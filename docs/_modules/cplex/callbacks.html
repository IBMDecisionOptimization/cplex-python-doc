<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cplex.callbacks &#8212; CPLEX Python API Reference Manual 22.1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=908d05d1" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/ibm_sphinx.css?v=ae0229bc" />
    
    <script src="../../_static/documentation_options.js?v=8a2b0fec"></script>
    <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    
    <script src="../../_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CPLEX Python API documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cplex.html" accesskey="U">cplex</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cplex.callbacks</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cplex.callbacks</h1><div class="highlight"><pre>
<span></span><span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># File: callback.py</span>
<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># Licensed Materials - Property of IBM</span>
<span class="c1"># 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21</span>
<span class="c1"># Copyright IBM Corporation 2008, 2024. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># US Government Users Restricted Rights - Use, duplication or</span>
<span class="c1"># disclosure restricted by GSA ADP Schedule Contract with</span>
<span class="c1"># IBM Corp.</span>
<span class="c1"># --------------------------------------------------------------------------</span>
<span class="sd">&quot;&quot;&quot;Callback classes for the CPLEX Python API.</span>

<span class="sd">This module defines the `Context` class which provides methods to query</span>
<span class="sd">information and perform all actions that can be performed from a generic</span>
<span class="sd">callback. See `Cplex.set_callback()`.</span>

<span class="sd">See the following examples for more information on generic callbacks:</span>

<span class="sd"> * admipex8.py</span>
<span class="sd"> * admipex9.py</span>
<span class="sd"> * bendersatsp2.py</span>

<span class="sd">This module also defines a hierarchy of classes for legacy callbacks,</span>
<span class="sd">many of which can be subclassed to define alternative behavior for the</span>
<span class="sd">algorithms in CPLEX. The methods provided by the classes allow you to</span>
<span class="sd">query information about the optimization in progress and to control the</span>
<span class="sd">optimization algorithm.</span>

<span class="sd">To use a subclassable legacy callback class, define a subclass of it that</span>
<span class="sd">defines a __call__ method. Then pass that class name to the</span>
<span class="sd">`Cplex.register_callback` method. The `Cplex` class will instantiate the</span>
<span class="sd">legacy callback class and return the instance of the class that was</span>
<span class="sd">created. If you wish to associate additional data with your callback</span>
<span class="sd">class, you may do so after it has been registered with the `Cplex` object.</span>

<span class="sd">See the following examples for more information on legacy callbacks:</span>

<span class="sd"> * admipex1.py</span>
<span class="sd"> * admipex2.py</span>
<span class="sd"> * admipex3.py</span>
<span class="sd"> * admipex5.py</span>
<span class="sd"> * admipex6.py</span>
<span class="sd"> * bendersatsp.py</span>
<span class="sd"> * lpex4.py</span>
<span class="sd"> * mipex4.py</span>

<span class="sd">Note</span>
<span class="sd">  If you operate the CPLEX Python API in parallel mode with callbacks</span>
<span class="sd">  registered, there will be a single instance of each of your callback</span>
<span class="sd">  classes shared among all threads.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_internal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal._callbackinfoenum</span><span class="w"> </span><span class="kn">import</span> <span class="n">CallbackInfo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">_constants</span> <span class="k">as</span> <span class="n">_const</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal._solutionstrategyenum</span><span class="w"> </span><span class="kn">import</span> <span class="n">SolutionStrategy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">_procedural</span> <span class="k">as</span> <span class="n">_proc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal._aux_functions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">apply_freeform_two_args</span><span class="p">,</span>
                                       <span class="n">apply_freeform_one_arg</span><span class="p">,</span>
                                       <span class="n">init_list_args</span><span class="p">,</span> <span class="n">convert</span><span class="p">,</span> <span class="n">max_arg_length</span><span class="p">,</span>
                                       <span class="n">validate_arg_lengths</span><span class="p">,</span> <span class="n">unzip</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal._matrices</span><span class="w"> </span><span class="kn">import</span> <span class="n">SparsePair</span><span class="p">,</span> <span class="n">_HBMatrix</span><span class="p">,</span> <span class="n">unpack_pair</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal._subinterfaces</span><span class="w"> </span><span class="kn">import</span> <span class="n">SolutionStatus</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">_pycplex</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">CplexError</span><span class="p">,</span> <span class="n">CplexSolverError</span><span class="p">,</span>
                         <span class="n">WrongNumberOfArgumentsError</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.constant_class</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConstantClass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.exceptions.error_codes</span><span class="w"> </span><span class="kn">import</span> <span class="n">CPXERR_UNSUPPORTED_OPERATION</span>

<div class="viewcode-block" id="Callback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Callback</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for Cplex callback classes.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Callback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Callback.__call__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.__call__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to be overridden by user-defined callback class.</span>

<span class="sd">        See the `Cplex.register_callback` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">CplexError</span><span class="p">(</span><span class="s2">&quot;Callback.__call__ is a pure virtual method&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_conv_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_col_index</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_col_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getcolindex</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_conv_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_row_index</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getrowindex</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
            <span class="n">name</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_conv_quad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_quad_index</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_quad_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getqconstrindex</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
            <span class="n">name</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_conv_sos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sos_index</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_sos_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getsosindex</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
            <span class="n">name</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="Callback.abort">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.abort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">abort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Terminates optimization.</span>

<span class="sd">        Note</span>
<span class="sd">          A call to abort should be followed immediately by a return</span>
<span class="sd">          statement. Calling other callback methods may override the</span>
<span class="sd">          effect of the abort statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_useraction&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_FAIL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Callback.get_end_time">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.get_end_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_end_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a time stamp for computing the time limit.</span>

<span class="sd">        Subtracting the return value of Callback.get_time() from the</span>
<span class="sd">        return value of this method yields the time remaining in</span>
<span class="sd">        seconds.</span>

<span class="sd">        The interpretation of this value as wall clock time or CPU</span>
<span class="sd">        time is controlled by the parameter clocktype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_ENDTIME</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="Callback.get_end_dettime">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.get_end_dettime">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_end_dettime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a deterministic time stamp in ticks.</span>

<span class="sd">        Subtracting the return value of Callback.get_dettime() from the</span>
<span class="sd">        return value of this method yields the time remaining in</span>
<span class="sd">        deterministic ticks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_ENDDETTIME</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="Callback.get_start_time">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.get_start_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a time stamp specifying when the solving process started.</span>

<span class="sd">        To compute elapsed time in seconds, subtract the result of</span>
<span class="sd">        Callback.get_time() from the result of this method. This computation</span>
<span class="sd">        yields either wallclock time (also known as real time) or CPU time,</span>
<span class="sd">        depending on the clock set by the clocktype parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_STARTTIME</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="Callback.get_start_dettime">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.get_start_dettime">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_start_dettime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a deterministic time stamp specifying when the solving process started.</span>

<span class="sd">        To compute elapsed deterministic time in ticks, subtract the result of</span>
<span class="sd">        Callback.get_dettime() from the result of this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_STARTDETTIME</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="Callback.get_time">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.get_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a time stamp for the current time.</span>

<span class="sd">        Subtracting the return value of this method from the return</span>
<span class="sd">        value of Callback.get_end_time() yields the time remaining in</span>
<span class="sd">        seconds.</span>

<span class="sd">        The interpretation of this value as wall clock time or CPU</span>
<span class="sd">        time is controlled by the parameter clocktype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_gettime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="Callback.get_dettime">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Callback.get_dettime">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dettime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a deterministic time stamp for the current time.</span>

<span class="sd">        Subtracting the return value of this method from the return</span>
<span class="sd">        value of Callback.get_end_dettime() yields the time remaining in</span>
<span class="sd">        deterministic ticks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getdettime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="OptimizationCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.OptimizationCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OptimizationCallback</span><span class="p">(</span><span class="n">Callback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for Cplex optimization callback classes.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_wherefrom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">get_wherefrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>

<div class="viewcode-block" id="OptimizationCallback.get_num_quadratic_constraints">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.OptimizationCallback.get_num_quadratic_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_quadratic_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of quadratic constraints in the problem.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getnumqconstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationCallback.get_num_cols">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.OptimizationCallback.get_num_cols">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of variables in the problem.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getnumcols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationCallback.get_num_rows">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.OptimizationCallback.get_num_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of linear constraints in the problem.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getnumrows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ContinuousCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ContinuousCallback</span><span class="p">(</span><span class="n">OptimizationCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for Cplex continuous callbacks.</span>

<span class="sd">    When Cplex is solving a problem by a simplex or barrier method,</span>
<span class="sd">    this callback will be called after the simplex or barrier</span>
<span class="sd">    callback, if any such callbacks are registered.</span>

<span class="sd">    During concurrent optimization, CPLEX calls the user-written</span>
<span class="sd">    callback only in the main thread, not in other concurrent threads.</span>

<span class="sd">    :undocumented: __init__, _wherefrom</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ContinuousCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;continuous&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setlpcallbackfunc</span></div>


<div class="viewcode-block" id="ContinuousCallback.get_dual_infeasibility">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback.get_dual_infeasibility">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dual_infeasibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a measure of the dual infeasibility of the problem.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_DUAL_INFMEAS</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContinuousCallback.get_primal_infeasibility">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback.get_primal_infeasibility">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_primal_infeasibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a measure of the primal infeasibility of the problem.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_PRIMAL_INFMEAS</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContinuousCallback.get_num_iterations">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback.get_num_iterations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of iterations completed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_ITCOUNT_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContinuousCallback.get_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback.get_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current value of the objective function.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wherefrom</span><span class="p">()</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_DUAL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
                <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_DUAL_OBJ</span><span class="p">,</span>
                <span class="n">CplexSolverError</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_PRIMAL_OBJ</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContinuousCallback.is_dual_feasible">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback.is_dual_feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_dual_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether or not the current solution is dual feasible.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wherefrom</span><span class="p">()</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_PRIMAL</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dual_infeasibility</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_DUAL_FEAS</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContinuousCallback.is_primal_feasible">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContinuousCallback.is_primal_feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_primal_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether or not the current solution is primal feasible.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wherefrom</span><span class="p">()</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_DUAL</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_primal_infeasibility</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_PRIMAL_FEAS</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SimplexCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.SimplexCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SimplexCallback</span><span class="p">(</span><span class="n">ContinuousCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for Cplex simplex callback classes.</span>

<span class="sd">    This callback will be used during execution of the primal simplex,</span>
<span class="sd">    dual simplex, or quadratic simplex algorithms.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SimplexCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.SimplexCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;simplex&quot;</span></div>
</div>



<div class="viewcode-block" id="BarrierCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BarrierCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BarrierCallback</span><span class="p">(</span><span class="n">ContinuousCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for Cplex barrier callback classes.</span>

<span class="sd">    This callback will be used during execution of the barrier or</span>
<span class="sd">    quadratic barrier algorithms.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BarrierCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BarrierCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;barrier&quot;</span></div>


<div class="viewcode-block" id="BarrierCallback.get_dual_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BarrierCallback.get_dual_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dual_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current dual value of the objective function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_DUAL_OBJ</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CrossoverCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CrossoverCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CrossoverCallback</span><span class="p">(</span><span class="n">OptimizationCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for Cplex crossover callback classes.</span>

<span class="sd">    This callback will be used during execution of a crossover</span>
<span class="sd">    algorithm.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CrossoverCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CrossoverCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;crossover&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setlpcallbackfunc</span></div>


<div class="viewcode-block" id="CrossoverCallback.get_num_dual_exchanges">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CrossoverCallback.get_num_dual_exchanges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_dual_exchanges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of dual exchanges performed so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CROSSOVER_DEXCH_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="CrossoverCallback.get_num_dual_pushes">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CrossoverCallback.get_num_dual_pushes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_dual_pushes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of dual pushes performed so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CROSSOVER_DPUSH_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="CrossoverCallback.get_num_primal_exchanges">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CrossoverCallback.get_num_primal_exchanges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_primal_exchanges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of primal exchanges performed so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CROSSOVER_PEXCH_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="CrossoverCallback.get_num_primal_pushes">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CrossoverCallback.get_num_primal_pushes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_primal_pushes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of primal pushes performed so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CROSSOVER_PPUSH_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="CrossoverCallback.get_num_superbasics">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CrossoverCallback.get_num_superbasics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_superbasics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of superbasic variables in the basis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CROSSOVER_SBCNT</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="QualityMetric">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.QualityMetric">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QualityMetric</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants defining metrics for the quality of the MIP solve.&quot;&quot;&quot;</span>
    <span class="n">kappa_stable</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_STABLE</span>
    <span class="n">kappa_suspicious</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_SUSPICIOUS</span>
    <span class="n">kappa_unstable</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_UNSTABLE</span>
    <span class="n">kappa_illposed</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_ILLPOSED</span>
    <span class="n">kappa_max</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_MAX</span>
    <span class="n">kappa_attention</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_ATTENTION</span></div>



<div class="viewcode-block" id="CutType">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CutType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CutType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arguments to MIPInfoCallback.get_num_cuts().&quot;&quot;&quot;</span>
    <span class="c1"># NB: If you edit these, look at _subinterfaces.py:CutType too!</span>
    <span class="c1">#     Also add the cut to the list of valid values get_num_cuts()!</span>
    <span class="n">cover</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_COVER_COUNT</span>
    <span class="n">GUB_cover</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_GUBCOVER_COUNT</span>
    <span class="n">flow_cover</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_FLOWCOVER_COUNT</span>
    <span class="n">clique</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CLIQUE_COUNT</span>
    <span class="n">fractional</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_FRACCUT_COUNT</span>
    <span class="n">MIR</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MIRCUT_COUNT</span>
    <span class="n">flow_path</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_FLOWPATH_COUNT</span>
    <span class="n">disjunctive</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_DISJCUT_COUNT</span>
    <span class="n">implied_bound</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_IMPLBD_COUNT</span>
    <span class="n">zero_half</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_ZEROHALFCUT_COUNT</span>
    <span class="n">multi_commodity_flow</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MCFCUT_COUNT</span>
    <span class="n">lift_and_project</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_LANDPCUT_COUNT</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_USERCUT_COUNT</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_TABLECUT_COUNT</span>
    <span class="n">solution_pool</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_SOLNPOOLCUT_COUNT</span>
    <span class="n">benders</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_BENDERS_COUNT</span></div>

    <span class="c1"># Not Implemented:</span>
    <span class="c1"># local_implied_bound</span>
    <span class="c1"># BQP</span>
    <span class="c1"># RLT</span>


<div class="viewcode-block" id="MIPInfoCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MIPInfoCallback</span><span class="p">(</span><span class="n">OptimizationCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for MIP informational callback classes.</span>

<span class="sd">    This callback will be used when CPLEX is solving a MIP problem.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">quality_metric</span> <span class="o">=</span> <span class="n">QualityMetric</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `QualityMetric()`&quot;&quot;&quot;</span>

    <span class="n">cut_type</span> <span class="o">=</span> <span class="n">CutType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CutType()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MIPInfoCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;MIP_info&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setinfocallbackfunc</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">lp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getnumcols</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">lp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getnumrows</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">lp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_quad</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getnumqconstrs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">lp</span><span class="p">)</span>

<div class="viewcode-block" id="MIPInfoCallback.get_num_cols">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_num_cols">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_num_rows">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_num_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_num_quadratic_constraints">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_num_quadratic_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_quadratic_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_quad</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_num_cuts">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_num_cuts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of cuts of type cut_type added so far.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cut_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_COVER_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_GUBCOVER_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_FLOWCOVER_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CLIQUE_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_FRACCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MIRCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_FLOWPATH_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_DISJCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_IMPLBD_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_ZEROHALFCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MCFCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_LANDPCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_USERCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_TABLECUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_SOLNPOOLCUT_COUNT</span><span class="p">,</span>
                            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_BENDERS_COUNT</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid value for cut_type (</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cut_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">cut_type</span><span class="p">,</span>
                                             <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_best_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_best_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_best_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the best objective value among unexplored nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_BEST_REMAINING</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_cutoff">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_cutoff">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current cutoff value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_CUTOFF</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_incumbent_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_incumbent_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_incumbent_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the objective value of the incumbent solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_BEST_INTEGER</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_incumbent_linear_slacks">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_incumbent_linear_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_incumbent_linear_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of linear slacks for the incumbent solution.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        self.get_incumbent_linear_slacks()</span>
<span class="sd">          return all linear slack values from the incumbent solution.</span>

<span class="sd">        self.get_incumbent_linear_slacks(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          slack values associated with the linear constraint whose</span>
<span class="sd">          index or name is i.</span>

<span class="sd">        self.get_incumbent_linear_slacks(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the slack values associated with the linear</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [self.get_incumbent_linear_slacks(i) for i in s]</span>

<span class="sd">        self.get_incumbent_linear_slacks(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices with begin</span>
<span class="sd">          &lt;= end or linear constraint names whose indices respect</span>
<span class="sd">          this order.  Returns the slack values associated with the</span>
<span class="sd">          linear constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end.  Equivalent to</span>
<span class="sd">          self.get_incumbent_linear_slacks(range(begin, end + 1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_incumbent_values</span><span class="p">())]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_slackfromx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">slacks</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">slacks</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_row</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_incumbent_quadratic_slacks">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_incumbent_quadratic_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_incumbent_quadratic_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of quadratic slacks for the incumbent solution.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        self.get_incumbent_quadratic_slacks()</span>
<span class="sd">          return all quadratic slack values from the incumbent</span>
<span class="sd">           solution.</span>

<span class="sd">        self.get_incumbent_quadratic_slacks(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns</span>
<span class="sd">          the slack values associated with the quadratic constraint</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        self.get_incumbent_quadratic_slacks(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the slack values associated with the</span>
<span class="sd">          quadratic constraints with indices the members of s.</span>
<span class="sd">          Equivalent to</span>
<span class="sd">          [self.get_incumbent_quadratic_slacks(i) for i in s]</span>

<span class="sd">        self.get_incumbent_quadratic_slacks(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the slack values associated with the</span>
<span class="sd">          quadratic constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          self.get_incumbent_quadratic_slacks(range(begin, end + 1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_incumbent_values</span><span class="p">())]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_qconstrslackfromx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">slacks</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_quad</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">slacks</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_quad</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_incumbent_values">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_incumbent_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_incumbent_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the variable values of the incumbent solution.</span>

<span class="sd">        There are four forms by which get_incumbent_values may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_incumbent_values()</span>
<span class="sd">          returns the entire incumbent solution</span>

<span class="sd">        self.get_incumbent_values(i)</span>
<span class="sd">          i must be a variable index or name.  Returns the value</span>
<span class="sd">          of the variable with index i in the incumbent solution.</span>

<span class="sd">        self.get_incumbent_values(s)</span>
<span class="sd">          s must be a sequence of variables indices or names.</span>
<span class="sd">          Returns a list of the values of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_incumbent_values(i) for i in s]</span>

<span class="sd">        self.get_incumbent_values(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the values of the variables with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_incumbent_values(range(begin, end + 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcallbackincumbent</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbackincumbent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getcallbackincumbent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_MIP_relative_gap">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_MIP_relative_gap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_MIP_relative_gap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current relative MIP gap.</span>

<span class="sd">        Accesses the current relative gap, like the routine</span>
<span class="sd">        CPXgetmiprelgap in the Callable Library. See CPXgetcallbackinfo</span>
<span class="sd">        and CPXgetmiprelgap in the Callable Library Reference Manual for</span>
<span class="sd">        more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MIP_REL_GAP</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_num_iterations">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_num_iterations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of iterations performed so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MIP_ITERATIONS_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_num_nodes">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_num_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nodes processed so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_COUNT_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_num_remaining_nodes">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_num_remaining_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_remaining_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of unexplored nodes remaining.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODES_LEFT_LONG</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.has_incumbent">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.has_incumbent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_incumbent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether or not an incumbent solution has been found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MIP_FEAS</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_float_quality">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_float_quality">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_float_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a measure of the quality of the MIP solution as a floating point value.</span>

<span class="sd">        The measure of the quality of a solution must be an attribute</span>
<span class="sd">        of self.quality_metric corresponding to a floating point</span>
<span class="sd">        quality metric.  Such metrics include:</span>

<span class="sd">        self.quality_metric.kappa_stable</span>
<span class="sd">        self.quality_metric.kappa_suspicious</span>
<span class="sd">        self.quality_metric.kappa_unstable</span>
<span class="sd">        self.quality_metric.kappa_illposed</span>
<span class="sd">        self.quality_metric.kappa_max</span>
<span class="sd">        self.quality_metric.kappa_attention</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_STABLE</span><span class="p">,</span>
                         <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_SUSPICIOUS</span><span class="p">,</span>
                         <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_UNSTABLE</span><span class="p">,</span>
                         <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_ILLPOSED</span><span class="p">,</span>
                         <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_MAX</span><span class="p">,</span>
                         <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_KAPPA_ATTENTION</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid value for which (</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">which</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span>
                                             <span class="n">CplexSolverError</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPInfoCallback.get_thread_num">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPInfoCallback.get_thread_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_thread_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the identifier for the thread from which the callback</span>
<span class="sd">        was invoked.</span>

<span class="sd">        See CPX_CALLBACK_INFO_MY_THREAD_NUM in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_MY_THREAD_NUM</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MIPCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MIPCallback</span><span class="p">(</span><span class="n">MIPInfoCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for MIP callback classes.</span>

<span class="sd">    This callback will be used when CPLEX is solving a MIP problem.</span>

<span class="sd">    :undocumented: __init__, _get_node_info, _get_seq_info</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MIPCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;MIP&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setmipcallbackfunc</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_node_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_info</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacknodeinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">which_node</span><span class="p">,</span> <span class="n">which_info</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_seq_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_info</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbackseqinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">which_node</span><span class="p">,</span> <span class="n">which_info</span><span class="p">)</span>

<div class="viewcode-block" id="MIPCallback.get_objective_coefficients">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPCallback.get_objective_coefficients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_objective_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the coefficients of the linear objective function.</span>

<span class="sd">        There are four forms by which get_objective_coefficients may</span>
<span class="sd">        be called.</span>

<span class="sd">        self.get_objective_coefficients()</span>
<span class="sd">          returns the entire objective function.</span>

<span class="sd">        self.get_objective_coefficients(i)</span>
<span class="sd">          i must be a variable index or name.  Returns the objective</span>
<span class="sd">          coefficient of the variable with index i.</span>

<span class="sd">        self.get_objective_coefficients(s)</span>
<span class="sd">          s must be a sequence of variable indices or names.  Returns</span>
<span class="sd">          a list of the objective coefficients of the variables with</span>
<span class="sd">          indices the members of s, in the same order as they appear</span>
<span class="sd">          in s.  Equivalent to [self.get_objective_coefficients(i)</span>
<span class="sd">          for i in s]</span>

<span class="sd">        self.get_objective_coefficients(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the objective coefficients of variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_objective_coefficients(range(begin, end + 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getobj</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                                        <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPCallback.get_current_node_depth">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MIPCallback.get_current_node_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_current_node_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the depth of the current node in the search tree.</span>

<span class="sd">        The root node has depth 0 (zero). The depth of other nodes is defined</span>
<span class="sd">        recursively as the depth of their parent node plus one.  In other</span>
<span class="sd">        words, the depth of a node is its distance in terms of the number of</span>
<span class="sd">        branches from the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The function is called get_current_node_depth() rather than</span>
        <span class="c1"># get_depth() (as in the other APIs) for historical reasons:</span>
        <span class="c1"># when we introduced the function we already had a get_depth()</span>
        <span class="c1"># function in the node callback which had a different signature and</span>
        <span class="c1"># different semantics</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacknodeinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_DEPTH_LONG</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FeasibilityStatus">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.FeasibilityStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FeasibilityStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feasibility status codes.&quot;&quot;&quot;</span>
    <span class="n">feasible</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_INTEGER_FEASIBLE</span>
    <span class="n">implied_feasible</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_IMPLIED_INTEGER_FEASIBLE</span>
    <span class="n">infeasible</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_INTEGER_INFEASIBLE</span></div>



<div class="viewcode-block" id="ControlCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ControlCallback</span><span class="p">(</span><span class="n">MIPCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for Cplex MIP control callback classes.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">feasibility_status</span> <span class="o">=</span> <span class="n">FeasibilityStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `FeasibilityStatus()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ControlCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_DEFAULT</span></div>


<div class="viewcode-block" id="ControlCallback.get_pseudo_costs">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_pseudo_costs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pseudo_costs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current pseudo costs.</span>

<span class="sd">        There are four forms by which get_pseudo_costs may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_pseudo_costs()</span>
<span class="sd">          returns a list of pairs with the pseudo costs for all the</span>
<span class="sd">           variables.</span>

<span class="sd">        self.get_pseudo_costs(i)</span>
<span class="sd">          i must be a variable index or name.  Returns a pair (up,</span>
<span class="sd">          down), where up is the up pseudo cost and down is the down</span>
<span class="sd">          pseudo cost of branching on the variable i.</span>

<span class="sd">        self.get_pseudo_costs(s)</span>
<span class="sd">          s must be a sequence of variable indices or names.  Returns</span>
<span class="sd">          a list of pairs (up, down) of pseudo costs of branching on</span>
<span class="sd">          the variables with indices the members of s, in the same</span>
<span class="sd">          order as they appear in s.  Equivalent to</span>
<span class="sd">          [self.get_pseudo_costs(i) for i in s]</span>

<span class="sd">        self.get_pseudo_costs(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of pairs (up, down) of pseudo costs of branching</span>
<span class="sd">          on the variables with indices between begin and end, inclusive</span>
<span class="sd">          of end. Equivalent to</span>
<span class="sd">          self.get_pseudo_costs(range(begin, end + 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcallbackpseudocosts</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">_proc</span><span class="o">.</span><span class="n">getcallbackpseudocosts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getcallbackpseudocosts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_feasibilities">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_feasibilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_feasibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current integer feasibility status.</span>

<span class="sd">        There are four forms by which get_feasibilities may be</span>
<span class="sd">        called.</span>

<span class="sd">        The return values are attributes of self.feasibility_status.</span>

<span class="sd">        self.get_feasibilities()</span>
<span class="sd">          returns a list with the feasibility status for all the</span>
<span class="sd">          variables.</span>

<span class="sd">        self.get_feasibilities(i)</span>
<span class="sd">          i must be a variable index or name.  Returns the</span>
<span class="sd">          feasibility status of the variable with index i.</span>

<span class="sd">        self.get_feasibilities(s)</span>
<span class="sd">          s must be a sequence of variable indices or names.  Returns</span>
<span class="sd">          a list of the feasibility statuses of the variables with</span>
<span class="sd">          indices the members of s, in the same order as they appear</span>
<span class="sd">          in s.  Equivalent to [self.get_feasibilities(i) for i in s]</span>

<span class="sd">        self.get_feasibilities(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the feasibility statuses of the variables</span>
<span class="sd">          with indices between begin and end, inclusive of end.</span>
<span class="sd">          Equivalent to self.get_feasibilities(range(begin, end + 1))</span>

<span class="sd">        Note</span>
<span class="sd">          Before you call this method from a solve callback, a</span>
<span class="sd">          solution must exist. That is, you must first create the</span>
<span class="sd">          solution by calling a CPLEX optimization method, and then</span>
<span class="sd">          you must verify that this optimization method generated a</span>
<span class="sd">          solution by checking its return value before you call the</span>
<span class="sd">          method get_feasibilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcallbacknodeintfeas</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacknodeintfeas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getcallbacknodeintfeas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_lower_bounds">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_lower_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the lower bounds at the current node.</span>

<span class="sd">        There are four forms by which get_lower_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_lower_bounds()</span>
<span class="sd">          returns a list with the lower bounds for all the variables.</span>

<span class="sd">        self.get_lower_bounds(i)</span>
<span class="sd">          i must be a variable index or name.  Returns the lower</span>
<span class="sd">          bound of the variable with index i.</span>

<span class="sd">        self.get_lower_bounds(s)</span>
<span class="sd">          s must be a sequence of variable indices or names.  Returns</span>
<span class="sd">          a list of the lower bounds of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_lower_bounds(i) for i in s]</span>

<span class="sd">        self.get_lower_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the lower bounds of the variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent</span>
<span class="sd">          to self.get_lower_bounds(range(begin, end + 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcallbacknodelb</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacknodelb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getcallbacknodelb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_upper_bounds">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_upper_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the upper bounds at the current node.</span>

<span class="sd">        There are four forms by which get_upper_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_upper_bounds()</span>
<span class="sd">          returns a list with the upper bounds for all the variables.</span>

<span class="sd">        self.get_upper_bounds(i)</span>
<span class="sd">          i must be a variable index or name.  Returns the upper</span>
<span class="sd">          bound of the variable with index i.</span>

<span class="sd">        self.get_upper_bounds(s)</span>
<span class="sd">          s must be a sequence of variable indices or names.  Returns</span>
<span class="sd">          a list of the upper bounds of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_upper_bounds(i) for i in s]</span>

<span class="sd">        self.get_upper_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the upper bounds of the variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_upper_bounds(range(begin, end + 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcallbacknodeub</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacknodeub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getcallbacknodeub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_node_data">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_node_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the user handle for the current node.</span>

<span class="sd">        Returns None if no handle is set for the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_USERHANDLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.set_node_data">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.set_node_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the user handle for the current node.</span>

<span class="sd">        Returns the user handle previously set for this node (or None</span>
<span class="sd">        if no handle was set).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbacksetuserhandle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_node_ID">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_node_ID">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sequence number of this node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_SEQNUM_LONG</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the value of the objective function at the current node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacknodeobjval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_linear_slacks">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_linear_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of linear slacks for the solution at the current node.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        self.get_linear_slacks()</span>
<span class="sd">          return all linear slack values from the problem at the</span>
<span class="sd">          current node.</span>

<span class="sd">        self.get_linear_slacks(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          slack values associated with the linear constraint whose</span>
<span class="sd">          index or name is i.</span>

<span class="sd">        self.get_linear_slacks(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the slack values associated with the linear</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [self.get_linear_slacks(i) for i in s]</span>

<span class="sd">        self.get_linear_slacks(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices with begin</span>
<span class="sd">          &lt;= end or linear constraint names whose indices respect</span>
<span class="sd">          this order.  Returns the slack values associated with the</span>
<span class="sd">          linear constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end.  Equivalent to</span>
<span class="sd">          self.get_linear_slacks(range(begin, end + 1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">())]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_slackfromx</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">slacks</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">slacks</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_row</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_quadratic_slacks">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_quadratic_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of quadratic slacks for the solution at the current node.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        self.get_quadratic_slacks()</span>
<span class="sd">          return all quadratic slack values from the problem at the</span>
<span class="sd">          current node.</span>

<span class="sd">        self.get_quadratic_slacks(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns</span>
<span class="sd">          the slack values associated with the quadratic constraint</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        self.get_quadratic_slacks(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the slack values associated with the</span>
<span class="sd">          quadratic constraints with indices the members of s.</span>
<span class="sd">          Equivalent to [self.get_quadratic_slacks(i) for i in s]</span>

<span class="sd">        self.get_quadratic_slacks(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the slack values associated with the</span>
<span class="sd">          quadratic constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          self.get_quadratic_slacks(range(begin, end + 1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">())]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_qconstrslackfromx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">slacks</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_quadratic_constraints</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">slacks</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_quad</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_values">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the solution values at the current node.</span>

<span class="sd">        In the case that the node LP is unbounded, this method returns</span>
<span class="sd">        a vector that corresponds to an unbounded direction, scaled so</span>
<span class="sd">        that at least one of its elements has magnitude</span>
<span class="sd">        cplex.infinity.  Thus, often the vector can be used directly,</span>
<span class="sd">        for example to separate a lazy constraint.  However, due to</span>
<span class="sd">        the presence of large values in the vector care must be taken</span>
<span class="sd">        to avoid potential numerical errors.  If in doubt,</span>
<span class="sd">        rescale the vector, and use it as an unbounded ray</span>
<span class="sd">        rather than a primal vector.</span>

<span class="sd">        There are four forms by which get_values may be called.</span>

<span class="sd">        self.get_values()</span>
<span class="sd">          returns the entire primal solution vector.</span>

<span class="sd">        self.get_values(i)</span>
<span class="sd">          i must be a variable index or name.  Returns the solution</span>
<span class="sd">          value of the variable with index i.</span>

<span class="sd">        self.get_values(s)</span>
<span class="sd">          s must be a sequence of variable indices or names.  Returns</span>
<span class="sd">          a list of the solution values of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_values(i) for i in s]</span>

<span class="sd">        self.get_values(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the solution values of variables with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_values(range(begin, end + 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcallbacknodex</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacknodex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getcallbacknodex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ControlCallback.get_SOS_feasibilities">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ControlCallback.get_SOS_feasibilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_SOS_feasibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current special ordered set feasibility status.</span>

<span class="sd">        There are four forms by which get_SOS_feasibilities may be</span>
<span class="sd">        called.</span>

<span class="sd">        Returns 1 if the SOS is feasible and 0 if it is not.</span>

<span class="sd">        self.get_SOS_feasibilties()</span>
<span class="sd">          Returns the feasibility statuses of all the special ordered</span>
<span class="sd">          sets.</span>

<span class="sd">        self.get_SOS_feasibilities(i)</span>
<span class="sd">          i must be a SOS index or name.  Returns the feasibility</span>
<span class="sd">          status of the special ordered set with index i.</span>

<span class="sd">        self.get_SOS_feasibilities(s)</span>
<span class="sd">          s must be a sequence of SOS indices or names.  Returns a</span>
<span class="sd">          list of the feasibility statuses of the special ordered</span>
<span class="sd">          sets with indices the members of s, in the same order as</span>
<span class="sd">          they appear in s.  Equivalent to</span>
<span class="sd">          [self.get_SOS_feasibilities(i) for i in s]</span>

<span class="sd">        self.get_SOS_feasibilities(begin, end)</span>
<span class="sd">          begin and end must be SOS indices or SOS names. Returns a list</span>
<span class="sd">          of the feasibility statuses of the special ordered sets with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_SOS_feasibilities(range(begin, end + 1))</span>

<span class="sd">        Note</span>
<span class="sd">          Before you call this method from a solve callback, a</span>
<span class="sd">          solution must exist. That is, you must first create the</span>
<span class="sd">          solution by calling a CPLEX optimization method, and then</span>
<span class="sd">          you must verify that this optimization method generated a</span>
<span class="sd">          solution by checking its return value before you call the</span>
<span class="sd">          method get_SOS_feasibilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">is_sos_feasible</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcallbacksosinfo</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_SOS_IS_FEASIBLE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">is_sos_feasible</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_sos</span><span class="p">,</span>
            <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getnumsos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">),</span> <span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="BranchType">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BranchType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants defining types of branches.&quot;&quot;&quot;</span>
    <span class="nb">any</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_TYPE_ANY</span>
    <span class="n">SOS1</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_TYPE_SOS1</span>
    <span class="n">SOS2</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_TYPE_SOS2</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_TYPE_VAR</span></div>



<div class="viewcode-block" id="BranchCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BranchCallback</span><span class="p">(</span><span class="n">ControlCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for branch callback classes.</span>

<span class="sd">    The user must be careful when using this class. Pruning a valid node</span>
<span class="sd">    can prune the optimal solution. Also, choosing a different branching</span>
<span class="sd">    variable can result in placing an invalid bound on a variable, in case</span>
<span class="sd">    the variable was already restricted to other bounds before.</span>

<span class="sd">    In particular, the user must not branch on variables that are implied</span>
<span class="sd">    feasible. ImpliedFeasible specifies that the variable has been</span>
<span class="sd">    presolved out. It will be feasible when all other integer variables</span>
<span class="sd">    are integer feasible. Branching on such variables can cut off</span>
<span class="sd">    feasible solutions.</span>

<span class="sd">    If the user intends to branch on continuous variables, the user must</span>
<span class="sd">    disable dual presolve reductions. To disable dual presolve</span>
<span class="sd">    reductions, set the parameter to control primal and dual reduction</span>
<span class="sd">    type, parameters.preprocessing.reduce, either to the value 1 (one)</span>
<span class="sd">    (that is, CPX_PREREDUCE_PRIMALONLY) or to the value 0 (zero) (that</span>
<span class="sd">    is, CPX_PREREDUCE_NOPRIMALORDUAL).</span>

<span class="sd">    Also, if the user intends to branch on continuous variables, the user</span>
<span class="sd">    must turn off reductions that may interfere with crushing or uncrushing.</span>
<span class="sd">    This is parameters.preprocessing.reformulations.</span>

<span class="sd">    By design, the CPLEX branch callback calculates and provides the</span>
<span class="sd">    branching decisions that CPLEX would make in case the user does not</span>
<span class="sd">    create any branches in the callback. Depending on variable selection</span>
<span class="sd">    and other features of your model, the computation of these candidate</span>
<span class="sd">    branches can be time-consuming. Consequently, if you know that you</span>
<span class="sd">    will never use the branching candidates suggested by CPLEX, then you</span>
<span class="sd">    can save time by disabling such features as strong branching. This</span>
<span class="sd">    callback will be used prior to branching at a node in the branch and</span>
<span class="sd">    cut tree.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">branch_type</span> <span class="o">=</span> <span class="n">BranchType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `BranchType()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BranchCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">fn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">_proc</span><span class="o">.</span><span class="n">setbranchcallbackfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">_proc</span><span class="o">.</span><span class="n">setbranchnosolncallbackfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;branch&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bound_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_begin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lu</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_estimate</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_branch_type</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="BranchCallback.get_branch">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.get_branch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_branch</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns one of the candidate branches at the current node.</span>

<span class="sd">        which_branch must be an integer such that 0 &lt;= which_branch &lt;</span>
<span class="sd">        self.get_num_branches().</span>

<span class="sd">        The return value of get_branch is a tuple t with two entries.</span>
<span class="sd">        The first entry is the node estimate for the specified branch.</span>
<span class="sd">        The second entry is a list of (var, dir, bnd) triples, where</span>
<span class="sd">        var is the index of a variable whose bound will change, bnd is</span>
<span class="sd">        the new bound, and dir is one of &quot;L&quot;, &quot;U&quot;, and &quot;B&quot;, indicating</span>
<span class="sd">        that the branch will change the lower bound, the upper bound,</span>
<span class="sd">        or both, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which_branch</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">which_branch</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CplexError</span><span class="p">(</span><span class="s2">&quot;BranchCallback.get_branch: Bad branch index&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">which_branch</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bound_count</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_begin</span><span class="p">[</span><span class="n">which_branch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_begin</span><span class="p">[</span><span class="n">which_branch</span><span class="p">]:</span> <span class="n">end</span><span class="p">]</span>
        <span class="n">bnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_begin</span><span class="p">[</span><span class="n">which_branch</span><span class="p">]:</span> <span class="n">end</span><span class="p">]</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lu</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_begin</span><span class="p">[</span><span class="n">which_branch</span><span class="p">]:</span> <span class="n">end</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_estimate</span><span class="p">[</span><span class="n">which_branch</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">bnds</span><span class="p">)))</span></div>


<div class="viewcode-block" id="BranchCallback.get_branch_type">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.get_branch_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_branch_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the type of the branch.</span>

<span class="sd">        One of the following:</span>
<span class="sd">        self.branch_type.any</span>
<span class="sd">        self.branch_type.SOS1</span>
<span class="sd">        self.branch_type.SOS2</span>
<span class="sd">        self.branch_type.variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branch_type</span></div>


<div class="viewcode-block" id="BranchCallback.get_num_branches">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.get_num_branches">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of nodes Cplex will create from this branch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_count</span></div>


<div class="viewcode-block" id="BranchCallback.is_integer_feasible">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.is_integer_feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_integer_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether or not the current node is integer feasible.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_branches</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="BranchCallback.make_branch">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.make_branch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective_estimate</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Makes a new branch with the specified data.</span>

<span class="sd">        objective_estimate is a float representing the estimated</span>
<span class="sd">        objective value resulting from the specified branch.</span>

<span class="sd">        variables is a sequence of (var, dir, bnd) triples specifying</span>
<span class="sd">        the variables on which to branch.  var must be an index of a</span>
<span class="sd">        variable, dir must be one of &quot;L&quot; and &quot;U&quot;, indicating that the</span>
<span class="sd">        bound is a lower or upper bound, respectively, and bnd is an</span>
<span class="sd">        integer specifying the new bound for the variable.</span>

<span class="sd">        constraints is a sequence of (vec, sense, rhs) triples</span>
<span class="sd">        specifying the constraints with which to branch.  vec must be</span>
<span class="sd">        either an instance of SparsePair or a sequence with two</span>
<span class="sd">        entries, the first of which specifies the indices and the</span>
<span class="sd">        second of which specifies the values of the constraint.  rhs</span>
<span class="sd">        must be a float determining the righthand side of the</span>
<span class="sd">        constraint.  sense must be one of &quot;L&quot;, &quot;G&quot;, or &quot;E&quot;, specifying</span>
<span class="sd">        whether the constraint is a less-than-or-equal-to (&lt;=),</span>
<span class="sd">        greater-than-or-equal-to (&gt;=), or equality constraint.</span>

<span class="sd">        node_data may be any object to be associated with the created</span>
<span class="sd">        node.  It can be queried by the get_node_data methods of the</span>
<span class="sd">        IncumbentCallback class and the NodeCallback class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">constraints</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
        <span class="n">obje</span> <span class="o">=</span> <span class="n">objective_estimate</span>
        <span class="k">if</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">bnds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="n">rmat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sense</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">seqnum</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">branchcallbackbranchgeneral</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rmat</span><span class="o">.</span><span class="n">matbeg</span><span class="p">,</span>
            <span class="n">rmat</span><span class="o">.</span><span class="n">matind</span><span class="p">,</span> <span class="n">rmat</span><span class="o">.</span><span class="n">matval</span><span class="p">,</span> <span class="n">obje</span><span class="p">,</span> <span class="n">node_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_SET</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">seqnum</span><span class="p">,)</span></div>


<div class="viewcode-block" id="BranchCallback.make_cplex_branch">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.make_cplex_branch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_cplex_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_branch</span><span class="p">,</span> <span class="n">node_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replicates a CPLEX branch.</span>

<span class="sd">        This method replicates the n-th branch that CPLEX would create</span>
<span class="sd">        at the current node. The purpose of this method is to branch</span>
<span class="sd">        exactly like CPLEX, but at the same time attach a user object to</span>
<span class="sd">        the newly created node.</span>

<span class="sd">        which_branch must be an integer such that 0 &lt;= which_branch &lt;</span>
<span class="sd">        self.get_num_branches().</span>

<span class="sd">        node_data may be any object to be associated with the created</span>
<span class="sd">        node.  It can be queried by the get_node_data methods of various</span>
<span class="sd">        callback classes.</span>

<span class="sd">        This method returns the sequence number of the newly created</span>
<span class="sd">        node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seqnum</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">branchcallbackbranchasCPLEX</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
                                                   <span class="n">which_branch</span><span class="p">,</span>
                                                   <span class="n">node_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_SET</span>
        <span class="k">return</span> <span class="n">seqnum</span></div>


<div class="viewcode-block" id="BranchCallback.prune">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.BranchCallback.prune">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes the current node from the search tree.</span>

<span class="sd">        Note</span>
<span class="sd">          Prune must not be called in combination with make_branch.</span>
<span class="sd">          Prune is not compatible with the populate_solution_pool</span>
<span class="sd">          method of the Cplex class because</span>
<span class="sd">          that method retains fathomed nodes for subsequent use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_SET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>



<div class="viewcode-block" id="CutCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.CutCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CutCallback</span><span class="p">(</span><span class="n">ControlCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for user cut and lazy constraint callback classes.</span>

<span class="sd">    :undocumented: add, add_local</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">use_cut</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_cut</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">use_cut</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">use_cut</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">use_cut</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">cutcallbackadd</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
            <span class="n">values</span><span class="p">,</span> <span class="n">use_cut</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">cutcallbackaddlocal</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">values</span><span class="p">)</span></div>



<div class="viewcode-block" id="UseConstraint">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UseConstraint">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UseConstraint</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants to specify when to use the added constraint&quot;&quot;&quot;</span>
    <span class="n">force</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_USECUT_FORCE</span>
    <span class="n">purge</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_USECUT_PURGE</span></div>



<div class="viewcode-block" id="LazyConstraintCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.LazyConstraintCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LazyConstraintCallback</span><span class="p">(</span><span class="n">CutCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for lazy constraint callback classes.</span>

<span class="sd">    This callback will be used when CPLEX finds a new integer</span>
<span class="sd">    feasible solution and when CPLEX finds that the LP relaxation</span>
<span class="sd">    at the current node is unbounded.</span>

<span class="sd">    Note:</span>
<span class="sd">      The lazy constraint callback may be invoked during MIP start</span>
<span class="sd">      processing.  In that case get_solution_source returns</span>
<span class="sd">      mip_start_solution.  When this value is returned some special</span>
<span class="sd">      considerations apply:</span>

<span class="sd">        - MIP start processing occurs very early in the solution process.</span>
<span class="sd">          At this point no search tree is setup yet and there are no</span>
<span class="sd">          search tree nodes yet.  Consequently, a lot of the callback</span>
<span class="sd">          methods that require a node context will fail in this</span>
<span class="sd">          situation.</span>
<span class="sd">        - Lazy constraints separated when processing a MIP start will be</span>
<span class="sd">          discarded after that MIP start has been processed. This means</span>
<span class="sd">          that the callback may have to separate the same constraint</span>
<span class="sd">          again for the next MIP start or for a solution that is found</span>
<span class="sd">          later in the solution process.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">use_constraint</span> <span class="o">=</span> <span class="n">UseConstraint</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `UseConstraint()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="LazyConstraintCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.LazyConstraintCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;lazycon&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setlazyconstraintcallbackfunc</span></div>


<div class="viewcode-block" id="LazyConstraintCallback.add">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.LazyConstraintCallback.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">use</span><span class="o">=</span><span class="n">use_constraint</span><span class="o">.</span><span class="n">force</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a linear constraint to the current subproblem.</span>

<span class="sd">        constraint must be either a SparsePair instance or a list of</span>
<span class="sd">        two lists, the first of which specifies variables, the second</span>
<span class="sd">        of which specifies the values of the constraint.</span>

<span class="sd">        sense must be a single-character string; (&quot;L&quot;, &quot;G&quot;, &quot;E&quot;)</span>

<span class="sd">        rhs is a float, specifying the righthand side of the constraint.</span>

<span class="sd">        use indicates under what circumstances the constraint should</span>
<span class="sd">        be used.  It can take the following values:</span>

<span class="sd">        self.use_constraint.force (default) : force CPLEX to use the constraint</span>
<span class="sd">        self.use_constraint.purge           : allow CPLEX to purge the constraint</span>

<span class="sd">        When you add a lazy constraint with the nondefault value purge,</span>
<span class="sd">        you authorize CPLEX to purge (that is, to eliminate) the lazy</span>
<span class="sd">        constraint under certain circumstances, for example, if the</span>
<span class="sd">        lazy constraint becomes slack. Consequently, in view of such</span>
<span class="sd">        purging, you must not assume that any previously added constraints</span>
<span class="sd">        are still in current relaxation. In other words, the purged</span>
<span class="sd">        lazy constraint may be violated in subsequent relaxations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">use</span><span class="p">)</span></div>


<div class="viewcode-block" id="LazyConstraintCallback.add_local">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.LazyConstraintCallback.add_local">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a linear local constraint to the current subproblem.</span>

<span class="sd">        A local constraint is a constraint that will only be added to</span>
<span class="sd">        the problem at the current node and the subtree rooted by the</span>
<span class="sd">        current node. It will not be added to the constraint matrix of</span>
<span class="sd">        the original model.</span>

<span class="sd">        constraint must be either a SparsePair instance or a list of</span>
<span class="sd">        two lists, the first of which specifies variables, the second</span>
<span class="sd">        of which specifies the values of the constraint.</span>

<span class="sd">        sense must be a single-character string; (&quot;L&quot;, &quot;G&quot;, &quot;E&quot;)</span>

<span class="sd">        rhs is a float, specifying the righthand side of the constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_local</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>


<div class="viewcode-block" id="LazyConstraintCallback.is_unbounded_node">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.LazyConstraintCallback.is_unbounded_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_unbounded_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the current LP relaxation is unbounded, False otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wherefrom</span><span class="p">()</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_CUT_UNBD</span></div>


<div class="viewcode-block" id="LazyConstraintCallback.get_solution_source">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.LazyConstraintCallback.get_solution_source">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_solution_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the source of the solution for which the lazy constraint callback was invoked.</span>

<span class="sd">        The possible return values are:</span>

<span class="sd">        IncumbentCallback.solution_source.node_solution: The integral solution is</span>
<span class="sd">        the solution to the LP relaxation of a node in the MIP search</span>
<span class="sd">        tree.</span>

<span class="sd">        IncumbentCallback.solution_source.heuristic_solution: The integral solution</span>
<span class="sd">        has been found by a CPLEX internal heuristic.</span>

<span class="sd">        IncumbentCallback.solution_source.mipstart_solution: The integral solution has been</span>
<span class="sd">        found during MIP start processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_LAZY_SOURCE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">IncumbentCallback</span><span class="o">.</span><span class="n">solution_source</span>
        <span class="n">switcher</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_NODE</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">node_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_HEUR</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">heuristic_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_MIPSTART</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">mipstart_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_USER</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">user_solution</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">switcher</span><span class="p">[</span><span class="n">node_info</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="UseCut">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UseCut">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UseCut</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants to specify when to use the added cut.&quot;&quot;&quot;</span>
    <span class="n">force</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_USECUT_FORCE</span>
    <span class="n">purge</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_USECUT_PURGE</span>
    <span class="nb">filter</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_USECUT_FILTER</span></div>



<div class="viewcode-block" id="UserCutCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UserCutCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UserCutCallback</span><span class="p">(</span><span class="n">CutCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for lazy constraint callback classes.</span>

<span class="sd">    This callback will be used within the cut loop that CPLEX calls at</span>
<span class="sd">    each node of the branch and cut algorithm.  It will be called once</span>
<span class="sd">    after CPLEX has ended its own cut generation loop so that the user</span>
<span class="sd">    can specify additional cuts to be added to the cut pool.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">use_cut</span> <span class="o">=</span> <span class="n">UseCut</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `UseCut()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="UserCutCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UserCutCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;usercut&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setusercutcallbackfunc</span></div>


<div class="viewcode-block" id="UserCutCallback.add">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UserCutCallback.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">use</span><span class="o">=</span><span class="n">use_cut</span><span class="o">.</span><span class="n">force</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a linear cut to to the current subproblem.</span>

<span class="sd">        cut must be either a SparsePair instance or a list of two</span>
<span class="sd">        lists, the first of which specifies variables, the second of</span>
<span class="sd">        which specifies the values of the cut.</span>

<span class="sd">        sense must be  a single-character string; (&quot;L&quot;, &quot;G&quot;, &quot;E&quot;)</span>

<span class="sd">        rhs is a float, specifying the righthand side of the cut.</span>

<span class="sd">        use indicates under what circumstances the cut should be used.</span>
<span class="sd">        It can take the following values</span>

<span class="sd">        self.use_cut.force (default) : force CPLEX to use the cut</span>
<span class="sd">        self.use_cut.purge           : allow CPLEX to purge the cut</span>
<span class="sd">        self.use_cut.filter          : treat as cuts CPLEX creates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">use</span><span class="p">)</span></div>


<div class="viewcode-block" id="UserCutCallback.add_local">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UserCutCallback.add_local">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a linear local cut to the current subproblem.</span>

<span class="sd">        A local cut is a cut that is only valid at the current</span>
<span class="sd">        node and the subtree rooted by the current node. It does</span>
<span class="sd">        not need to be globally valid.</span>

<span class="sd">        cut must be either a SparsePair instance or a list of two</span>
<span class="sd">        lists, the first of which specifies variables, the second of</span>
<span class="sd">        which specifies the values of the cut.</span>

<span class="sd">        sense must be  a single-character string; (&quot;L&quot;, &quot;G&quot;, &quot;E&quot;)</span>

<span class="sd">        rhs is a float, specifying the righthand side of the cut.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_local</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>


<div class="viewcode-block" id="UserCutCallback.is_after_cut_loop">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UserCutCallback.is_after_cut_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_after_cut_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if called after the cut loop, False otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wherefrom</span><span class="p">()</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_CUT_LAST</span></div>


<div class="viewcode-block" id="UserCutCallback.abort_cut_loop">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.UserCutCallback.abort_cut_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">abort_cut_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Terminate the cut loop and proceed with branching.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_ABORT_CUT_LOOP</span></div>
</div>



<div class="viewcode-block" id="MethodType">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.MethodType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MethodType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants defining methods for solving the node LP.&quot;&quot;&quot;</span>
    <span class="n">primal</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_PRIMAL</span>
    <span class="n">dual</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_DUAL</span>
    <span class="n">barrier</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_BARRIER</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_NET</span></div>



<div class="viewcode-block" id="HSCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HSCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HSCallback</span><span class="p">(</span><span class="n">ControlCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for heuristic and solve callback classes.&quot;&quot;&quot;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_subinterfaces</span><span class="o">.</span><span class="n">SolutionStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `_internal._subinterfaces.SolutionStatus()` &quot;&quot;&quot;</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `MethodType()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="HSCallback.get_cplex_status">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HSCallback.get_cplex_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cplex_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the solution status of the current subproblem.</span>

<span class="sd">        Returns an attribute of self.status.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getstat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="HSCallback.is_dual_feasible">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HSCallback.is_dual_feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_dual_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether the solution of the current subproblem is dual feasible.&quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_solninfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="HSCallback.is_primal_feasible">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HSCallback.is_primal_feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_primal_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether the solution of the current subproblem is primal feasible.&quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_solninfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="HSCallback.solve">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HSCallback.solve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alg</span><span class="o">=</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_DUAL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solves the current subproblem.</span>

<span class="sd">        The value of alg, if specified, determines the algorithm to</span>
<span class="sd">        use to solve the current subproblem.</span>

<span class="sd">        self.method.primal  : primal simplex</span>

<span class="sd">        self.method.dual    : dual simplex</span>

<span class="sd">        self.method.barrier : barrier</span>

<span class="sd">        self.method.network : network</span>

<span class="sd">        If this method generates a feasible solution it returns True,</span>
<span class="sd">        otherwise it returns False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alg</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_PRIMAL</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_primopt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_DUAL</span><span class="p">,</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_AUTOMATIC</span><span class="p">):</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_dualopt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_BARRIER</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_hybbaropt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_ALG_NET</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_hybnetopt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CplexError</span><span class="p">(</span><span class="s2">&quot;HSCallback.solve: bad algorithm identifier&quot;</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cplex_status</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">optimal</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">feasible</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">MIP_optimal</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">MIP_feasible</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="HeuristicCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HeuristicCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HeuristicCallback</span><span class="p">(</span><span class="n">HSCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for heuristic callback classes.</span>

<span class="sd">    This callback will be used after solving each subproblem and at</span>
<span class="sd">    the root node before each round of cuts is added to the problem</span>
<span class="sd">    and resolved.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HeuristicCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HeuristicCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;heuristic&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setheuristiccallbackfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="HeuristicCallback.set_bounds">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HeuristicCallback.set_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the bounds for a set of variables.</span>

<span class="sd">        Can be called by two forms.</span>

<span class="sd">        self.set_bounds(i, lb, ub)</span>
<span class="sd">          i must be a variable name or index and lb and ub must be</span>
<span class="sd">          real numbers.  Sets the lower bound and upper bound of the</span>
<span class="sd">          variable whose index or name is i to lb and ub,</span>
<span class="sd">          respectively.</span>

<span class="sd">        self.set_lower_bounds(seq_of_triples)</span>
<span class="sd">          seq_of_triples must be a list or tuple of tuples (i, lb, ub),</span>
<span class="sd">          each of which consists of a variable name or index and</span>
<span class="sd">          two real numbers.  Sets the bounds of the specified</span>
<span class="sd">          variables to the corresponding values.  Equivalent to</span>
<span class="sd">          [self.set_lower_bounds(triple[0], triple[1], triple[2]) for</span>
<span class="sd">          triple in seq_of_triples].</span>

<span class="sd">        Note</span>
<span class="sd">          The variables specified must not have been removed by</span>
<span class="sd">          presolve.</span>

<span class="sd">        Note</span>
<span class="sd">          These bound changes affect only the problem at the current</span>
<span class="sd">          node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">vars</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_getprestat_c</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">pstat</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pstat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CplexError</span><span class="p">(</span>
                        <span class="s2">&quot;Variable removed by presolve: cannot change bounds&quot;</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lu</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
            <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ub</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">lu</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">lu</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">])</span>
                <span class="n">bd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">lu</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">lu</span><span class="p">,</span> <span class="s2">&quot;LU&quot;</span><span class="p">])</span>
                <span class="n">bd</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">lb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ub</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_chgbds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lu</span><span class="p">,</span> <span class="n">bd</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="HeuristicCallback.set_solution">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.HeuristicCallback.set_solution">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">objective_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets a solution to be used as the incumbent.</span>

<span class="sd">        solution is either an instance of SparsePair or a sequence of</span>
<span class="sd">        length two.  If it is a sequence, the first entry is a</span>
<span class="sd">        sequence of variable indices or names whose values are to be</span>
<span class="sd">        changed and the second entry is a sequence of floats with the</span>
<span class="sd">        corresponding new solution values.  Variables whose indices</span>
<span class="sd">        are not specified remain unchanged.</span>

<span class="sd">        If objective_value is specified, it is taken as the objective</span>
<span class="sd">        value of the new solution.  Otherwise, the objective value is</span>
<span class="sd">        computed.</span>

<span class="sd">        Do not call this method multiple times.</span>
<span class="sd">        Calling it again will overwrite any previously specified solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">vars</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">objective_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">objective_value</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">obj_coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_objective_coefficients</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">):</span>
                <span class="n">objective_value</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">obj_coef</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objective_value</span> <span class="o">=</span> <span class="n">objective_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_SET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_feasibility</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>



<div class="viewcode-block" id="SolveCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.SolveCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolveCallback</span><span class="p">(</span><span class="n">HSCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for solve callback classes.</span>

<span class="sd">    This callback can be used to solve node relaxations during branch</span>
<span class="sd">    and cut search.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SolveCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.SolveCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;solve&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setsolvecallbackfunc</span></div>


<div class="viewcode-block" id="SolveCallback.set_start">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.SolveCallback.set_start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the starting vectors for the next solve.</span>

<span class="sd">        The arguments primal and dual must either be instances of</span>
<span class="sd">        SparsePair or sequences of length two.  If they are sequences,</span>
<span class="sd">        the first entry is a sequence of indices or names specifying</span>
<span class="sd">        the columns or rows whose values are to be set, and the second</span>
<span class="sd">        entry is a sequence of floats with the corresponding new</span>
<span class="sd">        values.</span>

<span class="sd">        If primal is specified but dual is not, no dual values will be</span>
<span class="sd">        stored.  If dual is specified but primal is not, no primal</span>
<span class="sd">        values will be stored.</span>

<span class="sd">        Variables whose indices are not specified will be set to 0.0.</span>

<span class="sd">        Note</span>
<span class="sd">          If presolve is enabled, attempting to set dual values in</span>
<span class="sd">          this method will raise an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">primal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">primal</span> <span class="o">=</span> <span class="n">SparsePair</span><span class="p">([],</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">dual</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dual</span> <span class="o">=</span> <span class="n">SparsePair</span><span class="p">([],</span> <span class="p">[])</span>
        <span class="n">var</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">primal</span><span class="p">)</span>
        <span class="n">rng</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">dual</span><span class="p">)</span>
        <span class="n">prim</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span>
        <span class="n">dual</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">()</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_row</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">prim</span><span class="p">[</span><span class="n">var</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pi</span><span class="p">):</span>
            <span class="n">dual</span><span class="p">[</span><span class="n">rng</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">var</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_crushx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="n">prim</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
                                   <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">prim</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rng</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_crushpi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="n">dual</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
                                   <span class="n">status</span><span class="p">,</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">CplexError</span><span class="p">(</span>
                    <span class="s2">&quot;Presolve must be disabled to set dual vectors in SolveCallback.set_start&quot;</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_copystart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">dual</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolveCallback.use_solution">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.SolveCallback.use_solution">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">use_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tell CPLEX to use the resident solution after calling solve.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_SET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>



<div class="viewcode-block" id="SolutionSource">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.SolutionSource">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolutionSource</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attributes defining possible solution sources.&quot;&quot;&quot;</span>
    <span class="n">node_solution</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_NODESOLN</span>
    <span class="n">heuristic_solution</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_HEURSOLN</span>
    <span class="n">user_solution</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_USERSOLN</span>
    <span class="n">mipstart_solution</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_MIPSTART</span></div>



<div class="viewcode-block" id="IncumbentCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IncumbentCallback</span><span class="p">(</span><span class="n">MIPCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for incumbent callback classes.</span>

<span class="sd">    This callback will be used after each new potential incumbent is found.</span>
<span class="sd">    If the callback is used to reject incumbents, the user must set</span>
<span class="sd">    the parameter</span>
<span class="sd">    c.parameters.preprocessing.reduce either to the value</span>
<span class="sd">    1 (one) to restrict presolve to primal reductions only or to 0 (zero)</span>
<span class="sd">    to disable all presolve reductions. This setting of the parameter is</span>
<span class="sd">    not necessary if the incumbent callback is used for other purposes.</span>

<span class="sd">    Note</span>
<span class="sd">      The incumbent callback may be invoked during MIP start processing.</span>
<span class="sd">      In that case get_solution_source will return mip_start_solution.</span>
<span class="sd">      In this situation the following special consideration applies:</span>

<span class="sd">      - MIP start processing occurs very early in the solution process.</span>
<span class="sd">        At this point no search tree is setup yet and there are no search</span>
<span class="sd">        tree nodes yet.  Consequently, a lot of the callback methods</span>
<span class="sd">        that require a node context will fail in this situation.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">solution_source</span> <span class="o">=</span> <span class="n">SolutionSource</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `SolutionSource()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IncumbentCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;incumbent&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setincumbentcallbackfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_DEFAULT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objective_value</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="IncumbentCallback.get_node_data">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.get_node_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the user handle for the current node.</span>

<span class="sd">        Returns None if no handle is set for the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_USERHANDLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="IncumbentCallback.set_node_data">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.set_node_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the user handle for the current node.</span>

<span class="sd">        Returns the user handle previously set for this node (or None</span>
<span class="sd">        if no handle was set).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbacksetuserhandle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="IncumbentCallback.get_node_ID">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.get_node_ID">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sequence number of the current node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_SEQNUM_LONG</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="IncumbentCallback.get_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.get_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the objective value of the potential incumbent.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective_value</span></div>


<div class="viewcode-block" id="IncumbentCallback.get_linear_slacks">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.get_linear_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of linear slacks for the solution at the current node.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        self.get_linear_slacks()</span>
<span class="sd">          return all linear slack values from the problem at the</span>
<span class="sd">          current node.</span>

<span class="sd">        self.get_linear_slacks(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          slack values associated with the linear constraint whose</span>
<span class="sd">          index or name is i.</span>

<span class="sd">        self.get_linear_slacks(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the slack values associated with the linear</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [self.get_linear_slacks(i) for i in s]</span>

<span class="sd">        self.get_linear_slacks(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices with begin</span>
<span class="sd">          &lt;= end or linear constraint names whose indices respect</span>
<span class="sd">          this order.  Returns the slack values associated with the</span>
<span class="sd">          linear constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end.  Equivalent to</span>
<span class="sd">          self.get_linear_slacks(range(begin, end + 1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_slackfromx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">slacks</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_rows</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">slacks</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_row</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IncumbentCallback.get_quadratic_slacks">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.get_quadratic_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a set of quadratic slacks for the solution at the current node.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        self.get_quadratic_slacks()</span>
<span class="sd">          return all quadratic slack values from the problem at the</span>
<span class="sd">          current node.</span>

<span class="sd">        self.get_quadratic_slacks(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns</span>
<span class="sd">          the slack values associated with the quadratic constraint</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        self.get_quadratic_slacks(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the slack values associated with the</span>
<span class="sd">          quadratic constraints with indices the members of s.</span>
<span class="sd">          Equivalent to [self.get_quadratic_slacks(i) for i in s]</span>

<span class="sd">        self.get_quadratic_slacks(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or</span>
<span class="sd">          quadratic constraint names. Returns the slack values associated</span>
<span class="sd">          with the quadratic constraints with indices between begin and</span>
<span class="sd">          end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_quadratic_slacks(range(begin, end + 1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">cb_qconstrslackfromx</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">from_cb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">slacks</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_quadratic_constraints</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">slacks</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_quad</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IncumbentCallback.get_values">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.get_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the potential incumbent solution values.</span>

<span class="sd">        There are four forms by which get_values may be called.</span>

<span class="sd">        self.get_values()</span>
<span class="sd">          returns the entire potential incumbent.</span>

<span class="sd">        self.get_values(i)</span>
<span class="sd">          i must be a variable index or name.  Returns the potential</span>
<span class="sd">          incumbent value of the variable with index i.</span>

<span class="sd">        self.get_values(s)</span>
<span class="sd">          s must be a sequence of variable indices or names.  Returns</span>
<span class="sd">          a list of the potential incumbent values of the variables</span>
<span class="sd">          with indices the members of s, in the same order as they</span>
<span class="sd">          appear in s.  Equivalent to [self.get_values(i) for i in s]</span>

<span class="sd">        self.get_values(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the potential incumbent values of variables</span>
<span class="sd">          with indices between begin and end, inclusive of end.</span>
<span class="sd">          Equivalent to self.get_values(range(begin, end + 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getx</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_cols</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_col</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IncumbentCallback.get_solution_source">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.get_solution_source">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_solution_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the source of the solution for which the incumbent callback was invoked.</span>

<span class="sd">        The possible return values are:</span>

<span class="sd">        self.solution_source.node_solution: The integral solution is</span>
<span class="sd">        the solution to the LP relaxation of a node in the MIP search</span>
<span class="sd">        tree.</span>

<span class="sd">        self.solution_source.heuristic_solution: The integral solution</span>
<span class="sd">        has been found by a CPLEX internal heuristic.</span>

<span class="sd">        self.solution_source.user_solution: The integral solution has been</span>
<span class="sd">        found by the user in the heuristic callback.</span>

<span class="sd">        self.solution_source.mipstart_solution: The integral solution has been</span>
<span class="sd">        found during MIP start processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wherefrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wherefrom</span><span class="p">()</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution_source</span>
        <span class="n">switcher</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_NODESOLN</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">node_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_HEURSOLN</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">heuristic_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_USERSOLN</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">user_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_MIP_INCUMBENT_MIPSTART</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">mipstart_solution</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">switcher</span><span class="p">[</span><span class="n">wherefrom</span><span class="p">]</span></div>


<div class="viewcode-block" id="IncumbentCallback.reject">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.IncumbentCallback.reject">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells Cplex not to use the potential incumbent.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_SET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_feasible</span> <span class="o">=</span> <span class="kc">False</span></div>
</div>



<div class="viewcode-block" id="NodeCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeCallback</span><span class="p">(</span><span class="n">MIPCallback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for node callback classes.</span>

<span class="sd">    This callback will be used before CPLEX enters a node, and can select</span>
<span class="sd">    a different node to be entered instead.</span>

<span class="sd">    :undocumented: __init__, __conditionally_convert</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__conditionally_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">which_node</span><span class="p">,</span> <span class="nb">type</span><span class="p">(())):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_number</span><span class="p">(</span><span class="n">which_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">which_node</span>

<div class="viewcode-block" id="NodeCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">setnodecallbackfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_DEFAULT</span></div>


<div class="viewcode-block" id="NodeCallback.get_branch_variable">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_branch_variable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_branch_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the index of the variable used to branch at node which_node.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_VAR</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="NodeCallback.get_depth">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the depth in the search tree of node which_node.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_DEPTH_LONG</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="NodeCallback.get_current_node_depth">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_current_node_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_current_node_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the depth of the current node in the search tree.</span>

<span class="sd">        This method always raises an exception since the node callback is not</span>
<span class="sd">        invoked in the context of any node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Overrides MIPCallback.get_current_node_depth</span>
        <span class="c1"># Always throw an exception.</span>
        <span class="c1"># The intention is this: The super class has a getCurrentNodeDepth()</span>
        <span class="c1"># function as well. That would throw an exception because the callable</span>
        <span class="c1"># library returns a non-zero status.</span>
        <span class="c1"># However, by explicitly overriding this function, we can explicitly</span>
        <span class="c1"># document that this will fail.</span>
        <span class="k">raise</span> <span class="n">CplexSolverError</span><span class="p">(</span><span class="s1">&#39;Not in a node context&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">CPXERR_UNSUPPORTED_OPERATION</span><span class="p">)</span></div>


<div class="viewcode-block" id="NodeCallback.get_estimated_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_estimated_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_estimated_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the estimated objective function value at node which_node.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_ESTIMATE</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="NodeCallback.get_infeasibility_sum">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_infeasibility_sum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_infeasibility_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sum of infeasibilities at node which_node.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_SIINF</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="NodeCallback.get_num_infeasibilities">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_num_infeasibilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_infeasibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of infeasibilities at node which_node.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_NIINF</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="NodeCallback.get_node_data">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_node_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the handle set by the user for node which_node.</span>

<span class="sd">        Returns None if no handle was set when the node was created.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_USERHANDLE</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="NodeCallback.set_node_data">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.set_node_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the user handle for the specified node.</span>

<span class="sd">        Returns the user handle previously set for that node (or None</span>
<span class="sd">        if no handle was set).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbacksetnodeuserhandle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
                                               <span class="n">which_node</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="NodeCallback.get_node_ID">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_node_ID">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a one-tuple containing the sequence number of node which_node.</span>

<span class="sd">        which_node must be an integer specifying the index</span>
<span class="sd">        number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_SEQNUM_LONG</span><span class="p">,</span> <span class="n">which_node</span><span class="p">),)</span></div>


<div class="viewcode-block" id="NodeCallback.get_node_number">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_node_number">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the index number of node which_node.</span>

<span class="sd">        which_node must be a 1-tuple whose entry is an integer</span>
<span class="sd">        specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_seq_info</span><span class="p">(</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_NODENUM_LONG</span><span class="p">,</span> <span class="n">which_node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="NodeCallback.get_objective_value">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.get_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the objective function value for node which_node.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_info</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_NODE_OBJVAL</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="NodeCallback.select_node">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.NodeCallback.select_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells Cplex to enter node which_node next.</span>

<span class="sd">        which_node may either be an integer specifying the index</span>
<span class="sd">        number of the desired node, or a 1-tuple whose entry is an</span>
<span class="sd">        integer specifying the sequence number of the desired node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__conditionally_convert</span><span class="p">(</span><span class="n">which_node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_useraction</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_SET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>



<div class="viewcode-block" id="TuningCallback">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.TuningCallback">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TuningCallback</span><span class="p">(</span><span class="n">Callback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclassable class for tuning callback classes.</span>

<span class="sd">    This callback will be used during tuning.</span>

<span class="sd">    For general information about tuning callbacks, see that topic</span>
<span class="sd">    in the CPLEX User&#39;s Manual.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TuningCallback.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.TuningCallback.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_type_string</span> <span class="o">=</span> <span class="s2">&quot;tuning&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb_set_function</span> <span class="o">=</span> <span class="n">_proc</span><span class="o">.</span><span class="n">settuningcallbackfunc</span></div>


<div class="viewcode-block" id="TuningCallback.get_progress">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.TuningCallback.get_progress">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the fraction of the tuning process that is done.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pycplex</span><span class="o">.</span><span class="n">fast_getcallbackinfo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cbstruct</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACK_INFO_TUNING_PROGRESS</span><span class="p">,</span>
            <span class="n">CplexSolverError</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ContextType">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.ContextType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ContextType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The different contexts in which a generic callback can be invoked.</span>

<span class="sd">    The values defined here serve two purposes:</span>

<span class="sd">       They are returned from `Context.get_id()` to indicate in which</span>
<span class="sd">       context a particular callback invocation happened.</span>

<span class="sd">       The bit-wise OR of these values specifies to</span>
<span class="sd">       `Cplex.set_callback()` in which contexts CPLEX invokes the</span>
<span class="sd">       callback.</span>

<span class="sd">    See the reference manual of the CPLEX Callable Library (C API)</span>
<span class="sd">    for a more detailed description of the various contexts.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thread_up</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACKCONTEXT_THREAD_UP</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_CALLBACKCONTEXT_THREAD_UP &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_CALLBACKCONTEXT_THREAD_UP.html&gt;`_ in the C API.&quot;&quot;&quot;</span>

    <span class="n">thread_down</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACKCONTEXT_THREAD_DOWN</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_CALLBACKCONTEXT_THREAD_DOWN &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_CALLBACKCONTEXT_THREAD_DOWN.html&gt;`_ in the C API.&quot;&quot;&quot;</span>

    <span class="n">local_progress</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACKCONTEXT_LOCAL_PROGRESS</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_CALLBACKCONTEXT_LOCAL_PROGRESS &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_CALLBACKCONTEXT_LOCAL_PROGRESS.html&gt;`_ in the C API.&quot;&quot;&quot;</span>

    <span class="n">global_progress</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACKCONTEXT_GLOBAL_PROGRESS</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_CALLBACKCONTEXT_GLOBAL_PROGRESS &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_CALLBACKCONTEXT_GLOBAL_PROGRESS.html&gt;`_ in the C API.&quot;&quot;&quot;</span>

    <span class="n">candidate</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACKCONTEXT_CANDIDATE</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_CALLBACKCONTEXT_CANDIDATE &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_CALLBACKCONTEXT_CANDIDATE.html&gt;`_ in the C API.&quot;&quot;&quot;</span>

    <span class="n">relaxation</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACKCONTEXT_RELAXATION</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_CALLBACKCONTEXT_RELAXATION &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_CALLBACKCONTEXT_RELAXATION.html&gt;`_ in the C API.&quot;&quot;&quot;</span>

    <span class="n">branching</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_CALLBACKCONTEXT_BRANCHING</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_CALLBACKCONTEXT_BRANCHING &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_CALLBACKCONTEXT_BRANCHING.html&gt;`_ in the C API.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="RelaxationFlags">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.RelaxationFlags">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RelaxationFlags</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The flags that can be passed to `Context.get_relaxation_status()`.</span>

<span class="sd">    See the reference manual of the CPLEX Callable Library (C API)</span>
<span class="sd">    for a more detailed description of the various contexts.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">no_solve</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">CPX_RELAXATION_FLAG_NOSOLVE</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CPX_RELAXATION_FLAG_NOSOLVE &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/macros/CPX_RELAXATION_FLAG_NOSOLVE.html&gt;`_ in the C API.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="Context">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Context</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context for the generic callback.</span>

<span class="sd">    An instance of this class defines the context in which a generic</span>
<span class="sd">    callback was invoked. It provides methods to query information and</span>
<span class="sd">    perform all actions that can be performed from a generic callback.</span>

<span class="sd">    Note that an instance of this class is only valid during the</span>
<span class="sd">    execution of the callback into which it was passed. Don&#39;t store a</span>
<span class="sd">    reference to the context across callback invocations.</span>

<span class="sd">    See `Cplex.set_callback()`.</span>

<span class="sd">    :undocumented: __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">CallbackInfo</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CallbackInfo`&quot;&quot;&quot;</span>

    <span class="n">solution_strategy</span> <span class="o">=</span> <span class="n">SolutionStrategy</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `SolutionStrategy`&quot;&quot;&quot;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">ContextType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `ContextType`&quot;&quot;&quot;</span>

    <span class="n">relaxation_flags</span> <span class="o">=</span> <span class="n">RelaxationFlags</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `RelaxationFlags`&quot;&quot;&quot;</span>

    <span class="n">solution_status</span> <span class="o">=</span> <span class="n">SolutionStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `SolutionStatus`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Context.__init__">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cpx</span><span class="p">,</span> <span class="n">contextptr</span><span class="p">,</span> <span class="n">contextid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span> <span class="o">=</span> <span class="n">cpx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span> <span class="o">=</span> <span class="n">contextptr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">=</span> <span class="n">contextid</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_column_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="c1"># Adapted from Callback._get_col_index</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getcolindex</span><span class="p">(</span><span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="n">lp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                 <span class="n">colname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_column_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">getnumcols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_colname2idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="c1"># This is the same as Callback._conv_col!</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_column_index</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

<div class="viewcode-block" id="Context.get_id">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the context in which the current callback was invoked.</span>

<span class="sd">        The return value will be one of the constants in `ContextType`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span></div>


<div class="viewcode-block" id="Context.in_thread_up">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.in_thread_up">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_thread_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the callback was invoked in context</span>
<span class="sd">        `ContextType.thread_up`.</span>

<span class="sd">        It is a shortcut for checking whether `get_id()` returns</span>
<span class="sd">        `ContextType.thread_up` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">thread_up</span></div>


<div class="viewcode-block" id="Context.in_thread_down">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.in_thread_down">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_thread_down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the callback was invoked in context</span>
<span class="sd">        `ContextType.thread_down`.</span>

<span class="sd">        It is a shortcut for checking whether `get_id()` returns</span>
<span class="sd">        `ContextType.thread_down` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">thread_down</span></div>


<div class="viewcode-block" id="Context.in_local_progress">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.in_local_progress">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_local_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the callback was invoked in context</span>
<span class="sd">        `ContextType.local_progress`.</span>

<span class="sd">        It is a shortcut for checking whether `get_id()` returns</span>
<span class="sd">        `ContextType.local_progress` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">local_progress</span></div>


<div class="viewcode-block" id="Context.in_global_progress">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.in_global_progress">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_global_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the callback was invoked in context</span>
<span class="sd">        `ContextType.global_progress`.</span>

<span class="sd">        It is a shortcut for checking whether `get_id()` returns</span>
<span class="sd">        `ContextType.global_progress` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">global_progress</span></div>


<div class="viewcode-block" id="Context.in_candidate">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.in_candidate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_candidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the callback was invoked in context</span>
<span class="sd">        `ContextType.candidate`.</span>

<span class="sd">        It is a shortcut for checking whether `get_id()` returns</span>
<span class="sd">        `ContextType.candidate` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">candidate</span></div>


<div class="viewcode-block" id="Context.in_relaxation">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.in_relaxation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_relaxation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the callback was invoked in context</span>
<span class="sd">        `ContextType.relaxation`.</span>

<span class="sd">        It is a shortcut for checking whether `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">relaxation</span></div>


<div class="viewcode-block" id="Context.in_branching">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.in_branching">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_branching</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the callback was invoked in context</span>
<span class="sd">        `ContextType.branching`.</span>

<span class="sd">        It is a shortcut for checking whether `get_id()` returns</span>
<span class="sd">        `ContextType.branching` or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contextid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">branching</span></div>


<div class="viewcode-block" id="Context.get_int_info">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_int_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_int_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a 32bit signed information value.</span>

<span class="sd">        Potential values are listed in `Context.info`. Note that in all</span>
<span class="sd">        contexts but `ContextType.global_progress` the information</span>
<span class="sd">        returned by the method is thread-local.</span>

<span class="sd">        See `CPXcallbackgetinfoint &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetinfoint.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetinfoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">what</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_long_info">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_long_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_long_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a 64bit signed information value.</span>

<span class="sd">        Potential values are listed in `Context.info`. Note that in all</span>
<span class="sd">        contexts but `ContextType.global_progress` the information</span>
<span class="sd">        returned by the method is thread-local.</span>

<span class="sd">        See `CPXcallbackgetinfolong &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetinfolong.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetinfolong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">what</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_double_info">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_double_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_double_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a float information value.</span>

<span class="sd">        Potential values are listed in `Context.info`. Note that in all</span>
<span class="sd">        contexts but `ContextType.global_progress` the information</span>
<span class="sd">        returned by the method is thread-local.</span>

<span class="sd">        See `CPXcallbackgetinfodbl &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetinfodbl.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetinfodbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">what</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.abort">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.abort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">abort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aborts the optimization.</span>

<span class="sd">        If you call this method then CPLEX will abort optimization at</span>
<span class="sd">        the next opportunity.</span>

<span class="sd">        See `CPXcallbackabort &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackabort.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">callbackabort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_relaxation_point">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_relaxation_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_relaxation_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the solution to the current relaxation.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation` or `ContextType.branching`. If invoked</span>
<span class="sd">        in a different context it will raise an exception.</span>

<span class="sd">        This method returns the values in the solution for the current</span>
<span class="sd">        relaxation for the variables specified by the arguments.</span>

<span class="sd">        There are four forms by which get_relaxation_point may be called.</span>

<span class="sd">        self.get_relaxation_point()</span>
<span class="sd">          returns the full solution vector.</span>

<span class="sd">        self.get_relaxation_point(i)</span>
<span class="sd">          i must be a variable index or name. Returns the value of the</span>
<span class="sd">          variable with index or name i in the solution to the current</span>
<span class="sd">          relaxation.</span>

<span class="sd">        self.get_relaxation_point(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the values of the variables with indices the members of</span>
<span class="sd">          s, in the same order as they appear in s. Equivalent to</span>
<span class="sd">          [self.get_relaxation_point(i) for i in s]</span>

<span class="sd">        self.get_relaxation_point(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of solution values of variables with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_relaxation_point(range(begin, end + 1)).</span>

<span class="sd">        See `CPXcallbackgetrelaxationpoint &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetrelaxationpoint.html&gt;`_ in the Callable</span>
<span class="sd">        Library Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetrelaxationpoint</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetrelaxationpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetrelaxationpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_relaxation_objective">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_relaxation_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_relaxation_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the objective value of current relaxation.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation` or `ContextType.branching`. If invoked</span>
<span class="sd">        in a different context it will raise an exception.</span>

<span class="sd">        See `CPXcallbackgetrelaxationpoint &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetrelaxationpoint.html&gt;`_ in the Callable</span>
<span class="sd">        Library Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetrelaxationpointobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_relaxation_status">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_relaxation_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_relaxation_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the solution status of the relaxation LP.</span>

<span class="sd">        Returns the solution status of the LP relaxation at the current</span>
<span class="sd">        node.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation` or `ContextType.branching`. If invoked</span>
<span class="sd">        in a different context it will raise an exception.</span>

<span class="sd">        See `CPXcallbackgetrelaxationstatus &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetrelaxationstatus.html&gt;`_ in the Callable</span>
<span class="sd">        Library Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetrelaxationstatus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.make_branch">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.make_branch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective_estimate</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Makes a new branch with the specified data.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.branching`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        objective_estimate is a float representing the estimated</span>
<span class="sd">        objective value resulting from the specified branch.</span>

<span class="sd">        variables is a sequence of (var, dir, bnd) tuples specifying</span>
<span class="sd">        the variables on which to branch. var must be an index of a</span>
<span class="sd">        variable, dir must be one of &quot;L&quot; and &quot;U&quot;, indicating that the</span>
<span class="sd">        bound is a lower or upper bound, respectively, and bnd is an</span>
<span class="sd">        integer specifying the new bound for the variable.</span>

<span class="sd">        constraints is a sequence of (vec, sense, rhs) tuples specifying</span>
<span class="sd">        the constraints with which to branch. vec must be either an</span>
<span class="sd">        instance of `SparsePair` or a sequence with two entries, the</span>
<span class="sd">        first of which specifies the indices and the second of which</span>
<span class="sd">        specifies the values of the constraint. rhs must be a float</span>
<span class="sd">        determining the righthand side of the constraint. sense must be</span>
<span class="sd">        one of &quot;L&quot;, &quot;G&quot;, or &quot;E&quot;, specifying whether the constraint is a</span>
<span class="sd">        less-than-or-equal-to (&lt;=), greater-than-or-equal-to (&gt;=), or</span>
<span class="sd">        equality constraint (=).</span>

<span class="sd">        The method returns an integer that uniquely identifies the newly</span>
<span class="sd">        created child node in the search tree.</span>

<span class="sd">        Note that the children will be dropped if you call</span>
<span class="sd">        `prune_current_node()` at the same node.</span>

<span class="sd">        See `CPXcallbackmakebranch &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackmakebranch.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span><span class="p">,</span> <span class="n">constraints</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">bnds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="n">rmat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sense</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackmakebranch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span>
                                        <span class="nb">vars</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span>
                                        <span class="n">rmat</span><span class="o">.</span><span class="n">matbeg</span><span class="p">,</span> <span class="n">rmat</span><span class="o">.</span><span class="n">matind</span><span class="p">,</span> <span class="n">rmat</span><span class="o">.</span><span class="n">matval</span><span class="p">,</span>
                                        <span class="n">objective_estimate</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.prune_current_node">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.prune_current_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prune_current_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ask CPLEX to prune the current node from the search tree.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation` or `ContextType.branching`. If invoked</span>
<span class="sd">        in a different context it will raise an exception.</span>

<span class="sd">        The node is marked for pruning. As soon as the callback returns,</span>
<span class="sd">        CPLEX stops processing the node. In particular, no child nodes</span>
<span class="sd">        will be created from that node, even if you called</span>
<span class="sd">        `make_branch()` to explicitly create new nodes.</span>

<span class="sd">        See `CPXcallbackprunenode &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackprunenode.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">callbackprunenode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.exit_cut_loop">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.exit_cut_loop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">exit_cut_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ask CPLEX to stop cutting plane separatation at the current</span>
<span class="sd">        node.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        See `CPXcallbackexitcutloop &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackexitcutloop.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackexitcutloop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_incumbent">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_incumbent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_incumbent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current incumbent solution.</span>

<span class="sd">        The method returns the values in the current incumbent solution</span>
<span class="sd">        for the variables specified by the arguments.</span>

<span class="sd">        There are four forms by which get_incumbent may be called.</span>

<span class="sd">        self.get_incumbent()</span>
<span class="sd">          returns the full incumbent vector.</span>

<span class="sd">        self.get_incumbent(i)</span>
<span class="sd">          i must be a variable index or name. Returns the value of the</span>
<span class="sd">          variable with index or name i in the current incumbent</span>
<span class="sd">          solution.</span>

<span class="sd">        self.get_incumbent(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the values of the variables with indices the members of</span>
<span class="sd">          s, in the same order as they appear in s. Equivalent to</span>
<span class="sd">          [self.get_incumbent(i) for i in s]</span>

<span class="sd">        self.get_incumbent(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of solution values of variables with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_incumbent(range(begin, end + 1)).</span>

<span class="sd">        See `CPXcallbackgetincumbent &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetincumbent.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetincumbent</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetincumbent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetincumbent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_incumbent_objective">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_incumbent_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_incumbent_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the objective value of the current incumbent.</span>

<span class="sd">        The returned value may be a huge value (such as 1e75) to indicate</span>
<span class="sd">        that no incumbent was found yet. Consider using `get_int_info()`</span>
<span class="sd">        with `CallbackInfo.feasible` first to check whether there is an</span>
<span class="sd">        incumbent.</span>

<span class="sd">        See `CPXcallbackgetincumbent &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetincumbent.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetincumbentobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.is_candidate_point">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.is_candidate_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_candidate_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test if the callback was invoked for a candidate feasible</span>
<span class="sd">        point.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.candidate`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        This method returns true if the callback was invoked for a</span>
<span class="sd">        candidate feasible point. In that case the candidate feasible</span>
<span class="sd">        point can be examined using `get_candidate_point()` and</span>
<span class="sd">        `get_candidate_objective()`.</span>

<span class="sd">        See `CPXcallbackcandidateispoint &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackcandidateispoint.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackcandidateispoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_candidate_source">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_candidate_source">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_candidate_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the source from which the current candidate solution originated.</span>

<span class="sd">        The value returned is from IncumbentCallback.solution_source.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># FIXME: Share this code with above</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">IncumbentCallback</span><span class="o">.</span><span class="n">solution_source</span>
        <span class="n">switcher</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_NODE</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">node_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_HEUR</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">heuristic_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_MIPSTART</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">mipstart_solution</span><span class="p">,</span>
            <span class="n">_const</span><span class="o">.</span><span class="n">CPX_LAZYCONSTRAINTCALLBACK_USER</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">user_solution</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">switcher</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_int_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">candidate_source</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Context.get_candidate_point">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_candidate_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_candidate_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current candidate solution.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.candidate` and `is_candidate_point()` returns true.</span>
<span class="sd">        If invoked in a different context it will raise an exception.</span>

<span class="sd">        This method returns the values in the current candidate solution</span>
<span class="sd">        for the variables specified by the arguments.</span>

<span class="sd">        There are four forms by which get_candidate_point may be called.</span>

<span class="sd">        self.get_candidate_point()</span>
<span class="sd">          returns the full solution vector.</span>

<span class="sd">        self.get_candidate_point(i)</span>
<span class="sd">          i must be a variable index or name. Returns the value of the</span>
<span class="sd">          variable with index or name i in the current candidate</span>
<span class="sd">          solution.</span>

<span class="sd">        self.get_candidate_point(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the values of the variables with indices the members of</span>
<span class="sd">          s, in the same order as they appear in s. Equivalent to</span>
<span class="sd">          [self.get_candidate_point(i) for i in s]</span>

<span class="sd">        self.get_candidate_point(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of solution values of variables with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_candidate_point(range(begin, end + 1))</span>

<span class="sd">        See `CPXcallbackgetcandidatepoint &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetcandidatepoint.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetcandidatepoint</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetcandidatepoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetcandidatepoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_candidate_objective">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_candidate_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_candidate_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the objective value of current candidate solution.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.candidate` and `is_candidate_point()` returns true.</span>
<span class="sd">        It will raise an exception if invoked in a different context.</span>

<span class="sd">        See `CPXcallbackgetcandidatepoint &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetcandidatepoint.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetcandidateobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.is_candidate_ray">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.is_candidate_ray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_candidate_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test if the callback was invoked for an unbounded ray.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.candidate`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        This method returns true if the callback was invoked for an</span>
<span class="sd">        unbounded relaxation. In that case the unbounded ray can be</span>
<span class="sd">        obtained using `get_candidate_ray()` and.</span>

<span class="sd">        See `CPXcallbackcandidateisray &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackcandidateisray.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackcandidateisray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_candidate_ray">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_candidate_ray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_candidate_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current unbounded ray.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.candidate` and `is_candidate_ray()` returns true. If</span>
<span class="sd">        invoked in a different context it will raise an exception.</span>

<span class="sd">        The method returns the values for in the unbounded ray for the</span>
<span class="sd">        variables specified by the arguments.</span>

<span class="sd">        There are four forms by which get_candidate_ray may be called.</span>

<span class="sd">        self.get_candidate_ray()</span>
<span class="sd">          returns the full ray vector.</span>

<span class="sd">        self.get_candidate_ray(i)</span>
<span class="sd">          i must be a variable index or name. Returns the value of the</span>
<span class="sd">          variable with index or name i in the unbounded ray.</span>

<span class="sd">        self.get_candidate_ray(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the values of the variables with indices the members of</span>
<span class="sd">          s, in the same order as they appear in s. Equivalent to</span>
<span class="sd">          [self.get_candidate_ray(i) for i in s]</span>

<span class="sd">        self.get_candidate_ray(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of unbounded reay values of variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_candidate_ray(range(begin, end + 1)).</span>

<span class="sd">        See `CPXcallbackgetcandidateray &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackgetcandidateray.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetcandidateray</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetcandidateray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetcandidateray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_local_lower_bounds">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_local_lower_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_local_lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current local lower bounds.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        There are four forms by which get_local_lower_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_local_lower_bounds()</span>
<span class="sd">          returns local lower bounds for all variables.</span>

<span class="sd">        self.get_local_lower_bounds(i)</span>
<span class="sd">          i must be a variable index or name. Returns the local lower</span>
<span class="sd">          bound of the variable with index or name i.</span>

<span class="sd">        self.get_local_lower_bounds(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the local lower bounds of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_local_lower_bounds(i) for i in s]</span>

<span class="sd">        self.get_local_lower_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the local lower bounds of variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_local_lower_bounds(range(begin, end + 1)).</span>

<span class="sd">        See `CPXcallbackgetlocallb &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/callbackgetlocallb.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetlocallb</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetlocallb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetlocallb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_local_upper_bounds">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_local_upper_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_local_upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current local upper bounds.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        There are four forms by which get_local_upper_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_local_upper_bounds()</span>
<span class="sd">          returns local upper bounds for all variables.</span>

<span class="sd">        self.get_local_upper_bounds(i)</span>
<span class="sd">          i must be a variable index or name. Returns the local upper</span>
<span class="sd">          bound of the variable with index or name i.</span>

<span class="sd">        self.get_local_upper_bounds(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the local upper bounds of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_local_upper_bounds(i) for i in s]</span>

<span class="sd">        self.get_local_upper_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the local upper bounds of variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_local_upper_bounds(range(begin, end + 1)).</span>

<span class="sd">        See `CPXcallbackgetlocalub &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/callbackgetlocalub.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetlocalub</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetlocalub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetlocalub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_global_lower_bounds">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_global_lower_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_global_lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current globally valid lower bounds.</span>

<span class="sd">        This method cannot be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.thread_up` or `ContextType.thread_down`.</span>

<span class="sd">        There are four forms by which get_global_lower_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_global_lower_bounds()</span>
<span class="sd">          returns global lower bounds for all variables.</span>

<span class="sd">        self.get_global_lower_bounds(i)</span>
<span class="sd">          i must be a variable index or name. Returns the global lower</span>
<span class="sd">          bound of the variable with index or name i.</span>

<span class="sd">        self.get_global_lower_bounds(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the global lower bounds of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_global_lower_bounds(i) for i in s]</span>

<span class="sd">        self.get_global_lower_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the global lower bounds of variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_global_lower_bounds(range(begin, end + 1)).</span>

<span class="sd">        See `CPXcallbackgetgloballb &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/callbackgetgloballb.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetgloballb</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetgloballb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetgloballb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.get_global_upper_bounds">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.get_global_upper_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_global_upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the current globally valid upper bounds.</span>

<span class="sd">        This method cannot be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.thread_up` or `ContextType.thread_down`.</span>

<span class="sd">        There are four forms by which get_global_upper_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        self.get_global_upper_bounds()</span>
<span class="sd">          returns global upper bounds for all variables.</span>

<span class="sd">        self.get_global_upper_bounds(i)</span>
<span class="sd">          i must be a variable index or name. Returns the global upper</span>
<span class="sd">          bound of the variable with index or name i.</span>

<span class="sd">        self.get_global_upper_bounds(s)</span>
<span class="sd">          s must be a sequence of variable indices or names. Returns a</span>
<span class="sd">          list of the global upper bounds of the variables with indices</span>
<span class="sd">          the members of s, in the same order as they appear in s.</span>
<span class="sd">          Equivalent to [self.get_global_upper_bounds(i) for i in s]</span>

<span class="sd">        self.get_global_upper_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns a list of the global upper bounds of variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          self.get_global_upper_bounds(range(begin, end + 1)).</span>

<span class="sd">        See `CPXcallbackgetglobalub &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/callbackgetglobalub.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">callbackgetglobalub</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_column_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_proc</span><span class="o">.</span><span class="n">callbackgetglobalub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">callbackgetglobalub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.post_heuristic_solution">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.post_heuristic_solution">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">post_heuristic_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Posts a feasible solution vector to CPLEX.</span>

<span class="sd">        This method posts a (possibly partial) feasible solution to</span>
<span class="sd">        CPLEX. CPLEX may use this vector to find a new incumbent</span>
<span class="sd">        solution.</span>

<span class="sd">        x is either a `SparsePair` instance or a list of two lists, the</span>
<span class="sd">        first of which specifies the variables (by index or name) and the</span>
<span class="sd">        second of which specifies the values.</span>

<span class="sd">        obj is an estimate for the objective function value of the</span>
<span class="sd">        solution provided by x.</span>

<span class="sd">        strategy specifies how CPLEX should complete partial solutions.</span>
<span class="sd">        See `SolutionStrategy` for further details.</span>

<span class="sd">        See `CPXcallbackpostheursoln &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackpostheursoln.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">_proc</span><span class="o">.</span><span class="n">callbackpostheursoln</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_colname2idx</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">values</span><span class="p">,</span>
                                   <span class="n">obj</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.add_user_cuts">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.add_user_cuts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_user_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuts</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">cutmanagement</span><span class="p">,</span> <span class="n">local</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds user cuts.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.relaxation`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        This method submits the specified user cuts to CPLEX.</span>

<span class="sd">        cuts, senses, rhs, cutmanagement, local must all be lists of</span>
<span class="sd">        compatible dimensions. The first three specify the cuts to be</span>
<span class="sd">        added.</span>

<span class="sd">        cuts must be either a list of `SparsePair` instances or a list of</span>
<span class="sd">        lists of two lists, the first of which specifies variables, the</span>
<span class="sd">        second of which specifies the values of the constraint.</span>

<span class="sd">        senses must be list of single-character strings; (&quot;L&quot;, &quot;G&quot;, &quot;E&quot;)</span>
<span class="sd">        It may also be one single string (the concatenation of the single</span>
<span class="sd">        character strings).</span>

<span class="sd">        rhs is a list of floats, specifying the righthand side of the</span>
<span class="sd">        constraints.</span>

<span class="sd">        cutmanagement must be a list of integer values specifying how</span>
<span class="sd">        CPLEX should treat each cut (see `UseCut` constants for further</span>
<span class="sd">        details).</span>

<span class="sd">        local must be a list of boolean values and specifies for each cut</span>
<span class="sd">        whether it is only locally valid (True) or globally valid</span>
<span class="sd">        (False).</span>

<span class="sd">        See `CPXcallbackaddusercuts &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackaddusercuts.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">senses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">cuts</span><span class="p">,</span> <span class="n">cutmanagement</span><span class="p">,</span> <span class="n">local</span><span class="p">]</span>
        <span class="n">ncuts</span> <span class="o">=</span> <span class="n">max_arg_length</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="n">arg_list</span><span class="p">,</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: cuts, senses, rhs, cutmanagement, local&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ncuts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_proc</span><span class="o">.</span><span class="n">chbmatrix</span><span class="p">(</span><span class="n">cuts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                                 <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">nnz</span><span class="p">):</span>
                <span class="n">_proc</span><span class="o">.</span><span class="n">callbackaddusercuts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">ncuts</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span>
                                          <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rmat</span><span class="p">,</span>
                                          <span class="n">cutmanagement</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.add_user_cut">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.add_user_cut">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_user_cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">cutmanagement</span><span class="p">,</span> <span class="n">local</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience wrapper for `add_user_cuts()` that only adds a</span>
<span class="sd">        single cut.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_user_cuts</span><span class="p">([</span><span class="n">cut</span><span class="p">],</span> <span class="p">[</span><span class="n">sense</span><span class="p">],</span> <span class="p">[</span><span class="n">rhs</span><span class="p">],</span> <span class="p">[</span><span class="n">cutmanagement</span><span class="p">],</span> <span class="p">[</span><span class="n">local</span><span class="p">])</span></div>


<div class="viewcode-block" id="Context.reject_candidate">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.reject_candidate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reject_candidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">senses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rejects the current candidate solution.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.candidate`. If invoked in a different context it</span>
<span class="sd">        will raise an exception.</span>

<span class="sd">        This method marks the current candidate solution as infeasible,</span>
<span class="sd">        potentially specifying additional constraints that cut it off.</span>

<span class="sd">        If constraints, senses, and rhs are all None then the current</span>
<span class="sd">        candidate solution is just rejected. If any of the three is not</span>
<span class="sd">        None then all must be not None and all must have compatible</span>
<span class="sd">        dimensions. In that case the three arguments specify a set of</span>
<span class="sd">        constraints that cut off the current candidate solution. CPLEX</span>
<span class="sd">        may use this information to tighten the problem formulation and</span>
<span class="sd">        to avoid finding the same solution again. There is however no</span>
<span class="sd">        guarantee that CPLEX will actually use those additional</span>
<span class="sd">        constraints.</span>

<span class="sd">        constraints must be either a list of `SparsePair` instances or a</span>
<span class="sd">        list of lists of two lists, the first of which specifies</span>
<span class="sd">        variables, the second of which specifies the values of the</span>
<span class="sd">        constraint.</span>

<span class="sd">        senses must be list of single-character strings; (&quot;L&quot;, &quot;G&quot;, &quot;E&quot;)</span>
<span class="sd">        It may also be one single string (the concatenation of the single</span>
<span class="sd">        character strings).</span>

<span class="sd">        rhs is a list of floats, specifying the righthand side of the</span>
<span class="sd">        constraints.</span>

<span class="sd">        See `CPXcallbackrejectcandidate &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackrejectcandidate.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constraints</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">senses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">constraints</span><span class="p">]</span>
        <span class="n">nconstraints</span> <span class="o">=</span> <span class="n">max_arg_length</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="n">arg_list</span><span class="p">,</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: constraints, senses, rhs&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="n">_proc</span><span class="o">.</span><span class="n">chbmatrix</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                             <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">nnz</span><span class="p">):</span>
            <span class="n">_proc</span><span class="o">.</span><span class="n">callbackrejectcandidate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">nconstraints</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span>
                                          <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rmat</span><span class="p">)</span></div>


<div class="viewcode-block" id="Context.reject_candidate_local">
<a class="viewcode-back" href="../../cplex.html#cplex.callbacks.Context.reject_candidate_local">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reject_candidate_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">senses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rejects the current candidate solution.</span>

<span class="sd">        This method can only be invoked if `get_id()` returns</span>
<span class="sd">        `ContextType.candidate` and if the candidate was invoked for an</span>
<span class="sd">        integral node. If invoked in a different context it will raise an</span>
<span class="sd">        exception.</span>

<span class="sd">        This method marks the current candidate solution as infeasible,</span>
<span class="sd">        potentially specifying additional constraints that cut it off.</span>
<span class="sd">        The specified constraints are not required to be globally valid.</span>
<span class="sd">        They are only required to be valid in the subtree in which the</span>
<span class="sd">        callback was invoked.</span>

<span class="sd">        If constraints, senses, and rhs are all None then the current</span>
<span class="sd">        candidate solution is just rejected. If any of the three is not</span>
<span class="sd">        None then all must be not None and all must have compatible</span>
<span class="sd">        dimensions. In that case the three arguments specify a set of</span>
<span class="sd">        constraints that cut off the current candidate solution. CPLEX</span>
<span class="sd">        may use this information to tighten the problem formulation and</span>
<span class="sd">        to avoid finding the same solution again. There is however no</span>
<span class="sd">        guarantee that CPLEX will actually use those additional</span>
<span class="sd">        constraints.</span>

<span class="sd">        constraints must be either a list of `SparsePair` instances or a</span>
<span class="sd">        list of lists of two lists, the first of which specifies</span>
<span class="sd">        variables, the second of which specifies the values of the</span>
<span class="sd">        constraint.</span>

<span class="sd">        senses must be list of single-character strings; (&quot;L&quot;, &quot;G&quot;, &quot;E&quot;)</span>
<span class="sd">        It may also be one single string (the concatenation of the single</span>
<span class="sd">        character strings).</span>

<span class="sd">        rhs is a list of floats, specifying the righthand side of the</span>
<span class="sd">        constraints.</span>

<span class="sd">        See `CPXcallbackrejectcandidatelocal &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/callbackrejectcandidatelocal.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constraints</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">senses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">constraints</span><span class="p">]</span>
        <span class="n">nconstraints</span> <span class="o">=</span> <span class="n">max_arg_length</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">_proc</span><span class="o">.</span><span class="n">chbmatrix</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cpx</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                             <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">nnz</span><span class="p">):</span>
            <span class="n">_proc</span><span class="o">.</span><span class="n">callbackrejectcandidatelocal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_contextptr</span><span class="p">,</span> <span class="n">nconstraints</span><span class="p">,</span>
                                               <span class="n">nnz</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rmat</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table of Contents</a></h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Cplex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Python tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/index.html">CPLEX for Python users</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span></span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CPLEX Python API documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cplex.html" >cplex</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cplex.callbacks</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright IBM Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>