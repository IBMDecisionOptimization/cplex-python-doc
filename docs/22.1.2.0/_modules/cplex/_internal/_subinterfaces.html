<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cplex._internal._subinterfaces &#8212; CPLEX Python API Reference Manual 22.1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=908d05d1" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/ibm_sphinx.css?v=ae0229bc" />
    
    <script src="../../../_static/documentation_options.js?v=8a2b0fec"></script>
    <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    
    <script src="../../../_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">CPLEX Python API documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../cplex.html" >cplex</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../_internal.html" accesskey="U">cplex._internal</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cplex._internal._subinterfaces</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cplex._internal._subinterfaces</h1><div class="highlight"><pre>
<span></span><span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># File: _subinterfaces.py</span>
<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># Licensed Materials - Property of IBM</span>
<span class="c1"># 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21</span>
<span class="c1"># Copyright IBM Corporation 2008, 2024. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># US Government Users Restricted Rights - Use, duplication or</span>
<span class="c1"># disclosure restricted by GSA ADP Schedule Contract with</span>
<span class="c1"># IBM Corp.</span>
<span class="c1"># ------------------------------------------------------------------------</span>
<span class="sd">&quot;&quot;&quot;Sub-interfaces of the CPLEX API.&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">contextlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">closing</span><span class="p">,</span> <span class="n">contextmanager</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numbers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_procedural</span> <span class="k">as</span> <span class="n">CPX_PROC</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._baseinterface</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseInterface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._multiobjsoln</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiObjSolnInterface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._matrices</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">SparsePair</span><span class="p">,</span> <span class="n">SparseTriple</span><span class="p">,</span> <span class="n">_HBMatrix</span><span class="p">,</span>
                        <span class="n">unpack_pair</span><span class="p">,</span> <span class="n">unpack_triple</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._aux_functions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">apply_freeform_one_arg</span><span class="p">,</span>
                             <span class="n">apply_freeform_two_args</span><span class="p">,</span>
                             <span class="n">max_arg_length</span><span class="p">,</span>
                             <span class="n">validate_arg_lengths</span><span class="p">,</span> <span class="n">apply_pairs</span><span class="p">,</span>
                             <span class="n">delete_set_by_range</span><span class="p">,</span>
                             <span class="n">make_group</span><span class="p">,</span> <span class="n">_group</span><span class="p">,</span>
                             <span class="n">init_list_args</span><span class="p">,</span> <span class="n">listify</span><span class="p">,</span>
                             <span class="n">unzip</span><span class="p">,</span> <span class="n">convert_sequence</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">CplexSolverError</span><span class="p">,</span> <span class="n">WrongNumberOfArgumentsError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..constant_class</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConstantClass</span>


<div class="viewcode-block" id="Histogram">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.Histogram">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Histogram</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to retrieve histogram data of the columns or rows of the</span>
<span class="sd">    linear constraint matrix.</span>

<span class="sd">    See `VariablesInterface.get_histogram()` and</span>
<span class="sd">    `LinearConstraintInterface.get_histogram()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Histogram.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.Histogram.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hist</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">gethist</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">key</span></div>


<div class="viewcode-block" id="Histogram.__getitem__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.Histogram.__getitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of columns/rows with a given nonzero count.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;histogram keys must be non-negative&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">):</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;histogram keys must be non-negative&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;histogram keys must be non-negative&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)]</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;key must be an integer or a slice&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Histogram.__str__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.Histogram.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string containing a histogram in human readable form.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
            <span class="n">hdr0</span> <span class="o">=</span> <span class="s2">&quot;Column counts (excluding fixed variables):&quot;</span>
            <span class="n">hdr1</span> <span class="o">=</span> <span class="s2">&quot;    Nonzero Count:&quot;</span>
            <span class="n">hdr2</span> <span class="o">=</span> <span class="s2">&quot;Number of Columns:&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hdr0</span> <span class="o">=</span> <span class="s2">&quot;Row counts (excluding fixed variables):&quot;</span>
            <span class="n">hdr1</span> <span class="o">=</span> <span class="s2">&quot; Nonzero Count:&quot;</span>
            <span class="n">hdr2</span> <span class="o">=</span> <span class="s2">&quot;Number of Rows:&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">)</span>
        <span class="n">maxhist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
                     <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rng</span><span class="p">)),</span>
                     <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">maxhist</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">perline</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="mi">75</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">hdr1</span><span class="p">))</span> <span class="o">/</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">needs_hdr0</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">rng</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">needs_hdr0</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">hdr0</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="n">needs_hdr0</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">hdr1</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">perline</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%*d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">hdr2</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rng</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">perline</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">jj</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%*d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hist</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">jj</span>
        <span class="k">return</span> <span class="n">ret</span></div>
</div>



<div class="viewcode-block" id="AdvancedVariablesInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedVariablesInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AdvancedVariablesInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for advanced operations on variables.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="AdvancedVariablesInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedVariablesInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new AdvancedVariablesInterface.</span>

<span class="sd">        The advanced variables interface is exposed by the top-level</span>
<span class="sd">        `Cplex` class as Cplex.variables.advanced.  This constructor is</span>
<span class="sd">        not meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedVariablesInterface.protect">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedVariablesInterface.protect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">protect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prevents variables from being aggregated during presolve.</span>

<span class="sd">        protect may be called with either a single variable identifier</span>
<span class="sd">        or a sequence of variable identifiers.  A variable identifier</span>
<span class="sd">        is either an index or a name of a variable.</span>

<span class="sd">        Note</span>
<span class="sd">          Subsequent calls to protect will replace previously protected</span>
<span class="sd">          variables with the new set of protected variables.</span>

<span class="sd">        Note</span>
<span class="sd">          If presolve can fix a variable to a value, it will be removed</span>
<span class="sd">          from the problem even if it has been protected.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.protect(&quot;a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.protect([&quot;b&quot;, &quot;d&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">listify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">copyprotected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedVariablesInterface.get_protected">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedVariablesInterface.get_protected">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_protected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the currently protected variables.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.protect(&quot;a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.get_protected()</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.protect([&quot;b&quot;, &quot;d&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.get_protected()</span>
<span class="sd">        [1, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getprotected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedVariablesInterface.tighten_lower_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedVariablesInterface.tighten_lower_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tighten_lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tightens the lower bounds on the specified variables.</span>

<span class="sd">        There are two forms by which</span>
<span class="sd">        variables.advanced.tighten_lower_bounds may be called.</span>

<span class="sd">        variables.advanced.tighten_lower_bounds(i, lb)</span>
<span class="sd">          i must be a variable name or index and lb must be a real</span>
<span class="sd">          number.  Sets the lower bound of the variable whose index</span>
<span class="sd">          or name is i to lb.</span>

<span class="sd">        variables.advanced.tighten_lower_bounds(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, lb) pairs, each</span>
<span class="sd">          of which consists of a variable name or index and a real</span>
<span class="sd">          number.  Sets the lower bound of the specified variables to</span>
<span class="sd">          the corresponding values.  Equivalent to</span>
<span class="sd">          [variables.advanced.tighten_lower_bounds(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.tighten_lower_bounds(0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds()</span>
<span class="sd">        [1.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.tighten_lower_bounds([(2, 3.0), (&quot;x1&quot;, -1.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds()</span>
<span class="sd">        [1.0, -1.0, 3.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">tlb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">tightenbds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>
                                <span class="s1">&#39;L&#39;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">tlb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedVariablesInterface.tighten_upper_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedVariablesInterface.tighten_upper_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tighten_upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tightens the upper bounds on the specified variables.</span>

<span class="sd">        There are two forms by which</span>
<span class="sd">        variables.advanced.tighten_upper_bounds may be called.</span>

<span class="sd">        variables.advanced.tighten_upper_bounds(i, lb)</span>
<span class="sd">          i must be a variable name or index and lb must be a real</span>
<span class="sd">          number.  Sets the upper bound of the variable whose index</span>
<span class="sd">          or name is i to lb.</span>

<span class="sd">        variables.advanced.tighten_upper_bounds(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, lb) pairs, each</span>
<span class="sd">          of which consists of a variable name or index and a real</span>
<span class="sd">          number.  Sets the upper bound of the specified variables to</span>
<span class="sd">          the corresponding values.  Equivalent to</span>
<span class="sd">          [variables.advanced.tighten_upper_bounds(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.tighten_upper_bounds(0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.advanced.tighten_upper_bounds([(2, 3.0), (&quot;x1&quot;, 10.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_upper_bounds()</span>
<span class="sd">        [1.0, 10.0, 3.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">tub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">tightenbds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>
                                <span class="s1">&#39;U&#39;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">tub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="VarTypes">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VarTypes">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VarTypes</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants defining variable types</span>

<span class="sd">    For a definition of each type, see those topics in the CPLEX User&#39;s</span>
<span class="sd">    Manual.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">continuous</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CONTINUOUS</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_BINARY</span>
    <span class="n">integer</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_INTEGER</span>
    <span class="n">semi_integer</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SEMIINT</span>
    <span class="n">semi_continuous</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SEMICONT</span></div>



<div class="viewcode-block" id="VariablesInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VariablesInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for adding, querying, and modifying variables.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    &gt;&gt;&gt; import cplex</span>
<span class="sd">    &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">    &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">    &gt;&gt;&gt; # default values for lower_bounds are 0.0</span>
<span class="sd">    &gt;&gt;&gt; c.variables.get_lower_bounds()</span>
<span class="sd">    [0.0, 0.0, 0.0]</span>
<span class="sd">    &gt;&gt;&gt; # values can be set either one at a time or many at a time</span>
<span class="sd">    &gt;&gt;&gt; c.variables.set_lower_bounds(0, 1.0)</span>
<span class="sd">    &gt;&gt;&gt; c.variables.set_lower_bounds([(&quot;x1&quot;, -1.0), (2, 3.0)])</span>
<span class="sd">    &gt;&gt;&gt; # values can be queried as a range</span>
<span class="sd">    &gt;&gt;&gt; c.variables.get_lower_bounds(0, &quot;x1&quot;)</span>
<span class="sd">    [1.0, -1.0]</span>
<span class="sd">    &gt;&gt;&gt; # values can be queried as a sequence in arbitrary order</span>
<span class="sd">    &gt;&gt;&gt; c.variables.get_lower_bounds([&quot;x1&quot;, &quot;x2&quot;, 0])</span>
<span class="sd">    [-1.0, 3.0, 1.0]</span>
<span class="sd">    &gt;&gt;&gt; # can query the number of variables</span>
<span class="sd">    &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; c.variables.set_types(0, c.variables.type.binary)</span>
<span class="sd">    &gt;&gt;&gt; c.variables.get_num_binary()</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">type</span> <span class="o">=</span> <span class="n">VarTypes</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `VarTypes()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="VariablesInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new VariablesInterface.</span>

<span class="sd">        The variables interface is exposed by the top-level `Cplex` class</span>
<span class="sd">        as `Cplex.variables`.  This constructor is not meant to be used</span>
<span class="sd">        externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">cplex</span><span class="p">,</span> <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcolindex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">advanced</span> <span class="o">=</span> <span class="n">AdvancedVariablesInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `AdvancedVariablesInterface()` &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="VariablesInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of variables in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; t = c.variables.type</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(types = [t.continuous, t.binary, t.integer])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumcols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_num_integer">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_num_integer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of integer variables in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; t = c.variables.type</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(types = [t.continuous, t.binary, t.integer])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num_integer()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_num_binary">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_num_binary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of binary variables in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; t = c.variables.type</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(types = [t.semi_continuous, t.binary, t.integer])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num_binary()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumbin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_num_semicontinuous">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_num_semicontinuous">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_semicontinuous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of semi-continuous variables in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; t = c.variables.type</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(types = [t.semi_continuous, t.semi_integer, t.semi_integer])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num_semicontinuous()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumsemicont</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_num_semiinteger">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_num_semiinteger">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_semiinteger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of semi-integer variables in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; t = c.variables.type</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(types = [t.semi_continuous, t.semi_integer, t.semi_integer])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num_semiinteger()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumsemiint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">types</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">columns</span><span class="p">]</span>
        <span class="n">num_new_cols</span> <span class="o">=</span> <span class="n">max_arg_length</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="n">arg_list</span><span class="p">,</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: obj, lb, ub, types, names, columns&quot;</span>
        <span class="p">)</span>
        <span class="n">num_old_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">newcols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span>
                             <span class="n">types</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chbmatrix</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                                    <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">cmat</span><span class="p">,</span> <span class="n">nnz</span><span class="p">):</span>
                <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addcols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                 <span class="n">num_new_cols</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span>
                                 <span class="n">cmat</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">types</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgctype</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                    <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_old_cols</span><span class="p">,</span> <span class="n">num_old_cols</span> <span class="o">+</span> <span class="n">num_new_cols</span><span class="p">)),</span>
                    <span class="n">types</span><span class="p">)</span>

<div class="viewcode-block" id="VariablesInterface.add">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds variables and related data to the problem.</span>

<span class="sd">        variables.add accepts the keyword arguments obj, lb, ub,</span>
<span class="sd">        types, names, and columns.</span>

<span class="sd">        If more than one argument is specified, all arguments must</span>
<span class="sd">        have the same length.</span>

<span class="sd">        obj is a list of floats specifying the linear objective</span>
<span class="sd">        coefficients of the variables.</span>

<span class="sd">        lb is a list of floats specifying the lower bounds on the</span>
<span class="sd">        variables.</span>

<span class="sd">        ub is a list of floats specifying the upper bounds on the</span>
<span class="sd">        variables.</span>

<span class="sd">        types must be either a list of single-character strings or a</span>
<span class="sd">        string containing the types of the variables.</span>

<span class="sd">        Note</span>
<span class="sd">          If types is specified, the problem type will be a MIP, even if</span>
<span class="sd">          all variables are specified to be continuous.</span>

<span class="sd">        names is a list of strings.</span>

<span class="sd">        columns may be either a list of sparse vectors or a matrix in</span>
<span class="sd">        list-of-lists format.</span>

<span class="sd">        Note</span>
<span class="sd">          The entries of columns must not contain duplicate indices.</span>
<span class="sd">          If an entry of columns references a row more than once,</span>
<span class="sd">          either by index, name, or a combination of index and name,</span>
<span class="sd">          an exception will be raised.</span>

<span class="sd">        Returns an iterator containing the indices of the added</span>
<span class="sd">        variables.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names=[&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     obj=[1.0, 2.0, 3.0],</span>
<span class="sd">        ...     types=[c.variables.type.integer] * 3)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     obj=[1.0, 2.0, 3.0],</span>
<span class="sd">        ...     lb=[-1.0, 1.0, 0.0],</span>
<span class="sd">        ...     ub=[100.0, cplex.infinity, cplex.infinity],</span>
<span class="sd">        ...     types=[c.variables.type.integer] * 3,</span>
<span class="sd">        ...     names=[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],</span>
<span class="sd">        ...     columns=[cplex.SparsePair(ind=[&#39;c0&#39;, 2],</span>
<span class="sd">        ...                               val=[1.0, -1.0]),</span>
<span class="sd">        ...              [[&#39;c2&#39;],[2.0]],</span>
<span class="sd">        ...              cplex.SparsePair(ind=[0, 1],</span>
<span class="sd">        ...                               val=[3.0, 4.0])])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds()</span>
<span class="sd">        [0.0, 0.0, 0.0, -1.0, 1.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_cols(&quot;1&quot;)</span>
<span class="sd">        SparsePair(ind = [2], val = [2.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span>
                                                     <span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">,</span>
                              <span class="n">obj</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes variables from the problem.</span>

<span class="sd">        There are four forms by which variables.delete may be called.</span>

<span class="sd">        variables.delete()</span>
<span class="sd">          deletes all variables from the problem.</span>

<span class="sd">        variables.delete(i)</span>
<span class="sd">          i must be a variable name or index. Deletes the variable</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        variables.delete(s)</span>
<span class="sd">          s must be a sequence of variable names or indices. Deletes</span>
<span class="sd">          the variables with names or indices contained within s.</span>
<span class="sd">          Equivalent to [variables.delete(i) for i in s].</span>

<span class="sd">        variables.delete(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Deletes the variables with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          variables.delete(range(begin, end + 1)). This will give the</span>
<span class="sd">          best performance when deleting batches of variables.</span>

<span class="sd">        See `CPXdelcols &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/delcols.html&gt;`_ in the Callable Library Reference Manual</span>
<span class="sd">        for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.variables.delete(8)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.delete(&quot;1&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.delete([2, &quot;0&quot;, 5])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names()</span>
<span class="sd">        [&#39;4&#39;, &#39;6&#39;, &#39;7&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delcols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.set_lower_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.set_lower_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the lower bound for a variable or set of variables.</span>

<span class="sd">        There are two forms by which variables.set_lower_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        variables.set_lower_bounds(i, lb)</span>
<span class="sd">          i must be a variable name or index and lb must be a real</span>
<span class="sd">          number.  Sets the lower bound of the variable whose index</span>
<span class="sd">          or name is i to lb.</span>

<span class="sd">        variables.set_lower_bounds(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, lb) pairs, each</span>
<span class="sd">          of which consists of a variable name or index and a real</span>
<span class="sd">          number.  Sets the lower bound of the specified variables to</span>
<span class="sd">          the corresponding values.  Equivalent to</span>
<span class="sd">          [variables.set_lower_bounds(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_lower_bounds(0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds()</span>
<span class="sd">        [1.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_lower_bounds([(2, 3.0), (&quot;x1&quot;, -1.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds()</span>
<span class="sd">        [1.0, -1.0, 3.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">setlb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgbds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">setlb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.set_upper_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.set_upper_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the upper bound for a variable or set of variables.</span>

<span class="sd">        There are two forms by which variables.set_upper_bounds may be</span>
<span class="sd">        called.</span>

<span class="sd">        variables.set_upper_bounds(i, ub)</span>
<span class="sd">          i must be a variable name or index and ub must be a real</span>
<span class="sd">          number.  Sets the upper bound of the variable whose index</span>
<span class="sd">          or name is i to ub.</span>

<span class="sd">        variables.set_upper_bounds(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, ub) pairs, each</span>
<span class="sd">          of which consists of a variable name or index and a real</span>
<span class="sd">          number.  Sets the upper bound of the specified variables to</span>
<span class="sd">          the corresponding values.  Equivalent to</span>
<span class="sd">          [variables.set_upper_bounds(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_upper_bounds(0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_upper_bounds([(&quot;x1&quot;, 10.0), (2, 3.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_upper_bounds()</span>
<span class="sd">        [1.0, 10.0, 3.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">setub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgbds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">setub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.set_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.set_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the name of a variable or set of variables.</span>

<span class="sd">        There are two forms by which variables.set_names may be</span>
<span class="sd">        called.</span>

<span class="sd">        variables.set_names(i, name)</span>
<span class="sd">          i must be a variable name or index and name must be a</span>
<span class="sd">          string.</span>

<span class="sd">        variables.set_names(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, name) pairs,</span>
<span class="sd">          each of which consists of a variable name or index and a</span>
<span class="sd">          string.  Sets the name of the specified variables to the</span>
<span class="sd">          corresponding strings.  Equivalent to</span>
<span class="sd">          [variables.set_names(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; t = c.variables.type</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(types = [t.continuous, t.binary, t.integer])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_names(0, &quot;first&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_names([(2, &quot;third&quot;), (1, &quot;second&quot;)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names()</span>
<span class="sd">        [&#39;first&#39;, &#39;second&#39;, &#39;third&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">setnames</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgcolname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">setnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.set_types">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.set_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the type of a variable or set of variables.</span>

<span class="sd">        There are two forms by which variables.set_types may be</span>
<span class="sd">        called.</span>

<span class="sd">        variables.set_types(i, type)</span>
<span class="sd">          i must be a variable name or index and name must be a</span>
<span class="sd">          single-character string.</span>

<span class="sd">        variables.set_types(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, type) pairs,</span>
<span class="sd">          each of which consists of a variable name or index and a</span>
<span class="sd">          single-character string.  Sets the type of the specified</span>
<span class="sd">          variables to the corresponding strings.  Equivalent to</span>
<span class="sd">          [variables.set_types(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        Note</span>
<span class="sd">          If the types are set, the problem will be treated as a MIP,</span>
<span class="sd">          even if all variable types are continuous.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(5)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_types(0, c.variables.type.continuous)</span>
<span class="sd">        &gt;&gt;&gt; c.variables.set_types([(&quot;1&quot;, c.variables.type.integer),</span>
<span class="sd">                                   (&quot;2&quot;, c.variables.type.binary),</span>
<span class="sd">                                   (&quot;3&quot;, c.variables.type.semi_continuous),</span>
<span class="sd">                                   (&quot;4&quot;, c.variables.type.semi_integer)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_types()</span>
<span class="sd">        [&#39;C&#39;, &#39;I&#39;, &#39;B&#39;, &#39;S&#39;, &#39;N&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.type[c.variables.get_types(0)]</span>
<span class="sd">        &#39;continuous&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">xctypes</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">xctypes</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">xctypes</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">xctypes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgctype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">xctypes</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_lower_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_lower_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the lower bounds on variables from the problem.</span>

<span class="sd">        There are four forms by which variables.get_lower_bounds may be called.</span>

<span class="sd">        variables.get_lower_bounds()</span>
<span class="sd">          return the lower bounds on all variables from the problem.</span>

<span class="sd">        variables.get_lower_bounds(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the lower</span>
<span class="sd">          bound on the variable whose index or name is i.</span>

<span class="sd">        variables.get_lower_bounds(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the lower bounds on the variables with indices the members</span>
<span class="sd">          of s.  Equivalent to</span>
<span class="sd">          [variables.get_lower_bounds(i) for i in s]</span>

<span class="sd">        variables.get_lower_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the lower bounds on the variables with indices between</span>
<span class="sd">          begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          variables.get_lower_bounds(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(lb = [1.5 * i for i in range(10)],</span>
<span class="sd">                                      names = [str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds(8)</span>
<span class="sd">        12.0</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds(&quot;1&quot;,3)</span>
<span class="sd">        [1.5, 3.0, 4.5]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds([2,&quot;0&quot;,5])</span>
<span class="sd">        [3.0, 0.0, 7.5]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_lower_bounds()</span>
<span class="sd">        [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getlb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getlb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getlb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_upper_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_upper_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the upper bounds on variables from the problem.</span>

<span class="sd">        There are four forms by which variables.get_upper_bounds may be called.</span>

<span class="sd">        variables.get_upper_bounds()</span>
<span class="sd">          return the upper bounds on all variables from the problem.</span>

<span class="sd">        variables.get_upper_bounds(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the upper</span>
<span class="sd">          bound on the variable whose index or name is i.</span>

<span class="sd">        variables.get_upper_bounds(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the upper bounds on the variables with indices the members</span>
<span class="sd">          of s.  Equivalent to</span>
<span class="sd">          [variables.get_upper_bounds(i) for i in s]</span>

<span class="sd">        variables.get_upper_bounds(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the upper bounds on the variables with indices between</span>
<span class="sd">          begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          variables.get_upper_bounds(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(ub = [(1.5 * i) + 1.0 for i in range(10)],</span>
<span class="sd">                                      names = [str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_upper_bounds(8)</span>
<span class="sd">        13.0</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_upper_bounds(&quot;1&quot;,3)</span>
<span class="sd">        [2.5, 4.0, 5.5]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_upper_bounds([2,&quot;0&quot;,5])</span>
<span class="sd">        [4.0, 1.0, 8.5]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_upper_bounds()</span>
<span class="sd">        [1.0, 2.5, 4.0, 5.5, 7.0, 8.5, 10.0, 11.5, 13.0, 14.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of variables from the problem.</span>

<span class="sd">        There are four forms by which variables.get_names may be called.</span>

<span class="sd">        variables.get_names()</span>
<span class="sd">          return the names of all variables from the problem.</span>

<span class="sd">        variables.get_names(i)</span>
<span class="sd">          i must be a variable index.  Returns the name of variable i.</span>

<span class="sd">        variables.get_names(s)</span>
<span class="sd">          s must be a sequence of variable indices.  Returns the</span>
<span class="sd">          names of the variables with indices the members of s.</span>
<span class="sd">          Equivalent to [variables.get_names(i) for i in s]</span>

<span class="sd">        variables.get_names(begin, end)</span>
<span class="sd">          begin and end must be variable indices. Returns the names of</span>
<span class="sd">          the variables with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to variables.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&#39;x&#39; + str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names(8)</span>
<span class="sd">        &#39;x8&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names(1,3)</span>
<span class="sd">        [&#39;x1&#39;, &#39;x2&#39;, &#39;x3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names([2,0,5])</span>
<span class="sd">        [&#39;x2&#39;, &#39;x0&#39;, &#39;x5&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_names()</span>
<span class="sd">        [&#39;x0&#39;, &#39;x1&#39;, &#39;x2&#39;, &#39;x3&#39;, &#39;x4&#39;, &#39;x5&#39;, &#39;x6&#39;, &#39;x7&#39;, &#39;x8&#39;, &#39;x9&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcolname</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_types">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the types of variables from the problem.</span>

<span class="sd">        There are four forms by which variables.types may be called.</span>

<span class="sd">        variables.types()</span>
<span class="sd">          return the types of all variables from the problem.</span>

<span class="sd">        variables.types(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the type of</span>
<span class="sd">          the variable whose index or name is i.</span>

<span class="sd">        variables.types(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the types of the variables with indices the members of s.</span>
<span class="sd">          Equivalent to [variables.get_types(i) for i in s]</span>

<span class="sd">        variables.types(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the types of the variables with indices between begin</span>
<span class="sd">          and end, inclusive of end. Equivalent to</span>
<span class="sd">          variables.get_types(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; t = c.variables.type</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(5)],</span>
<span class="sd">                                      types = [t.continuous, t.integer,</span>
<span class="sd">                                      t.binary, t.semi_continuous, t.semi_integer])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_types(3)</span>
<span class="sd">        &#39;S&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_types(1,3)</span>
<span class="sd">        [&#39;I&#39;, &#39;B&#39;, &#39;S&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_types([2,0,4])</span>
<span class="sd">        [&#39;B&#39;, &#39;C&#39;, &#39;N&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_types()</span>
<span class="sd">        [&#39;C&#39;, &#39;I&#39;, &#39;B&#39;, &#39;S&#39;, &#39;N&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">gettype</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getctype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">gettype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span></div>


<div class="viewcode-block" id="VariablesInterface.get_cols">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_cols">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of columns of the linear constraint matrix.</span>

<span class="sd">        Returns a list of SparsePair instances or a single SparsePair</span>
<span class="sd">        instance, depending on the form by which it was called.</span>

<span class="sd">        There are four forms by which variables.get_cols may be called.</span>

<span class="sd">        variables.get_cols()</span>
<span class="sd">          return the entire linear constraint matrix.</span>

<span class="sd">        variables.get_cols(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the column of</span>
<span class="sd">          the linear constraint matrix associated with variable i.</span>

<span class="sd">        variables.get_cols(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the columns of the linear constraint matrix associated with</span>
<span class="sd">          the variables with indices the members of s.  Equivalent to</span>
<span class="sd">          [variables.get_cols(i) for i in s]</span>

<span class="sd">        variables.get_cols(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the columns of the linear constraint matrix associated</span>
<span class="sd">          with the variables with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          variables.get_cols(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names=[&#39;c1&#39;, &#39;c2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names=[str(i) for i in range(3)],</span>
<span class="sd">        ...     columns=[cplex.SparsePair(ind=[&#39;c1&#39;], val=[1.0]),</span>
<span class="sd">        ...     cplex.SparsePair(ind=[&#39;c2&#39;], val=[2.0]),</span>
<span class="sd">        ...     cplex.SparsePair(ind=[&#39;c1&#39;,&#39;c2&#39;], val=[3.0, 4.0])])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_cols(2)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [3.0, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; for col in c.variables.get_cols(1, 2):</span>
<span class="sd">        ...     print(col)</span>
<span class="sd">        SparsePair(ind = [1], val = [2.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [3.0, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; for col in c.variables.get_cols([2, 0, 1]):</span>
<span class="sd">        ...     print(col)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [3.0, 4.0])</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [1], val = [2.0])</span>
<span class="sd">        &gt;&gt;&gt; for col in c.variables.get_cols():</span>
<span class="sd">        ...     print(col)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [1], val = [2.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [3.0, 4.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcols</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matbeg</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matind</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matval</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getcols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="VariablesInterface.get_histogram">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.VariablesInterface.get_histogram">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a histogram of the columns of the linear constraint matrix.</span>

<span class="sd">        To access the number of columns with given nonzero counts, use</span>
<span class="sd">        slice notation.  If a negative nonzero count is queried in</span>
<span class="sd">        this manner an IndexError will be raised.</span>

<span class="sd">        The __str__ method of the `Histogram` object returns a string</span>
<span class="sd">        displaying the number of columns with given nonzeros counts in</span>
<span class="sd">        human readable form.</span>

<span class="sd">        The data member &quot;orientation&quot; of the histogram object is</span>
<span class="sd">        &quot;column&quot;, indicating that the histogram shows the nonzero</span>
<span class="sd">        counts for the columns of the linear constraint matrix.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; histogram = c.variables.get_histogram()</span>
<span class="sd">        &gt;&gt;&gt; print(histogram)</span>
<span class="sd">        Column counts (excluding fixed variables):</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">            Nonzero Count:   1   2   3</span>
<span class="sd">        Number of Columns:   1   6  36</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &gt;&gt;&gt; histogram[2]</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; histogram[0:4]</span>
<span class="sd">        [0, 1, 6, 36]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="AdvancedLinearConstraintInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AdvancedLinearConstraintInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for handling lazy cuts and user cuts.</span>

<span class="sd">    Lazy cuts are constraints not specified in the constraint</span>
<span class="sd">    matrix of the MIP problem, but that must be not be violated</span>
<span class="sd">    in a solution. Using lazy cuts makes sense when there are a</span>
<span class="sd">    large number of constraints that must be satisfied at a solution,</span>
<span class="sd">    but are unlikely to be violated if they are left out. When</span>
<span class="sd">    you add lazy cuts to your model, set the CPLEX parameter</span>
<span class="sd">    c.parameters.preprocessing.reduce to 0 (zero) or 1 (one)</span>
<span class="sd">    in order to turn off dual reductions.</span>

<span class="sd">    User cuts are constraints that are implied by the constraint</span>
<span class="sd">    matrix and integrality requirements. Adding user cuts is helpful</span>
<span class="sd">    to tighten the MIP formulation. When you add user cuts, set</span>
<span class="sd">    the CPLEX parameter cplex.parameters.preprocessing.reformulations to</span>
<span class="sd">    cplex.parameters.preprocessing.reformulations.values.interfere_uncrush or</span>
<span class="sd">    cplex.parameters.preprocessing.reformulations.values.none to make sure</span>
<span class="sd">    that CPLEX makes only reductions that do not interfere with crushing</span>
<span class="sd">    linear forms (cuts in this case).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AdvancedLinearConstraintInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new AdvancedLinearConstraintInterface.</span>

<span class="sd">        The advanced linear constraints interface is exposed by the</span>
<span class="sd">        top-level `Cplex` class as Cplex.linear_constraints.advanced.</span>
<span class="sd">        This constructor is not meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedLinearConstraintInterface.get_num_lazy_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface.get_num_lazy_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_lazy_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of lazy cuts in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; cut = cplex.SparsePair(ind=[0, 1, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_lazy_constraints(</span>
<span class="sd">        ...     lin_expr=[cut],</span>
<span class="sd">        ...     senses=&quot;E&quot;,</span>
<span class="sd">        ...     rhs=[0.0],</span>
<span class="sd">        ...     names=[&quot;lz1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_lazy_constraints()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">_getnumlazyconstraints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedLinearConstraintInterface.get_num_user_cuts">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface.get_num_user_cuts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_user_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of user cuts in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; cut = cplex.SparsePair(ind=[0, 1, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_user_cuts(</span>
<span class="sd">        ...     lin_expr=[cut],</span>
<span class="sd">        ...     senses=&quot;E&quot;,</span>
<span class="sd">        ...     rhs=[0.0],</span>
<span class="sd">        ...     names=[&quot;usr1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_user_cuts()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">_getnumusercuts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_lazy_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">senses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="p">[</span><span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">],</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: lin_expr, senses, rhs, names&quot;</span>
        <span class="p">)</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addlazyconstraints</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span>
            <span class="n">lin_expr</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

<div class="viewcode-block" id="AdvancedLinearConstraintInterface.add_lazy_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface.add_lazy_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_lazy_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">senses</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds lazy constraints to the problem.</span>

<span class="sd">        linear_constraints.advanced.add_lazy_constraints accepts the</span>
<span class="sd">        keyword arguments lin_expr, senses, rhs, and names.</span>

<span class="sd">        If more than one argument is specified, all arguments must</span>
<span class="sd">        have the same length.</span>

<span class="sd">        lin_expr may be either a list of SparsePair instances or a</span>
<span class="sd">        matrix in list-of-lists format.</span>

<span class="sd">        Note</span>
<span class="sd">          The entries of lin_expr must not contain duplicate indices.</span>
<span class="sd">          If an entry of lin_expr references a variable more than</span>
<span class="sd">          once, either by index, name, or a combination of index and</span>
<span class="sd">          name, an exception will be raised.</span>

<span class="sd">        senses must be either a list of single-character strings or a</span>
<span class="sd">        string containing the senses of the linear constraints.</span>

<span class="sd">        rhs is a list of floats, specifying the righthand side of</span>
<span class="sd">        each linear constraint.</span>

<span class="sd">        names is a list of strings.</span>

<span class="sd">        Returns an iterator containing the indices of the added lazy</span>
<span class="sd">        constraints.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; cut = cplex.SparsePair(ind=[0, 1, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_lazy_constraints(</span>
<span class="sd">        ...     lin_expr=[cut],</span>
<span class="sd">        ...     senses=&quot;E&quot;,</span>
<span class="sd">        ...     rhs=[0.0],</span>
<span class="sd">        ...     names=[&quot;lz1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; cut2 = cplex.SparsePair(ind=[0, 2, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; cut3 = cplex.SparsePair(ind=[0, 2, 5], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_lazy_constraints(</span>
<span class="sd">        ...     lin_expr=[cut2, cut3],</span>
<span class="sd">        ...     senses=&quot;EE&quot;,</span>
<span class="sd">        ...     rhs=[0.0, 0.0],</span>
<span class="sd">        ...     names=[&quot;lz2&quot;, &quot;lz3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_lazy_constraints()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lin_expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span><span class="n">lin_expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_lazy_constraints</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_add_lazy_constraints</span><span class="p">,</span>
                              <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_user_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">senses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="p">[</span><span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">],</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: lin_expr, senses, rhs, names&quot;</span>
        <span class="p">)</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addusercuts</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span>
            <span class="n">lin_expr</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

<div class="viewcode-block" id="AdvancedLinearConstraintInterface.add_user_cuts">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface.add_user_cuts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_user_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">senses</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds user cuts to the problem.</span>

<span class="sd">        linear_constraints.advanced.add_user_cuts accepts the keyword</span>
<span class="sd">        arguments lin_expr, senses, rhs, and names.</span>

<span class="sd">        If more than one argument is specified, all arguments must</span>
<span class="sd">        have the same length.</span>

<span class="sd">        lin_expr may be either a list of SparsePair instances or a</span>
<span class="sd">        matrix in list-of-lists format.</span>

<span class="sd">        Note</span>
<span class="sd">          The entries of lin_expr must not contain duplicate indices.</span>
<span class="sd">          If an entry of lin_expr references a variable more than</span>
<span class="sd">          once, either by index, name, or a combination of index and</span>
<span class="sd">          name, an exception will be raised.</span>

<span class="sd">        senses must be either a list of single-character strings or a</span>
<span class="sd">        string containing the senses of the linear constraints.</span>

<span class="sd">        rhs is a list of floats, specifying the righthand side of</span>
<span class="sd">        each linear constraint.</span>

<span class="sd">        names is a list of strings.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; cut = cplex.SparsePair(ind=[0, 1, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_user_cuts(</span>
<span class="sd">        ...     names=[&quot;usr1&quot;],</span>
<span class="sd">        ...     lin_expr=[cut],</span>
<span class="sd">        ...     senses=&quot;E&quot;,</span>
<span class="sd">        ...     rhs=[0.0])</span>
<span class="sd">        &gt;&gt;&gt; cut2 = cplex.SparsePair(ind=[0, 2, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; cut3 = cplex.SparsePair(ind=[0, 2, 5], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_user_cuts(</span>
<span class="sd">        ...     lin_expr=[cut2, cut3],</span>
<span class="sd">        ...     senses = &quot;EE&quot;,</span>
<span class="sd">        ...     rhs=[0.0, 0.0],</span>
<span class="sd">        ...     names=[&quot;usr2&quot;, &quot;usr3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_user_cuts()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span>
            <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_user_cuts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_user_cuts</span><span class="p">,</span>
                              <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedLinearConstraintInterface.free_lazy_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface.free_lazy_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">free_lazy_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all lazy constraints from the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; cut = cplex.SparsePair(ind=[0, 1, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_lazy_constraints(</span>
<span class="sd">        ...     lin_expr = [cut],</span>
<span class="sd">        ...     senses = &quot;E&quot;,</span>
<span class="sd">        ...     rhs = [0.0],</span>
<span class="sd">        ...     names = [&quot;lz1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_lazy_constraints()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.free_lazy_constraints()</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_lazy_constraints()</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">freelazyconstraints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedLinearConstraintInterface.free_user_cuts">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedLinearConstraintInterface.free_user_cuts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">free_user_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all user cuts from the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; cut = cplex.SparsePair(ind=[0, 1, 4], val=[1.0, 1.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.advanced.add_user_cuts(</span>
<span class="sd">        ...     lin_expr=[cut],</span>
<span class="sd">        ...     senses=&quot;E&quot;,</span>
<span class="sd">        ...     rhs=[0.0],</span>
<span class="sd">        ...     names=[&quot;usr1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_user_cuts()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.free_user_cuts()</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.advanced.get_num_user_cuts()</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">freeusercuts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="LinearConstraintInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LinearConstraintInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for adding, modifying, and querying linear constraints.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="LinearConstraintInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new LinearConstraintInterface.</span>

<span class="sd">        The linear constraints interface is exposed by the top-level</span>
<span class="sd">        `Cplex` class as `Cplex.linear_constraints`.  This constructor is</span>
<span class="sd">        not meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">cplex</span><span class="p">,</span> <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getrowindex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">advanced</span> <span class="o">=</span> <span class="n">AdvancedLinearConstraintInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `AdvancedLinearConstraintInterface()` &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of linear constraints.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names = [&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_num()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumrows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">range_values</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">senses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">range_values</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">]</span>
        <span class="n">num_new_rows</span> <span class="o">=</span> <span class="n">max_arg_length</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="n">arg_list</span><span class="p">,</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: lin_expr, senses, rhs, range_values, names&quot;</span>
        <span class="p">)</span>
        <span class="n">num_old_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">lin_expr</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chbmatrix</span><span class="p">(</span><span class="n">lin_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                                    <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">rmat</span><span class="p">,</span> <span class="n">nnz</span><span class="p">):</span>
                <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addrows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="n">num_new_rows</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span>
                                 <span class="n">rmat</span><span class="p">,</span> <span class="p">[],</span> <span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">range_values</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgrngval</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                    <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_old_rows</span><span class="p">,</span> <span class="n">num_old_rows</span> <span class="o">+</span> <span class="n">num_new_rows</span><span class="p">)),</span>
                    <span class="n">range_values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">senses</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">range_values</span><span class="p">:</span>
                <span class="n">range_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">newrows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span>
                             <span class="n">range_values</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

<div class="viewcode-block" id="LinearConstraintInterface.add">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">senses</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds linear constraints to the problem.</span>

<span class="sd">        linear_constraints.add accepts the keyword arguments lin_expr,</span>
<span class="sd">        senses, rhs, range_values, and names.</span>

<span class="sd">        If more than one argument is specified, all arguments must</span>
<span class="sd">        have the same length.</span>

<span class="sd">        lin_expr may be either a list of SparsePair instances or a</span>
<span class="sd">        matrix in list-of-lists format.</span>

<span class="sd">        Note</span>
<span class="sd">          The entries of lin_expr must not contain duplicate indices.</span>
<span class="sd">          If an entry of lin_expr references a variable more than</span>
<span class="sd">          once, either by index, name, or a combination of index and</span>
<span class="sd">          name, an exception will be raised.</span>

<span class="sd">        senses must be either a list of single-character strings or a</span>
<span class="sd">        string containing the senses of the linear constraints.</span>
<span class="sd">        Each entry must</span>
<span class="sd">        be one of &#39;G&#39;, &#39;L&#39;, &#39;E&#39;, and &#39;R&#39;, indicating</span>
<span class="sd">        greater-than-or-equal-to (&gt;=), less-than-or-equal-to (&lt;=),</span>
<span class="sd">        equality (=), and ranged constraints, respectively.</span>

<span class="sd">        rhs is a list of floats, specifying the righthand side of</span>
<span class="sd">        each linear constraint.</span>

<span class="sd">        range_values is a list of floats, specifying the difference</span>
<span class="sd">        between lefthand side and righthand side of each linear constraint.</span>
<span class="sd">        If range_values[i] &gt; 0 (zero) then the constraint i is defined as</span>
<span class="sd">        rhs[i] &lt;= rhs[i] + range_values[i]. If range_values[i] &lt; 0 (zero)</span>
<span class="sd">        then constraint i is defined as</span>
<span class="sd">        rhs[i] + range_value[i] &lt;= a*x &lt;= rhs[i].</span>

<span class="sd">        names is a list of strings.</span>

<span class="sd">        Returns an iterator containing the indices of the added linear</span>
<span class="sd">        constraints.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">                lin_expr = [cplex.SparsePair(ind = [&quot;x1&quot;, &quot;x3&quot;], val = [1.0, -1.0]),</span>
<span class="sd">                            cplex.SparsePair(ind = [&quot;x1&quot;, &quot;x2&quot;], val = [1.0, 1.0]),</span>
<span class="sd">                            cplex.SparsePair(ind = [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;], val = [-1.0] * 3),</span>
<span class="sd">                            cplex.SparsePair(ind = [&quot;x2&quot;, &quot;x3&quot;], val = [10.0, -2.0])],</span>
<span class="sd">                senses = [&quot;E&quot;, &quot;L&quot;, &quot;G&quot;, &quot;R&quot;],</span>
<span class="sd">                rhs = [0.0, 1.0, -1.0, 2.0],</span>
<span class="sd">                range_values = [0.0, 0.0, 0.0, -10.0],</span>
<span class="sd">                names = [&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs()</span>
<span class="sd">        [0.0, 1.0, -1.0, 2.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">range_values</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span>
            <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">range_values</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">,</span>
                              <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">range_values</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes linear constraints from the problem.</span>

<span class="sd">        There are four forms by which linear_constraints.delete may be</span>
<span class="sd">        called.</span>

<span class="sd">        linear_constraints.delete()</span>
<span class="sd">          deletes all linear constraints from the problem.</span>

<span class="sd">        linear_constraints.delete(i)</span>
<span class="sd">          i must be a linear constraint name or index. Deletes the</span>
<span class="sd">          linear constraint whose index or name is i.</span>

<span class="sd">        linear_constraints.delete(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Deletes the linear constraints with names or indices contained</span>
<span class="sd">          within s. Equivalent to [linear_constraints.delete(i) for i in s].</span>

<span class="sd">        linear_constraints.delete(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Deletes the linear constraints with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          linear_constraints.delete(range(begin, end + 1)). This will</span>
<span class="sd">          give the best performance when deleting batches of linear</span>
<span class="sd">          constraints.</span>

<span class="sd">        See `CPXdelrows &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/delrows.html&gt;`_ in the Callable Library Reference Manual</span>
<span class="sd">        for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.delete(8)</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.delete(&quot;1&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.delete([2, &quot;0&quot;, 5])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names()</span>
<span class="sd">        [&#39;4&#39;, &#39;6&#39;, &#39;7&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delrows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.set_rhs">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.set_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the righthand side of a set of linear constraints.</span>

<span class="sd">        There are two forms by which linear_constraints.set_rhs may be</span>
<span class="sd">        called.</span>

<span class="sd">        linear_constraints.set_rhs(i, rhs)</span>
<span class="sd">          i must be a row name or index and rhs must be a real number.</span>
<span class="sd">          Sets the righthand side of the row whose index or name is</span>
<span class="sd">          i to rhs.</span>

<span class="sd">        linear_constraints.set_rhs(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, rhs) pairs, each</span>
<span class="sd">          of which consists of a row name or index and a real</span>
<span class="sd">          number.  Sets the righthand side of the specified rows to</span>
<span class="sd">          the corresponding values.  Equivalent to</span>
<span class="sd">          [linear_constraints.set_rhs(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names = [&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs()</span>
<span class="sd">        [0.0, 0.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_rhs(&quot;c1&quot;, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs()</span>
<span class="sd">        [0.0, 1.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_rhs([(&quot;c3&quot;, 2.0), (2, -1.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs()</span>
<span class="sd">        [0.0, 1.0, -1.0, 2.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">chgrhs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgrhs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">chgrhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.set_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.set_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the name of a linear constraint or set of linear constraints.</span>

<span class="sd">        There are two forms by which linear_constraints.set_names may be</span>
<span class="sd">        called.</span>

<span class="sd">        linear_constraints.set_names(i, name)</span>
<span class="sd">          i must be a linear constraint name or index and name must be a</span>
<span class="sd">          string.</span>

<span class="sd">        linear_constraints.set_names(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, name) pairs,</span>
<span class="sd">          each of which consists of a linear constraint name or index and a</span>
<span class="sd">          string.  Sets the name of the specified linear constraints to the</span>
<span class="sd">          corresponding strings.  Equivalent to</span>
<span class="sd">          [linear_constraints.set_names(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names = [&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_names(&quot;c1&quot;, &quot;second&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names(1)</span>
<span class="sd">        &#39;second&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_names([(&quot;c3&quot;, &quot;last&quot;), (2, &quot;middle&quot;)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names()</span>
<span class="sd">        [&#39;c0&#39;, &#39;second&#39;, &#39;middle&#39;, &#39;last&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">setnames</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgrowname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">setnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.set_senses">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.set_senses">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_senses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the sense of a linear constraint or set of linear constraints.</span>

<span class="sd">        There are two forms by which linear_constraints.set_senses may be</span>
<span class="sd">        called.</span>

<span class="sd">        linear_constraints.set_senses(i, type)</span>
<span class="sd">          i must be a row name or index and name must be a</span>
<span class="sd">          single-character string.</span>

<span class="sd">        linear_constraints.set_senses(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, sense) pairs,</span>
<span class="sd">          each of which consists of a row name or index and a</span>
<span class="sd">          single-character string.  Sets the sense of the specified</span>
<span class="sd">          rows to the corresponding strings.  Equivalent to</span>
<span class="sd">          [linear_constraints.set_senses(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        The senses of the constraints must be one of &#39;G&#39;, &#39;L&#39;, &#39;E&#39;,</span>
<span class="sd">        and &#39;R&#39;, indicating greater-than-or-equal-to (&gt;=),</span>
<span class="sd">        less-than-or-equal-to (&lt;=), equality (=), and ranged constraints,</span>
<span class="sd">        respectively.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names = [&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_senses()</span>
<span class="sd">        [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_senses(&quot;c1&quot;, &quot;G&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_senses(1)</span>
<span class="sd">        &#39;G&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_senses([(&quot;c3&quot;, &quot;L&quot;), (2, &quot;R&quot;)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_senses()</span>
<span class="sd">        [&#39;E&#39;, &#39;G&#39;, &#39;R&#39;, &#39;L&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">senses</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgsense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                          <span class="n">indices</span><span class="p">,</span> <span class="n">senses</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.set_linear_components">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.set_linear_components">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_linear_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets a linear constraint or set of linear constraints.</span>

<span class="sd">        There are two forms by which this method may be called:</span>

<span class="sd">        linear_constraints.set_linear_components(i, lin)</span>
<span class="sd">          i must be a row name or index and lin must be either a</span>
<span class="sd">          SparsePair or a pair of sequences, the first of which</span>
<span class="sd">          consists of variable names or indices, the second of which</span>
<span class="sd">          consists of floats.</span>

<span class="sd">        linear_constraints.set_linear_components(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, lin) pairs,</span>
<span class="sd">          each of which consists of a row name or index and a vector</span>
<span class="sd">          as described above.  Sets the specified rows</span>
<span class="sd">          to the corresponding vector.  Equivalent to</span>
<span class="sd">          [linear_constraints.set_linear_components(pair[0], pair[1])</span>
<span class="sd">          for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names=[&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&quot;x0&quot;, &quot;x1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_linear_components(&quot;c0&quot;, [[&quot;x0&quot;], [1.0]])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rows(&quot;c0&quot;)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_linear_components([</span>
<span class="sd">        ...     (&quot;c3&quot;, cplex.SparsePair(ind=[&quot;x1&quot;], val=[-1.0])),</span>
<span class="sd">        ...     (2, [[0, 1], [-2.0, 3.0]])])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rows(&quot;c3&quot;)</span>
<span class="sd">        SparsePair(ind = [1], val = [-1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rows(2)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [-2.0, 3.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">setlin</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span> <span class="n">vars_</span><span class="p">):</span>
            <span class="n">validate_arg_lengths</span><span class="p">([</span><span class="n">cons</span><span class="p">,</span> <span class="n">vars_</span><span class="p">])</span>
            <span class="n">cons</span> <span class="o">=</span> <span class="n">convert_sequence</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index</span><span class="p">)</span>
            <span class="n">varcache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span> <span class="n">vars_</span><span class="p">):</span>
                <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgcoeflist</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span>
                    <span class="n">convert_sequence</span><span class="p">(</span>
                        <span class="n">ind</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_get_index</span><span class="p">,</span>
                        <span class="n">varcache</span>
                    <span class="p">),</span>
                    <span class="n">val</span>
                <span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">setlin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.set_range_values">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.set_range_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_range_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the range values for a set of linear constraints.</span>

<span class="sd">        That is, this method sets the lefthand side (lhs) for each ranged</span>
<span class="sd">        constraint of the form lhs &lt;= lin_expr &lt;= rhs.</span>

<span class="sd">        The range values are a list of floats, specifying the difference</span>
<span class="sd">        between lefthand side and righthand side of each linear constraint.</span>
<span class="sd">        If range_values[i] &gt; 0 (zero) then the constraint i is defined as</span>
<span class="sd">        rhs[i] &lt;= rhs[i] + range_values[i]. If range_values[i] &lt; 0 (zero)</span>
<span class="sd">        then constraint i is defined as</span>
<span class="sd">        rhs[i] + range_value[i] &lt;= a*x &lt;= rhs[i].</span>

<span class="sd">        Note that changing the range values will not change the sense of a</span>
<span class="sd">        constraint; you must call the method set_senses() of the class</span>
<span class="sd">        LinearConstraintInterface to change the sense of a ranged row if</span>
<span class="sd">        the previous range value was 0 (zero) and the constraint sense was not</span>
<span class="sd">        &#39;R&#39;. Similarly, changing the range coefficient from a nonzero value to</span>
<span class="sd">        0 (zero) will not change the constraint sense from &#39;R&quot; to &quot;E&quot;; an</span>
<span class="sd">        additional call of setsenses() is required to accomplish that.</span>

<span class="sd">        There are two forms by which linear_constraints.set_range_values may be</span>
<span class="sd">        called.</span>

<span class="sd">        linear_constraints.set_range_values(i, range)</span>
<span class="sd">          i must be a row name or index and range must be a real</span>
<span class="sd">          number.  Sets the range value of the row whose index or</span>
<span class="sd">          name is i to range.</span>

<span class="sd">        linear_constraints.set_range_values(seq_of_pairs)</span>
<span class="sd">          seq_of_pairs must be a list or tuple of (i, range) pairs, each</span>
<span class="sd">          of which consists of a row name or index and a real</span>
<span class="sd">          number.  Sets the range values for the specified rows to</span>
<span class="sd">          the corresponding values.  Equivalent to</span>
<span class="sd">          [linear_constraints.set_range_values(pair[0], pair[1]) for pair in seq_of_pairs].</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names = [&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_range_values(&quot;c1&quot;, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_range_values()</span>
<span class="sd">        [0.0, 1.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_range_values([(&quot;c3&quot;, 2.0), (2, -1.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_range_values()</span>
<span class="sd">        [0.0, 1.0, -1.0, 2.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">chgrngval</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgrngval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">chgrngval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.set_coefficients">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.set_coefficients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets individual coefficients of the linear constraint matrix.</span>

<span class="sd">        There are two forms by which</span>
<span class="sd">        linear_constraints.set_coefficients may be called.</span>

<span class="sd">        linear_constraints.set_coefficients(row, col, val)</span>
<span class="sd">          row and col must be indices or names of a linear constraint</span>
<span class="sd">          and variable, respectively.  The corresponding coefficient</span>
<span class="sd">          is set to val.</span>

<span class="sd">        linear_constraints.set_coefficients(coefficients)</span>
<span class="sd">          coefficients must be a list of (row, col, val) triples as</span>
<span class="sd">          described above.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names = [&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;, &quot;x1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_coefficients(&quot;c0&quot;, &quot;x1&quot;, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rows(0)</span>
<span class="sd">        SparsePair(ind = [1], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.set_coefficients([(&quot;c2&quot;, &quot;x0&quot;, 2.0),</span>
<span class="sd">                                                   (&quot;c2&quot;, &quot;x1&quot;, -1.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rows(&quot;c2&quot;)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [2.0, -1.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">arg</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arg_list</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgcoeflist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">arg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">arg_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">arg_list</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_rhs">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the righthand side of constraints from the problem.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        linear_constraints.get_rhs()</span>
<span class="sd">          return the righthand side of all linear constraints from</span>
<span class="sd">          the problem.</span>

<span class="sd">        linear_constraints.get_rhs(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          righthand side of the linear constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        linear_constraints.get_rhs(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the righthand side of the linear constraints with</span>
<span class="sd">          indices the members of s.  Equivalent to</span>
<span class="sd">          [linear_constraints.get_rhs(i) for i in s]</span>

<span class="sd">        linear_constraints.get_rhs(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the righthand side of the linear</span>
<span class="sd">          constraints with indices between begin and end, inclusive</span>
<span class="sd">          of end. Equivalent to</span>
<span class="sd">          linear_constraints.get_rhs(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(rhs = [1.5 * i for i in range(10)],</span>
<span class="sd">                                     names = [str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs(8)</span>
<span class="sd">        12.0</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs(&quot;1&quot;,3)</span>
<span class="sd">        [1.5, 3.0, 4.5]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs([2,&quot;0&quot;,5])</span>
<span class="sd">        [3.0, 0.0, 7.5]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rhs()</span>
<span class="sd">        [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getrhs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getrhs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getrhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_senses">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_senses">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_senses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the senses of constraints from the problem.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        linear_constraints.get_senses()</span>
<span class="sd">          return the senses of all linear constraints from the</span>
<span class="sd">          problem.</span>

<span class="sd">        linear_constraints.get_senses(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          sense of the linear constraint whose index or name is i.</span>

<span class="sd">        linear_constraints.get_senses(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the senses of the linear constraints with indices</span>
<span class="sd">          the members of s.  Equivalent to</span>
<span class="sd">          [linear_constraints.get_senses(i) for i in s]</span>

<span class="sd">        linear_constraints.get_senses(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the senses of the linear constraints</span>
<span class="sd">          with indices between begin and end, inclusive of end.</span>
<span class="sd">          Equivalent to</span>
<span class="sd">          linear_constraints.get_senses(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">        ...     senses=[&quot;E&quot;, &quot;G&quot;, &quot;L&quot;, &quot;R&quot;],</span>
<span class="sd">        ...     names=[str(i) for i in range(4)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_num()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_senses(1)</span>
<span class="sd">        &#39;G&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_senses(&quot;1&quot;,3)</span>
<span class="sd">        [&#39;G&#39;, &#39;L&#39;, &#39;R&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_senses([2,&quot;0&quot;,1])</span>
<span class="sd">        [&#39;L&#39;, &#39;E&#39;, &#39;G&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_senses()</span>
<span class="sd">        [&#39;E&#39;, &#39;G&#39;, &#39;L&#39;, &#39;R&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getsense</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getsense</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">s</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_range_values">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_range_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_range_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the range values of linear constraints from the problem.</span>

<span class="sd">        That is, this method returns the lefthand side (lhs) for each</span>
<span class="sd">        ranged constraint of the form lhs &lt;= lin_expr &lt;= rhs. This method</span>
<span class="sd">        makes sense only for ranged constraints, that is, linear constraints</span>
<span class="sd">        of sense &#39;R&#39;.</span>

<span class="sd">        The range values are a list of floats, specifying the difference</span>
<span class="sd">        between lefthand side and righthand side of each linear constraint.</span>
<span class="sd">        If range_values[i] &gt; 0 (zero) then the constraint i is defined as</span>
<span class="sd">        rhs[i] &lt;= rhs[i] + range_values[i]. If range_values[i] &lt; 0 (zero)</span>
<span class="sd">        then constraint i is defined as</span>
<span class="sd">        rhs[i] + range_value[i] &lt;= a*x &lt;= rhs[i].</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        linear_constraints.get_range_values()</span>
<span class="sd">          return the range values of all linear constraints from the</span>
<span class="sd">          problem.</span>

<span class="sd">        linear_constraints.get_range_values(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          range value of the linear constraint whose index or name is i.</span>

<span class="sd">        linear_constraints.get_range_values(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the range values of the linear constraints with</span>
<span class="sd">          indices the members of s.  Equivalent to</span>
<span class="sd">          [linear_constraints.get_range_values(i) for i in s]</span>

<span class="sd">        linear_constraints.get_range_values(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the range values of the linear</span>
<span class="sd">          constraints with indices between begin and end, inclusive</span>
<span class="sd">          of end. Equivalent to</span>
<span class="sd">          linear_constraints.get_range_values(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">                range_values = [1.5 * i for i in range(10)],</span>
<span class="sd">                senses = [&quot;R&quot;] * 10,</span>
<span class="sd">                names = [str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_range_values(8)</span>
<span class="sd">        12.0</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_range_values(&quot;1&quot;,3)</span>
<span class="sd">        [1.5, 3.0, 4.5]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_range_values([2,&quot;0&quot;,5])</span>
<span class="sd">        [3.0, 0.0, 7.5]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_range_values()</span>
<span class="sd">        [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getrngval</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getrngval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getrngval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_coefficients">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_coefficients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns coefficients by row, column coordinates.</span>

<span class="sd">        There are two forms by which</span>
<span class="sd">        linear_constraints.get_coefficients may be called.</span>

<span class="sd">        linear_constraints.get_coefficients(row, col)</span>
<span class="sd">          returns the coefficient.</span>

<span class="sd">        linear_constraints.get_coefficients(sequence_of_pairs)</span>
<span class="sd">          returns a list of coefficients.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;, &quot;x1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">                names = [&quot;c0&quot;, &quot;c1&quot;],</span>
<span class="sd">                lin_expr = [[[1], [1.0]], [[0, 1], [2.0, -1.0]]])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_coefficients(&quot;c0&quot;, &quot;x1&quot;)</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_coefficients([(&quot;c1&quot;, &quot;x0&quot;), (&quot;c1&quot;, &quot;x1&quot;)])</span>
<span class="sd">        [2.0, -1.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcoef</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">getcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_coefficients</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_rows">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of rows of the linear constraint matrix.</span>

<span class="sd">        Returns a list of SparsePair instances or a single SparsePair</span>
<span class="sd">        instance, depending on the form by which it was called.</span>

<span class="sd">        There are four forms by which linear_constraints.get_rows may be</span>
<span class="sd">        called.</span>

<span class="sd">        linear_constraints.get_rows()</span>
<span class="sd">          return the entire linear constraint matrix.</span>

<span class="sd">        linear_constraints.get_rows(i)</span>
<span class="sd">          i must be a row name or index.  Returns the ith row of</span>
<span class="sd">          the linear constraint matrix.</span>

<span class="sd">        linear_constraints.get_rows(s)</span>
<span class="sd">          s must be a sequence of row names or indices.  Returns the</span>
<span class="sd">          rows of the linear constraint matrix indexed by the members</span>
<span class="sd">          of s.  Equivalent to</span>
<span class="sd">          [linear_constraints.get_rows(i) for i in s]</span>

<span class="sd">        linear_constraints.get_rows(begin, end)</span>
<span class="sd">          begin and end must be row indices or row names. Returns the</span>
<span class="sd">          rows of the linear constraint matrix with indices between begin</span>
<span class="sd">          and end, inclusive of end. Equivalent to</span>
<span class="sd">          linear_constraints.get_rows(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">        ...     names=[&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;],</span>
<span class="sd">        ...     lin_expr=[</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x1&quot;, &quot;x3&quot;], val=[1.0, -1.0]),</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x1&quot;, &quot;x2&quot;], val=[1.0, 1.0]),</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;], val=[-1.0] * 3),</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x2&quot;, &quot;x3&quot;], val=[10.0, -2.0])</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_rows(0)</span>
<span class="sd">        SparsePair(ind = [0, 2], val = [1.0, -1.0])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.linear_constraints.get_rows(1,3):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 1.0])</span>
<span class="sd">        SparsePair(ind = [0, 1, 2], val = [-1.0, -1.0, -1.0])</span>
<span class="sd">        SparsePair(ind = [1, 2], val = [10.0, -2.0])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.linear_constraints.get_rows([&quot;c2&quot;, 0]):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [0, 1, 2], val = [-1.0, -1.0, -1.0])</span>
<span class="sd">        SparsePair(ind = [0, 2], val = [1.0, -1.0])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.linear_constraints.get_rows():</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [0, 2], val = [1.0, -1.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 1.0])</span>
<span class="sd">        SparsePair(ind = [0, 1, 2], val = [-1.0, -1.0, -1.0])</span>
<span class="sd">        SparsePair(ind = [1, 2], val = [10.0, -2.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getrows</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getrows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matbeg</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matind</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matval</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_num_nonzeros">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_num_nonzeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nonzeros in the linear constraint</span>
<span class="sd">        matrix.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">        ...     names=[&quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;],</span>
<span class="sd">        ...     lin_expr=[</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x1&quot;, &quot;x3&quot;], val=[1.0, -1.0]),</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x1&quot;, &quot;x2&quot;], val=[1.0, 1.0]),</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;], val=[-1.0] * 3),</span>
<span class="sd">        ...         cplex.SparsePair(ind=[&quot;x2&quot;, &quot;x3&quot;], val=[10.0, -2.0])</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_num_nonzeros()</span>
<span class="sd">        9</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumnz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of linear constraints from the problem.</span>

<span class="sd">        There are four forms by which linear_constraints.get_names may be called.</span>

<span class="sd">        linear_constraints.get_names()</span>
<span class="sd">          return the names of all linear constraints from the problem.</span>

<span class="sd">        linear_constraints.get_names(i)</span>
<span class="sd">          i must be a linear constraint index.  Returns the name of row i.</span>

<span class="sd">        linear_constraints.get_names(s)</span>
<span class="sd">          s must be a sequence of row indices.  Returns the names of</span>
<span class="sd">          the linear constraints with indices the members of s.</span>
<span class="sd">          Equivalent to [linear_constraints.get_names(i) for i in s]</span>

<span class="sd">        linear_constraints.get_names(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices. Returns the</span>
<span class="sd">          names of the linear constraints with indices between begin and</span>
<span class="sd">          end, inclusive of end. Equivalent to</span>
<span class="sd">          linear_constraints.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(names = [&quot;c&quot; + str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names(8)</span>
<span class="sd">        &#39;c8&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names(1, 3)</span>
<span class="sd">        [&#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names([2, 0, 5])</span>
<span class="sd">        [&#39;c2&#39;, &#39;c0&#39;, &#39;c5&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.linear_constraints.get_names()</span>
<span class="sd">        [&#39;c0&#39;, &#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;c4&#39;, &#39;c5&#39;, &#39;c6&#39;, &#39;c7&#39;, &#39;c8&#39;, &#39;c9&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getrowname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                       <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearConstraintInterface.get_histogram">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.LinearConstraintInterface.get_histogram">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a histogram of the rows of the linear constraint matrix.</span>

<span class="sd">        To access the number of rows with given nonzero counts, use</span>
<span class="sd">        slice notation.  If a negative nonzero count is queried in</span>
<span class="sd">        this manner an IndexError will be raised.</span>

<span class="sd">        The __str__ method of the `Histogram` object returns a string</span>
<span class="sd">        displaying the number of rows with given nonzeros counts in</span>
<span class="sd">        human readable form.</span>

<span class="sd">        The data member &quot;orientation&quot; of the histogram object is</span>
<span class="sd">        &quot;row&quot;, indicating that the histogram shows the nonzero</span>
<span class="sd">        counts for the rows of the linear constraint matrix.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; histogram = c.linear_constraints.get_histogram()</span>
<span class="sd">        &gt;&gt;&gt; print(histogram)</span>
<span class="sd">        Row counts (excluding fixed variables):</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">         Nonzero Count:   3   4   5  10  37</span>
<span class="sd">        Number of Rows:   1   9   1   4   1</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &gt;&gt;&gt; histogram[4]</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; histogram[2:7]</span>
<span class="sd">        [0, 1, 9, 1, 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="IndicatorType">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IndicatorType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identifiers for types of indicator constraints.&quot;&quot;&quot;</span>
    <span class="n">if_</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_INDICATOR_IF</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CPX_INDICATOR_IF (&#39;-&gt;&#39;).&quot;&quot;&quot;</span>
    <span class="n">onlyif</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_INDICATOR_ONLYIF</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CPX_INDICATOR_ONLYIF (&#39;&lt;-&#39;)&quot;&quot;&quot;</span>
    <span class="n">iff</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_INDICATOR_IFANDONLYIF</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CPX_INDICATOR_IFANDONLYIF (&#39;&lt;-&gt;&#39;)&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="IndicatorConstraintInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IndicatorConstraintInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for adding, modifying, and querying indicator constraints.&quot;&quot;&quot;</span>

    <span class="n">type_</span> <span class="o">=</span> <span class="n">IndicatorType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `IndicatorType()`&quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorConstraintInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new IndicatorConstraintInterface.</span>

<span class="sd">        The indicator constraints interface is exposed by the top-level</span>
<span class="sd">        `Cplex` class as `Cplex.indicator_constraints`.  This constructor</span>
<span class="sd">        is not meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">cplex</span><span class="p">,</span>
                         <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstrindex</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of indicator constraints.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.add(name=&quot;ind1&quot;)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumindconstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">indvar</span><span class="p">,</span> <span class="n">complemented</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                   <span class="n">indtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sense</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">sense</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sense</span><span class="p">)</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">lin_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">indvar</span><span class="p">,</span> <span class="n">complemented</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                    <span class="n">indtype</span><span class="p">]</span>
        <span class="n">num_new_rows</span> <span class="o">=</span> <span class="n">max_arg_length</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="n">arg_list</span><span class="p">,</span>
            <span class="s2">&quot;: lin_expr, sense, rhs, indvar, complemented, name, indtype&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chbmatrix</span><span class="p">(</span><span class="n">lin_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_env_lp_ptr</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">linmat</span><span class="p">,</span> <span class="n">nnz</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addindconstr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                  <span class="n">num_new_rows</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">indvar</span><span class="p">),</span>
                                  <span class="n">complemented</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span>
                                  <span class="n">linmat</span><span class="p">,</span> <span class="n">indtype</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>

<div class="viewcode-block" id="IndicatorConstraintInterface.add_batch">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.add_batch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">complemented</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds indicator constraints to the problem.</span>

<span class="sd">        Takes up to eight keyword arguments.</span>

<span class="sd">        If more than one argument is specified, all arguments must</span>
<span class="sd">        have the same length.</span>

<span class="sd">        lin_expr : either a list of SparsePair instances or a matrix in</span>
<span class="sd">        list-of-lists format.</span>

<span class="sd">        Note</span>
<span class="sd">          lin_expr must not contain duplicate indices.  If lin_expr</span>
<span class="sd">          references a variable more than once, either by index, name,</span>
<span class="sd">          or a combination of index and name, an exception will be</span>
<span class="sd">          raised.</span>

<span class="sd">        sense : must be either a list of single-character strings or a</span>
<span class="sd">        string containing the senses of the indicator constraints.</span>
<span class="sd">        Each entry must be one of &#39;G&#39;, &#39;L&#39;, &#39;E&#39;, indicating</span>
<span class="sd">        greater-than-or-equal-to (&gt;=), less-than-or-equal-to (&lt;=), and</span>
<span class="sd">        equality (=), respectively. Left unspecified, the default is &#39;E&#39;.</span>

<span class="sd">        rhs : a list of floats, specifying the righthand side of each</span>
<span class="sd">        indicator constraint.</span>

<span class="sd">        indvar : a list of names or indices (or a mixture of the two), of</span>
<span class="sd">        the variables that control whether the constraint is active or</span>
<span class="sd">        not.</span>

<span class="sd">        complemented : a list of values (0 or 1). Default value of 0</span>
<span class="sd">        instructs CPLEX to interpret indicator constraint as active when</span>
<span class="sd">        the indicator variable is 1. Set complemented to 1 to instruct</span>
<span class="sd">        CPLEX that the indicator constraint is active when indvar = 0.</span>

<span class="sd">        name : a list of strings that determine the names of the</span>
<span class="sd">        individual constraints.</span>

<span class="sd">        indtype : a list of the types of indicator constraints. Defaults</span>
<span class="sd">        to CPX_INDICATOR_IF (&#39;-&gt;&#39;).  See `IndicatorType()`.</span>

<span class="sd">        Returns an iterator containing the indices of the added indicator</span>
<span class="sd">        constraints.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.indicator_constraints.add_batch(</span>
<span class="sd">        ...     lin_expr=[cplex.SparsePair(ind=[&quot;x2&quot;], val=[2.0]),</span>
<span class="sd">        ...               cplex.SparsePair(ind=[&quot;x3&quot;], val=[2.0])],</span>
<span class="sd">        ...     sense=&quot;LL&quot;,</span>
<span class="sd">        ...     rhs=[1.0, 1.0],</span>
<span class="sd">        ...     indvar=[&quot;x1&quot;, &quot;x2&quot;],</span>
<span class="sd">        ...     complemented=[0, 0],</span>
<span class="sd">        ...     name=[&quot;ind1&quot;, &quot;ind2&quot;],</span>
<span class="sd">        ...     indtype=[c.indicator_constraints.type_.if_,</span>
<span class="sd">        ...              c.indicator_constraints.type_.if_])</span>
<span class="sd">        &gt;&gt;&gt; len(list(indices))</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lin_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">indvar</span><span class="p">,</span>
         <span class="n">complemented</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indtype</span><span class="p">)</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span>
             <span class="n">lin_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">indvar</span><span class="p">,</span> <span class="n">complemented</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_batch</span><span class="p">,</span>
                              <span class="n">lin_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">indvar</span><span class="p">,</span> <span class="n">complemented</span><span class="p">,</span>
                              <span class="n">name</span><span class="p">,</span> <span class="n">indtype</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">indvar</span><span class="p">,</span> <span class="n">complemented</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
             <span class="n">indtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_batch</span><span class="p">([</span><span class="n">lin_expr</span><span class="p">],</span> <span class="n">sense</span><span class="p">,</span> <span class="p">[</span><span class="n">rhs</span><span class="p">],</span> <span class="p">[</span><span class="n">indvar</span><span class="p">],</span> <span class="p">[</span><span class="n">complemented</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="p">[</span><span class="n">indtype</span><span class="p">])</span>

<div class="viewcode-block" id="IndicatorConstraintInterface.add">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">indvar</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">complemented</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">indtype</span><span class="o">=</span><span class="n">IndicatorType</span><span class="o">.</span><span class="n">if_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds an indicator constraint to the problem.</span>

<span class="sd">        Takes up to eight keyword arguments.</span>

<span class="sd">        lin_expr : either a SparsePair or a list of two lists, the first of</span>
<span class="sd">        which contains variable indices or names, the second of which</span>
<span class="sd">        contains values.</span>

<span class="sd">        Note</span>
<span class="sd">          lin_expr must not contain duplicate indices.  If lin_expr</span>
<span class="sd">          references a variable more than once, either by index, name,</span>
<span class="sd">          or a combination of index and name, an exception will be</span>
<span class="sd">          raised.</span>

<span class="sd">        sense : the sense of the constraint, may be &quot;L&quot;, &quot;G&quot;, or &quot;E&quot;:</span>
<span class="sd">        default is &quot;E&quot;</span>

<span class="sd">        rhs : a float defining the righthand side of the constraint</span>

<span class="sd">        indvar : the name or index of the variable that controls if</span>
<span class="sd">        the constraint is active</span>

<span class="sd">        complemented : default value of 0 instructs CPLEX to interpret</span>
<span class="sd">        indicator constraint as active when the indicator variable is 1.</span>
<span class="sd">        Set complemented to 1 to instruct CPLEX that the indicator</span>
<span class="sd">        constraint is active when indvar = 0.</span>

<span class="sd">        name : the name of the constraint.</span>

<span class="sd">        indtype : the type of indicator constraint. Defaults to</span>
<span class="sd">        CPX_INDICATOR_IF (&#39;-&gt;&#39;).  See `IndicatorType()`.</span>

<span class="sd">        Returns the index of the added indicator constraint.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.add(</span>
<span class="sd">        ...     indvar=&quot;x1&quot;,</span>
<span class="sd">        ...     complemented=0,</span>
<span class="sd">        ...     rhs=1.0,</span>
<span class="sd">        ...     sense=&quot;G&quot;,</span>
<span class="sd">        ...     lin_expr=cplex.SparsePair(ind=[&quot;x2&quot;], val=[2.0]),</span>
<span class="sd">        ...     name=&quot;ind1&quot;,</span>
<span class="sd">        ...     indtype=c.indicator_constraints.type_.if_)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lin_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lin_expr</span> <span class="o">=</span> <span class="n">SparsePair</span><span class="p">()</span>
        <span class="c1"># We only ever create one indicator constraint at a time.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_single</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">,</span>
                                <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">indvar</span><span class="p">,</span> <span class="n">complemented</span><span class="p">,</span>
                                <span class="n">name</span><span class="p">,</span> <span class="n">indtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes indicator constraints from the problem.</span>

<span class="sd">        There are four forms by which indicator_constraints.delete may be</span>
<span class="sd">        called.</span>

<span class="sd">        indicator_constraints.delete()</span>
<span class="sd">          deletes all indicator constraints from the problem.</span>

<span class="sd">        indicator_constraints.delete(i)</span>
<span class="sd">          i must be an indicator constraint name or index. Deletes</span>
<span class="sd">          the indicator constraint whose index or name is i.</span>

<span class="sd">        indicator_constraints.delete(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Deletes the indicator constraints with names or</span>
<span class="sd">          indices contained within s. Equivalent to</span>
<span class="sd">          [indicator_constraints.delete(i) for i in s].</span>

<span class="sd">        indicator_constraints.delete(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Deletes the indicator constraints with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          indicator_constraints.delete(range(begin, end + 1)). This will</span>
<span class="sd">          give the best performance when deleting batches of indicator</span>
<span class="sd">          constraints.</span>

<span class="sd">        See `CPXdelindconstrs &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/delindconstrs.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(name=str(i)) for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.delete(8)</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.delete(&quot;1&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.delete([2, &quot;0&quot;, 5])</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names()</span>
<span class="sd">        [&#39;4&#39;, &#39;6&#39;, &#39;7&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delindconstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_indicator_variables">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_indicator_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_indicator_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the indicator variables of a set of indicator constraints.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_indicator_variables()</span>
<span class="sd">          return the indicator variables of all indicator constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        indicator_constraints.get_indicator_variables(i)</span>
<span class="sd">          i must be an indicator constraint name or index.  Returns the</span>
<span class="sd">          indicator variables of the indicator constraint whose index</span>
<span class="sd">          or name is i.</span>

<span class="sd">        indicator_constraints.get_indicator_variables(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns the indicator variables of the indicator</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [indicator_constraints.get_indicator_variables(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_indicator_variables(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns the indicator variables of the</span>
<span class="sd">          indicator constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          indicator_constraints.get_indicator_variables(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)], types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(</span>
<span class="sd">        ...      name=str(i), indvar=i,</span>
<span class="sd">        ...      lin_expr=cplex.SparsePair(ind=[i+1], val=[1.0]))</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_indicator_variables(8)</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_indicator_variables(&quot;1&quot;,3)</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_indicator_variables([2,&quot;0&quot;,5])</span>
<span class="sd">        [2, 0, 5]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_indicator_variables()</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getindvar</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstr_constant</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getindvar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_complemented">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_complemented">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_complemented</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether a set of indicator constraints is complemented.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_complemented()</span>
<span class="sd">          return whether or not all indicator constraints from the</span>
<span class="sd">          problem are complemented.</span>

<span class="sd">        indicator_constraints.get_complemented(i)</span>
<span class="sd">          i must be an indicator constraint name or index.  Returns</span>
<span class="sd">          whether or not the indicator constraint whose index or name</span>
<span class="sd">          is i is complemented.</span>

<span class="sd">        indicator_constraints.get_complemented(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns whether or not the indicator constraints</span>
<span class="sd">          with indices the members of s are complemented.  Equivalent</span>
<span class="sd">          to [indicator_constraints.get_complemented(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_complemented(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns whether or not the indicator</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end, are complemented. Equivalent to</span>
<span class="sd">          indicator_constraints.get_complemented(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)], types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(</span>
<span class="sd">        ...      name=str(i), indvar=10,</span>
<span class="sd">        ...      complemented=i % 2)</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_complemented(8)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_complemented(&quot;1&quot;,3)</span>
<span class="sd">        [1, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_complemented([2,&quot;0&quot;,5])</span>
<span class="sd">        [0, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_complemented()</span>
<span class="sd">        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getcomp</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstr_constant</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getcomp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_num_nonzeros">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_num_nonzeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nonzeros in a set of indicator constraints.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_num_nonzeros()</span>
<span class="sd">          return the number of nonzeros in all indicator constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        indicator_constraints.get_num_nonzeros(i)</span>
<span class="sd">          i must be an indicator constraint name or index.  Returns the</span>
<span class="sd">          number of nonzeros in the indicator constraint whose index</span>
<span class="sd">          or name is i.</span>

<span class="sd">        indicator_constraints.get_num_nonzeros(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns the number of nonzeros in the indicator</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [indicator_constraints.get_num_nonzeros(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_num_nonzeros(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns the number of nonzeros in the</span>
<span class="sd">          indicator constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          indicator_constraints.get_num_nonzeros(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)], types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(</span>
<span class="sd">        ...      name=str(i), indvar=10,</span>
<span class="sd">        ...      lin_expr=[range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num_nonzeros(8)</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num_nonzeros(&quot;1&quot;,3)</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num_nonzeros([2,&quot;0&quot;,5])</span>
<span class="sd">        [2, 0, 5]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num_nonzeros()</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getnnz</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="c1"># NB: We return surplus here for nzcnt (this is on purpose).</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstr_constant</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getnnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_rhs">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the righthand side of a set of indicator constraints.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_rhs()</span>
<span class="sd">          return the righthand side of all indicator constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        indicator_constraints.get_rhs(i)</span>
<span class="sd">          i must be an indicator constraint name or index.  Returns the</span>
<span class="sd">          righthand side of the indicator constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        indicator_constraints.get_rhs(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns the righthand side of the indicator</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [indicator_constraints.get_rhs(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_rhs(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns the righthand side of the indicator</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          indicator_constraints.get_rhs(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(rhs=1.5 * i, name=str(i)) for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_rhs(8)</span>
<span class="sd">        12.0</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_rhs(&quot;1&quot;,3)</span>
<span class="sd">        [1.5, 3.0, 4.5]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_rhs([2,&quot;0&quot;,5])</span>
<span class="sd">        [3.0, 0.0, 7.5]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_rhs()</span>
<span class="sd">        [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getrhs</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstr_constant</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getrhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_senses">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_senses">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_senses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sense of a set of indicator constraints.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_senses()</span>
<span class="sd">          return the senses of all indicator constraints from the</span>
<span class="sd">          problem.</span>

<span class="sd">        indicator_constraints.get_senses(i)</span>
<span class="sd">          i must be an indicator constraint name or index.  Returns the</span>
<span class="sd">          sense of the indicator constraint whose index or name is i.</span>

<span class="sd">        indicator_constraints.get_senses(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns the senses of the indicator constraints</span>
<span class="sd">          with indices the members of s.  Equivalent to</span>
<span class="sd">          [indicator_constraints.get_senses(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_senses(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns the senses of the indicator</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          indicator_constraints.get_senses(range(begin, end + 1)).</span>


<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(name=str(i), sense=j)</span>
<span class="sd">        ...  for i, j in enumerate(&quot;EGLE&quot;)]</span>
<span class="sd">        [0, 1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_senses(1)</span>
<span class="sd">        &#39;G&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_senses(&quot;1&quot;,3)</span>
<span class="sd">        [&#39;G&#39;, &#39;L&#39;, &#39;E&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_senses([2,&quot;0&quot;,1])</span>
<span class="sd">        [&#39;L&#39;, &#39;E&#39;, &#39;G&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_senses()</span>
<span class="sd">        [&#39;E&#39;, &#39;G&#39;, &#39;L&#39;, &#39;E&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getsense</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstr_constant</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getsense</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">s</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_types">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the type of a set of indicator constraints.</span>

<span class="sd">        See `IndicatorType()`.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_types()</span>
<span class="sd">          return the types of all indicator constraints from the</span>
<span class="sd">          problem.</span>

<span class="sd">        indicator_constraints.get_types(i)</span>
<span class="sd">          i must be an indicator constraint name or index.  Returns the</span>
<span class="sd">          type of the indicator constraint whose index or name is i.</span>

<span class="sd">        indicator_constraints.get_types(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns the types of the indicator constraints</span>
<span class="sd">          with indices the members of s.  Equivalent to</span>
<span class="sd">          [indicator_constraints.get_types(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_types(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns the types of the indicator</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          indicator_constraints.get_types(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; idx = c.indicator_constraints.add(name=&#39;i1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_types(idx)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.type_[1]</span>
<span class="sd">        &#39;if_&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">gettype</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstr_constant</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">gettype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_linear_components">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_linear_components">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the linear constraint of a set of indicator</span>
<span class="sd">        constraints.</span>

<span class="sd">        Returns a list of SparsePair instances or a single SparsePair</span>
<span class="sd">        instance, depending on the form by which it was called.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_linear_components()</span>
<span class="sd">          return the linear components of all indicator constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        indicator_constraints.get_linear_components(i)</span>
<span class="sd">          i must be an indicator constraint name or index.  Returns the</span>
<span class="sd">          linear component of the indicator constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        indicator_constraints.get_linear_components(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns the linear components of the indicator</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [indicator_constraints.get_linear_components(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_linear_components(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns the linear components of the</span>
<span class="sd">          indicator constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          indicator_constraints.get_linear_components(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names=[str(i) for i in range(4)],</span>
<span class="sd">        ...     types=&quot;B&quot; * 4</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(</span>
<span class="sd">        ...      name=str(i), indvar=3,</span>
<span class="sd">        ...      lin_expr=[range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(3)]</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_linear_components(2)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.indicator_constraints.get_linear_components(&quot;0&quot;, 1):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.indicator_constraints.get_linear_components([1, &quot;0&quot;]):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.indicator_constraints.get_linear_components():</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getlin</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">()</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matbeg</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">matind</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">matval</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstr</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getlin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorConstraintInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.IndicatorConstraintInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of a set of indicator constraints.</span>

<span class="sd">        May be called by four forms.</span>

<span class="sd">        indicator_constraints.get_names()</span>
<span class="sd">          return the names of all indicator constraints from the</span>
<span class="sd">          problem.</span>

<span class="sd">        indicator_constraints.get_names(i)</span>
<span class="sd">          i must be an indicator constraint index.  Returns the name</span>
<span class="sd">          of constraint i.</span>

<span class="sd">        indicator_constraints.get_names(s)</span>
<span class="sd">          s must be a sequence of indicator constraint indices.</span>
<span class="sd">          Returns the names of the indicator constraints with indices</span>
<span class="sd">          the members of s.  Equivalent to</span>
<span class="sd">          [indicator_constraints.get_names(i) for i in s]</span>

<span class="sd">        indicator_constraints.get_names(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices. Returns the</span>
<span class="sd">          names of the indicator constraints with indices between begin</span>
<span class="sd">          and end, inclusive of end. Equivalent to</span>
<span class="sd">          indicator_constraints.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; [c.indicator_constraints.add(name=&quot;i&quot; + str(i))</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names(8)</span>
<span class="sd">        &#39;i8&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names(1, 3)</span>
<span class="sd">        [&#39;i1&#39;, &#39;i2&#39;, &#39;i3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names([2, 0, 5])</span>
<span class="sd">        [&#39;i2&#39;, &#39;i0&#39;, &#39;i5&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.indicator_constraints.get_names()</span>
<span class="sd">        [&#39;i0&#39;, &#39;i1&#39;, &#39;i2&#39;, &#39;i3&#39;, &#39;i4&#39;, &#39;i5&#39;, &#39;i6&#39;, &#39;i7&#39;, &#39;i8&#39;, &#39;i9&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstrname</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="QuadraticConstraintInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QuadraticConstraintInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for adding, modifying, and querying quadratic constraints.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuadraticConstraintInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new QuadraticConstraintInterface.</span>

<span class="sd">        The quadratic constraints interface is exposed by the top-level</span>
<span class="sd">        `Cplex` class as `Cplex.quadratic_constraints`.  This constructor</span>
<span class="sd">        is not meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">cplex</span><span class="p">,</span> <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstrindex</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of quadratic constraints.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l = cplex.SparsePair(ind = [&#39;x&#39;], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; q = cplex.SparseTriple(ind1 = [&#39;x&#39;], ind2 = [&#39;y&#39;], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(name=str(i), lin_expr=l, quad_expr=q)</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumqconstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">,</span> <span class="n">quad_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">lin_expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">,</span> <span class="n">qval</span> <span class="o">=</span> <span class="n">unpack_triple</span><span class="p">(</span><span class="n">quad_expr</span><span class="p">)</span>
        <span class="n">varcache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addqconstr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">varcache</span><span class="p">),</span>
                            <span class="n">val</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">varcache</span><span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">ind2</span><span class="p">,</span> <span class="n">varcache</span><span class="p">),</span>
                            <span class="n">qval</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="QuadraticConstraintInterface.add">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quad_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a quadratic constraint to the problem.</span>

<span class="sd">        Takes up to five keyword arguments:</span>

<span class="sd">        lin_expr : either a SparsePair or a list of two lists specifying</span>
<span class="sd">        the linear component of the constraint.</span>

<span class="sd">        Note</span>
<span class="sd">          lin_expr must not contain duplicate indices.  If lin_expr</span>
<span class="sd">          references a variable more than once, either by index, name,</span>
<span class="sd">          or a combination of index and name, an exception will be</span>
<span class="sd">          raised.</span>

<span class="sd">        quad_expr : either a SparseTriple or a list of three lists</span>
<span class="sd">        specifying the quadratic component of the constraint.</span>

<span class="sd">        Note</span>
<span class="sd">          quad_expr must not contain duplicate indices.  If quad_expr</span>
<span class="sd">          references a matrix entry more than once, either by indices,</span>
<span class="sd">          names, or a combination of indices and names, an exception</span>
<span class="sd">          will be raised.</span>

<span class="sd">        sense : either &quot;L&quot;, &quot;G&quot;, or &quot;E&quot;</span>

<span class="sd">        rhs : a float specifying the righthand side of the constraint.</span>

<span class="sd">        name : the name of the constraint.</span>

<span class="sd">        Returns the index of the added quadratic constraint.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l = cplex.SparsePair(ind = [&#39;x&#39;], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; q = cplex.SparseTriple(ind1 = [&#39;x&#39;], ind2 = [&#39;y&#39;], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.add(name = &quot;my_quad&quot;,</span>
<span class="sd">        ...                             lin_expr = l,</span>
<span class="sd">        ...                             quad_expr = q,</span>
<span class="sd">        ...                             rhs = 1.0,</span>
<span class="sd">        ...                             sense = &quot;G&quot;)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lin_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lin_expr</span> <span class="o">=</span> <span class="n">SparsePair</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">quad_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">quad_expr</span> <span class="o">=</span> <span class="n">SparseTriple</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">])</span>
        <span class="c1"># We only ever create one quadratic constraint at a time.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_single</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">,</span>
                                <span class="n">lin_expr</span><span class="p">,</span> <span class="n">quad_expr</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes quadratic constraints from the problem.</span>

<span class="sd">        There are four forms by which quadratic_constraints.delete may be</span>
<span class="sd">        called.</span>

<span class="sd">        quadratic_constraints.delete()</span>
<span class="sd">          deletes all quadratic constraints from the problem.</span>

<span class="sd">        quadratic_constraints.delete(i)</span>
<span class="sd">          i must be a quadratic constraint name or index. Deletes</span>
<span class="sd">          the quadratic constraint whose index or name is i.</span>

<span class="sd">        quadratic_constraints.delete(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices. Deletes the quadratic constraints with names or</span>
<span class="sd">          indices contained within s. Equivalent to</span>
<span class="sd">          [quadratic_constraints.delete(i) for i in s].</span>

<span class="sd">        quadratic_constraints.delete(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Deletes the quadratic constraints with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          quadratic_constraints.delete(range(begin, end + 1)). This will</span>
<span class="sd">          give the best performance when deleting batches of quadratic</span>
<span class="sd">          constraints.</span>

<span class="sd">        See `CPXdelqconstrs &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/socpapi/delqconstrs.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l = cplex.SparsePair(ind=[&#39;x&#39;], val=[1.0])</span>
<span class="sd">        &gt;&gt;&gt; q = cplex.SparseTriple(ind1=[&#39;x&#39;], ind2=[&#39;y&#39;], val=[1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(</span>
<span class="sd">        ...      name=str(i), lin_expr=l, quad_expr=q)</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.delete(8)</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.delete(&quot;1&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.delete([2, &quot;0&quot;, 5])</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names()</span>
<span class="sd">        [&#39;4&#39;, &#39;6&#39;, &#39;7&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delqconstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_rhs">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the righthand side of a set of quadratic constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        quadratic_constraints.get_rhs()</span>
<span class="sd">          return the righthand side of all quadratic constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        quadratic_constraints.get_rhs(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns the</span>
<span class="sd">          righthand side of the quadratic constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        quadratic_constraints.get_rhs(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the righthand side of the quadratic</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [quadratic_constraints.get_rhs(i) for i in s]</span>

<span class="sd">        quadratic_constraints.get_rhs(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the righthand side of the quadratic</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          quadratic_constraints.get_rhs(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(rhs=1.5 * i, name=str(i))</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_rhs(8)</span>
<span class="sd">        12.0</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_rhs(&quot;1&quot;,3)</span>
<span class="sd">        [1.5, 3.0, 4.5]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_rhs([2,&quot;0&quot;,5])</span>
<span class="sd">        [3.0, 0.0, 7.5]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_rhs()</span>
<span class="sd">        [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getrhs</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstr_info</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getrhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_senses">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_senses">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_senses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the senses of a set of quadratic constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        quadratic_constraints.get_senses()</span>
<span class="sd">          return the senses of all quadratic constraints from the</span>
<span class="sd">          problem.</span>

<span class="sd">        quadratic_constraints.get_senses(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns the</span>
<span class="sd">          sense of the quadratic constraint whose index or name is i.</span>

<span class="sd">        quadratic_constraints.get_senses(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the senses of the quadratic constraints</span>
<span class="sd">          with indices the members of s.  Equivalent to</span>
<span class="sd">          [quadratic_constraints.get_senses(i) for i in s]</span>

<span class="sd">        quadratic_constraints.get_senses(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the senses of the quadratic</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          quadratic_constraints.get_senses(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;])</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(name=str(i), sense=j)</span>
<span class="sd">        ...  for i, j in enumerate(&quot;GGLL&quot;)]</span>
<span class="sd">        [0, 1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_senses(1)</span>
<span class="sd">        &#39;G&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_senses(&quot;1&quot;,3)</span>
<span class="sd">        [&#39;G&#39;, &#39;L&#39;, &#39;L&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_senses([2,&quot;0&quot;,1])</span>
<span class="sd">        [&#39;L&#39;, &#39;G&#39;, &#39;G&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_senses()</span>
<span class="sd">        [&#39;G&#39;, &#39;G&#39;, &#39;L&#39;, &#39;L&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getsense</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstr_info</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getsense</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_linear_num_nonzeros">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_linear_num_nonzeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_num_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nonzeros in the linear part of a set of quadratic constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        quadratic_constraints.get_linear_num_nonzeros()</span>
<span class="sd">          return the number of nonzeros in all quadratic constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        quadratic_constraints.get_linear_num_nonzeros(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns the</span>
<span class="sd">          number of nonzeros in the quadratic constraint whose index</span>
<span class="sd">          or name is i.</span>

<span class="sd">        quadratic_constraints.get_linear_num_nonzeros(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the number of nonzeros in the quadratic</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [quadratic_constraints.get_linear_num_nonzeros(i) for i in s]</span>

<span class="sd">        quadratic_constraints.get_linear_num_nonzeros(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the number of nonzeros in the</span>
<span class="sd">          quadratic constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          quadratic_constraints.get_linear_num_nonzeros(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)], types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(</span>
<span class="sd">        ...      name = str(i),</span>
<span class="sd">        ...      lin_expr = [range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_linear_num_nonzeros(8)</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_linear_num_nonzeros(&quot;1&quot;,3)</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_linear_num_nonzeros([2,&quot;0&quot;,5])</span>
<span class="sd">        [2, 0, 5]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_linear_num_nonzeros()</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getlinnz</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstr_info</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getlinnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_linear_components">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_linear_components">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the linear part of a set of quadratic constraints.</span>

<span class="sd">        Returns a list of SparsePair instances or one SparsePair</span>
<span class="sd">        instance.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        quadratic_constraints.get_linear_components()</span>
<span class="sd">          return the linear components of all quadratic constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        quadratic_constraints.get_linear_components(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns the</span>
<span class="sd">          linear component of the quadratic constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        quadratic_constraints.get_linear_components(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the linear components of the quadratic</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [quadratic_constraints.get_linear_components(i) for i in s]</span>

<span class="sd">        quadratic_constraints.get_linear_components(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the linear components of the</span>
<span class="sd">          quadratic constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          quadratic_constraints.get_linear_components(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names=[str(i) for i in range(4)],</span>
<span class="sd">        ...     types=&quot;B&quot; * 4</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(</span>
<span class="sd">        ...      name=str(i),</span>
<span class="sd">        ...      lin_expr=[range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(3)]</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_linear_components(2)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.quadratic_constraints.get_linear_components(&quot;0&quot;, 1):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.quadratic_constraints.get_linear_components([1, &quot;0&quot;]):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        &gt;&gt;&gt; for row in c.quadratic_constraints.get_linear_components():</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getlin</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SparsePair</span><span class="p">(</span><span class="o">*</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstr_lin</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getlin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_quad_num_nonzeros">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_quad_num_nonzeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quad_num_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nonzeros in the quadratic part of a set of quadratic constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        quadratic_constraints.get_quad_num_nonzeros()</span>
<span class="sd">          Returns the number of nonzeros in all quadratic constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        quadratic_constraints.get_quad_num_nonzeros(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns the</span>
<span class="sd">          number of nonzeros in the quadratic constraint whose index</span>
<span class="sd">          or name is i.</span>

<span class="sd">        quadratic_constraints.get_quad_num_nonzeros(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the number of nonzeros in the quadratic</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [quadratic_constraints.get_quad_num_nonzeros(i) for i in s]</span>

<span class="sd">        quadratic_constraints.get_quad_num_nonzeros(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the number of nonzeros in the</span>
<span class="sd">          quadratic constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          quadratic_constraints.get_quad_num_nonzeros(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)])</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(</span>
<span class="sd">        ...      name = str(i),</span>
<span class="sd">        ...      quad_expr = [range(i), range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(1, 11)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_quad_num_nonzeros(8)</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_quad_num_nonzeros(&quot;1&quot;,2)</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_quad_num_nonzeros([2,&quot;1&quot;,5])</span>
<span class="sd">        [3, 1, 6]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_quad_num_nonzeros()</span>
<span class="sd">        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getquadnz</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstr_info</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getquadnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_quadratic_components">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_quadratic_components">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the quadratic part of a set of quadratic constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        quadratic_constraints.get_quadratic_components()</span>
<span class="sd">          return the quadratic components of all quadratic constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        quadratic_constraints.get_quadratic_components(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns the</span>
<span class="sd">          quadratic component of the quadratic constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        quadratic_constraints.get_quadratic_components(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the quadratic components of the quadratic</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [quadratic_constraints.get_quadratic_components(i) for i in s]</span>

<span class="sd">        quadratic_constraints.get_quadratic_components(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the quadratic components of the</span>
<span class="sd">          quadratic constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          quadratic_constraints.get_quadratic_components(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names=[str(i) for i in range(4)]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(</span>
<span class="sd">        ...      name=&quot;q{0}&quot;.format(i),</span>
<span class="sd">        ...      quad_expr=[range(i), range(i),</span>
<span class="sd">        ...                 [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(1, 3)]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_quadratic_components(1)</span>
<span class="sd">        SparseTriple(ind1 = [0, 1], ind2 = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; for quad in c.quadratic_constraints.get_quadratic_components(&quot;q1&quot;, 1):</span>
<span class="sd">        ...     print(quad)</span>
<span class="sd">        SparseTriple(ind1 = [0], ind2 = [0], val = [1.0])</span>
<span class="sd">        SparseTriple(ind1 = [0, 1], ind2 = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; for quad in c.quadratic_constraints.get_quadratic_components([&quot;q2&quot;, 0]):</span>
<span class="sd">        ...     print(quad)</span>
<span class="sd">        SparseTriple(ind1 = [0, 1], ind2 = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        SparseTriple(ind1 = [0], ind2 = [0], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; for quad in c.quadratic_constraints.get_quadratic_components():</span>
<span class="sd">        ...     print(quad)</span>
<span class="sd">        SparseTriple(ind1 = [0], ind2 = [0], val = [1.0])</span>
<span class="sd">        SparseTriple(ind1 = [0, 1], ind2 = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getquad</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SparseTriple</span><span class="p">(</span><span class="o">*</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstr_quad</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getquad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticConstraintInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QuadraticConstraintInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of a set of quadratic constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        quadratic_constraints.get_names()</span>
<span class="sd">          return the names of all quadratic constraints from the</span>
<span class="sd">          problem.</span>

<span class="sd">        quadratic_constraints.get_names(i)</span>
<span class="sd">          i must be a quadratic constraint index.  Returns the name</span>
<span class="sd">          of constraint i.</span>

<span class="sd">        quadratic_constraints.get_names(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint indices.</span>
<span class="sd">          Returns the names of the quadratic constraints with indices</span>
<span class="sd">          the members of s.  Equivalent to</span>
<span class="sd">          [quadratic_constraints.get_names(i) for i in s]</span>

<span class="sd">        quadratic_constraints.get_names(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices. Returns</span>
<span class="sd">          the names of the quadratic constraints with indices between</span>
<span class="sd">          begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          quadratic_constraints.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)])</span>
<span class="sd">        &gt;&gt;&gt; [c.quadratic_constraints.add(</span>
<span class="sd">        ...      name = &quot;q&quot; + str(i),</span>
<span class="sd">        ...      quad_expr = [range(i), range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(1, 11)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names(8)</span>
<span class="sd">        &#39;q9&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names(1, 3)</span>
<span class="sd">        [&#39;q2&#39;, &#39;q3&#39;, &#39;q4&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names([2, 0, 5])</span>
<span class="sd">        [&#39;q3&#39;, &#39;q1&#39;, &#39;q6&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.quadratic_constraints.get_names()</span>
<span class="sd">        [&#39;q1&#39;, &#39;q2&#39;, &#39;q3&#39;, &#39;q4&#39;, &#39;q5&#39;, &#39;q6&#39;, &#39;q7&#39;, &#39;q8&#39;, &#39;q9&#39;, &#39;q10&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstrname</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SOSType">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SOSType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants defining the type of special ordered sets.</span>

<span class="sd">    For a definition of SOS type 1 and 2, see those topics in the CPLEX</span>
<span class="sd">    User&#39;s Manual.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SOS1</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_TYPE_SOS1</span>
    <span class="n">SOS2</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_TYPE_SOS2</span></div>



<div class="viewcode-block" id="SOSInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SOSInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class containing methods for Special Ordered Sets (SOS).&quot;&quot;&quot;</span>

    <span class="nb">type</span> <span class="o">=</span> <span class="n">SOSType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `SOSType()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SOSInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new SOSInterface.</span>

<span class="sd">        The SOS interface is exposed by the top-level `Cplex` class as</span>
<span class="sd">        `Cplex.SOS`.  This constructor is not meant to be used</span>
<span class="sd">        externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">cplex</span><span class="p">,</span> <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsosindex</span><span class="p">)</span></div>


<div class="viewcode-block" id="SOSInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of special ordered sets.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumsos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


    <span class="c1"># FIXME: &#39;type&#39; and &#39;SOS&#39; are bad variable names.  type is a &quot;reserved&quot;</span>
    <span class="c1">#        word and SOS should be lowercased.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">SOS</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">SOS</span><span class="p">)</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addsos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                        <span class="n">weights</span><span class="p">,</span> <span class="p">[</span><span class="n">name</span><span class="p">])</span>

<div class="viewcode-block" id="SOSInterface.add">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="n">SOS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a special ordered set constraint to the problem.</span>

<span class="sd">        Takes three keyword arguments.</span>

<span class="sd">        type : can be either SOS.type.SOS1 or SOS.type.SOS2</span>

<span class="sd">        SOS : either a SparsePair or a list of two lists, the first of</span>
<span class="sd">        which contains variable indices or names, the second of which</span>
<span class="sd">        contains the weights to assign to those variables.</span>

<span class="sd">        name: the name of the SOS</span>

<span class="sd">        Returns the index of the added SOS constraint.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.add(type = &quot;1&quot;, name = &quot;type_one&quot;,</span>
<span class="sd">        ...           SOS = cplex.SparsePair(ind = [&quot;2&quot;, &quot;3&quot;],</span>
<span class="sd">        ...                                  val = [25.0, 18.0]))</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.add(type = &quot;2&quot;, name = &quot;type_two&quot;,</span>
<span class="sd">        ...           SOS = cplex.SparsePair(ind = [&quot;2&quot;, &quot;4&quot;, &quot;7&quot;, &quot;3&quot;],</span>
<span class="sd">        ...                                  val = [1.0, 3.0, 25.0, 18.0]))</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">SOS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">SOS</span> <span class="o">=</span> <span class="n">SparsePair</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">])</span>
        <span class="c1"># We only ever create one sos constraint at a time.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_single</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">,</span> <span class="n">SOS</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="SOSInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes special ordered sets from the problem.</span>

<span class="sd">        There are four forms by which SOS.delete may be called.</span>

<span class="sd">        SOS.delete()</span>
<span class="sd">          deletes all SOS constraints from the problem.</span>

<span class="sd">        SOS.delete(i)</span>
<span class="sd">          i must be a SOS constraint name or index. Deletes the SOS</span>
<span class="sd">          constraint indexed as i or named i.</span>

<span class="sd">        SOS.delete(s)</span>
<span class="sd">          s must be a sequence of SOS constraint names or indices.</span>
<span class="sd">          Deletes the SOS constraints with names or indices contained</span>
<span class="sd">          within s. Equivalent to [SOS.delete(i) for i in s].</span>

<span class="sd">        SOS.delete(begin, end)</span>
<span class="sd">          begin and end must be SOS constraint indices or SOS constraint</span>
<span class="sd">          names. Deletes the SOS constraints with indices between begin</span>
<span class="sd">          and end, inclusive of end. Equivalent to</span>
<span class="sd">          SOS.delete(range(begin, end + 1)). This will give the best</span>
<span class="sd">          performance when deleting batches of SOS constraints.</span>

<span class="sd">        See `CPXdelsos &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/delsos.html&gt;`_ in the Callable Library Reference Manual</span>
<span class="sd">        for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; l = cplex.SparsePair(ind=[&#39;x&#39;], val=[1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.SOS.add(name=str(i), SOS=l) for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.delete(8)</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.delete(&quot;1&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.delete([2, &quot;0&quot;, 5])</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names()</span>
<span class="sd">        [&#39;4&#39;, &#39;6&#39;, &#39;7&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delsos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SOSInterface.get_sets">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.get_sets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sets of variables and their corresponding weights.</span>

<span class="sd">        Returns a SparsePair instance or a list of SparsePair instances.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        SOS.get_sets()</span>
<span class="sd">          return the set of variables and weights of all SOS</span>
<span class="sd">          constraints from the problem.</span>

<span class="sd">        SOS.get_sets(i)</span>
<span class="sd">          i must be a SOS constraint name or index.  Returns the set</span>
<span class="sd">          of variables and weights of the SOS constraint whose index</span>
<span class="sd">          or name is i.</span>

<span class="sd">        SOS.get_sets(s)</span>
<span class="sd">          s must be a sequence of SOS constraint names or indices.</span>
<span class="sd">          Returns the variables and weights of the SOS constraints</span>
<span class="sd">          with indices the members of s.  Equivalent to</span>
<span class="sd">          [SOS.get_sets(i) for i in s]</span>

<span class="sd">        SOS.get_sets(begin, end)</span>
<span class="sd">          begin and end must be SOS constraint indices or SOS constraint</span>
<span class="sd">          names. Returns the variables and weights of the SOS constraints</span>
<span class="sd">          with indices between begin and end, inclusive of end.</span>
<span class="sd">          Equivalent to SOS.get_sets(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names=[str(i) for i in range(4)],</span>
<span class="sd">        ...     types=&quot;B&quot; * 4</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; [c.SOS.add(</span>
<span class="sd">        ...      name=&quot;s{0}&quot;.format(i),</span>
<span class="sd">        ...      SOS=[range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(1, 3)]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_sets(1)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; for s in c.SOS.get_sets(&quot;s1&quot;, 1):</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; for s in c.SOS.get_sets([&quot;s2&quot;, 0]):</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; for s in c.SOS.get_sets():</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getsos</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">()</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matbeg</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matind</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matval</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getsos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SOSInterface.get_types">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.get_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the type of a set of special ordered sets.</span>

<span class="sd">        Return values are attributes of Cplex.SOS.type.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        SOS.get_types()</span>
<span class="sd">          return the type of all SOS constraints.</span>

<span class="sd">        SOS.get_types(i)</span>
<span class="sd">          i must be a SOS constraint name or index.  Returns the type</span>
<span class="sd">          of the SOS constraint whose index or name is i.</span>

<span class="sd">        SOS.get_types(s)</span>
<span class="sd">          s must be a sequence of SOS constraint names or indices.</span>
<span class="sd">          Returns the type of the SOS constraints with indices the</span>
<span class="sd">          members of s.  Equivalent to [SOS.get_types(i) for i in s]</span>

<span class="sd">        SOS.get_types(begin, end)</span>
<span class="sd">          begin and end must be SOS constraint indices or SOS constraint</span>
<span class="sd">          names. Returns the type of the SOS constraints with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          SOS.get_types(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)], types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; [c.SOS.add(name = str(i), type = str(i % 2 + 1))</span>
<span class="sd">        ...  for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_types(8)</span>
<span class="sd">        &#39;1&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_types(&quot;1&quot;,3)</span>
<span class="sd">        [&#39;2&#39;, &#39;1&#39;, &#39;2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_types([2,&quot;0&quot;,5])</span>
<span class="sd">        [&#39;1&#39;, &#39;1&#39;, &#39;2&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_types()</span>
<span class="sd">        [&#39;1&#39;, &#39;2&#39;, &#39;1&#39;, &#39;2&#39;, &#39;1&#39;, &#39;2&#39;, &#39;1&#39;, &#39;2&#39;, &#39;1&#39;, &#39;2&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">gettype</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsos_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">gettype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span></div>


<div class="viewcode-block" id="SOSInterface.get_num_members">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.get_num_members">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the size of a set of special ordered sets.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        SOS.get_num_members()</span>
<span class="sd">          return the number of variables in all SOS constraints from</span>
<span class="sd">          the problem.</span>

<span class="sd">        SOS.get_num_members(i)</span>
<span class="sd">          i must be a SOS constraint name or index.  Returns the</span>
<span class="sd">          number of variables in the SOS constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        SOS.get_num_members(s)</span>
<span class="sd">          s must be a sequence of SOS constraint names or indices.</span>
<span class="sd">          Returns the number of variables in the SOS constraints with</span>
<span class="sd">          indices the members of s.  Equivalent to</span>
<span class="sd">          [SOS.get_num_members(i) for i in s]</span>

<span class="sd">        SOS.get_num_members(begin, end)</span>
<span class="sd">          begin and end must be SOS constraint indices or SOS constraint</span>
<span class="sd">          names. Returns the number of variables in the SOS constraints</span>
<span class="sd">          with indices between begin and end, inclusive of end.</span>
<span class="sd">          Equivalent to SOS.get_num_members(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)], types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; [c.SOS.add(name = str(i),</span>
<span class="sd">        ...            SOS = [range(i), [1.0 * (j+1.0) for j in range(i)]])</span>
<span class="sd">        ...  for i in range(1,11)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num_members(7)</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num_members(&quot;1&quot;,2)</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num_members([3,&quot;1&quot;,4])</span>
<span class="sd">        [4, 1, 5]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num_members()</span>
<span class="sd">        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getsize</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsos_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SOSInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SOSInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of a set of special ordered sets.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        SOS.get_names()</span>
<span class="sd">          return the names of all SOS constraints from the problem.</span>

<span class="sd">        SOS.get_names(i)</span>
<span class="sd">          i must be an SOS constraint index.  Returns the name of</span>
<span class="sd">          SOS constraint i.</span>

<span class="sd">        SOS.get_names(s)</span>
<span class="sd">          s must be a sequence of SOS constraint indices.  Returns</span>
<span class="sd">          the names of the SOS constraints with indices the members</span>
<span class="sd">          of s.  Equivalent to [SOS.get_names(i) for i in s]</span>

<span class="sd">        SOS.get_names(begin, end)</span>
<span class="sd">          begin and end must be SOS constraint indices. Returns the names</span>
<span class="sd">          of the SOS constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          SOS.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&quot;x0&quot;])</span>
<span class="sd">        &gt;&gt;&gt; [c.SOS.add(name = &quot;sos&quot; + str(i)) for i in range(1, 11)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names(8)</span>
<span class="sd">        &#39;sos9&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names(1, 3)</span>
<span class="sd">        [&#39;sos2&#39;, &#39;sos3&#39;, &#39;sos4&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names([2, 0, 5])</span>
<span class="sd">        [&#39;sos3&#39;, &#39;sos1&#39;, &#39;sos6&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.SOS.get_names()</span>
<span class="sd">        [&#39;sos1&#39;, &#39;sos2&#39;, &#39;sos3&#39;, &#39;sos4&#39;, &#39;sos5&#39;, &#39;sos6&#39;, &#39;sos7&#39;, &#39;sos8&#39;, &#39;sos9&#39;, &#39;sos10&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsosname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="EffortLevel">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.EffortLevel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EffortLevel</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Effort levels associated with a MIP start&quot;&quot;&quot;</span>
    <span class="n">auto</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MIPSTART_AUTO</span>
    <span class="n">check_feasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MIPSTART_CHECKFEAS</span>
    <span class="n">solve_fixed</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MIPSTART_SOLVEFIXED</span>
    <span class="n">solve_MIP</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MIPSTART_SOLVEMIP</span>
    <span class="n">repair</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MIPSTART_REPAIR</span>
    <span class="n">no_check</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MIPSTART_NOCHECK</span></div>



<div class="viewcode-block" id="MIPStartsInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MIPStartsInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Contains methods pertaining to MIP starts.&quot;&quot;&quot;</span>

    <span class="n">effort_level</span> <span class="o">=</span> <span class="n">EffortLevel</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `EffortLevel()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MIPStartsInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new MIPStartsInterface.</span>

<span class="sd">        The MIP starts interface is exposed by the top-level `Cplex`</span>
<span class="sd">        class as `Cplex.MIP_starts`.  This constructor is not meant to be</span>
<span class="sd">        used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">cplex</span><span class="p">,</span>
                         <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmipstartindex</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of MIP starts currently stored.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names = [str(i) for i in range(11)],</span>
<span class="sd">        ...     types = &quot;I&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind = [i], val = [0.0]),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto) for i in range(5)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num()</span>
<span class="sd">        5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnummipstarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.read">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads MIP starts from a file.</span>

<span class="sd">        This method reads a file in the format MST and copies the</span>
<span class="sd">        information of all the MIP starts contained in that file into a</span>
<span class="sd">        CPLEX problem object.  The parameter cplex.parameters.advance</span>
<span class="sd">        must be set to cplex.parameters.advance.values.standard, its</span>
<span class="sd">        default value, or cplex.parameters.advance.values.alternate</span>
<span class="sd">        in order for the MIP starts to be used.</span>

<span class="sd">        Note</span>
<span class="sd">          If the MIP start file is successfully read, then any</span>
<span class="sd">          previously existing MIP starts will be deleted.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.write(&quot;test_all.mst&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.read(&quot;test_all.mst&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">readcopymipstarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">begin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes a set of MIP starts to a file.</span>

<span class="sd">        If called with only a filename, writes all MIP starts to that</span>
<span class="sd">        file.</span>

<span class="sd">        If called with a filename and one index or name of a MIP</span>
<span class="sd">        start, writes only that MIP start to the file.</span>

<span class="sd">        If called with a filename and two indices or names of MIP</span>
<span class="sd">        starts, writes all MIP starts between the first and second</span>
<span class="sd">        index or name, inclusive of begin and end, to the file.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names = [str(i) for i in range(11)], types = &quot;I&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind = [i], val = [0.0]),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto) for i in range(5)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.write(&quot;test_all.mst&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.write(&quot;test_one.mst&quot;, 1)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.write(&quot;test_four.mst&quot;, 1, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">begin</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">begin</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">writemipstarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span>
                                <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addmipstarts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span>
                <span class="n">val</span><span class="p">,</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">name</span><span class="p">])</span>

<div class="viewcode-block" id="MIPStartsInterface.add">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds MIP starts to the problem.</span>

<span class="sd">        To add a single MIP start, call this method as</span>

<span class="sd">        cpx.MIP_starts.add(start, effort_level, name)</span>

<span class="sd">        The first argument, start, must be either a SparsePair</span>
<span class="sd">        instance or a list of two lists, the first of which contains</span>
<span class="sd">        variable indices or names, the second of which contains the</span>
<span class="sd">        values that those variables take.</span>

<span class="sd">        The second argument, effort_level, must be an attribute of</span>
<span class="sd">        MIP_starts.effort_level.</span>

<span class="sd">        The third optional argument is the name of the MIP start.</span>

<span class="sd">        To add a set of MIP starts, call this method as</span>

<span class="sd">        cpx.MIP_starts.add(sequence)</span>

<span class="sd">        where sequence is a list or tuple of pairs (start,</span>
<span class="sd">        effort_level) or triples (start, effort_level, name) as</span>
<span class="sd">        described above.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(11)],</span>
<span class="sd">        ...                           types = &quot;I&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     cplex.SparsePair(ind = [0], val = [0.0]),</span>
<span class="sd">        ...     c.MIP_starts.effort_level.repair, &quot;first&quot;)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     cplex.SparsePair(ind = [1], val = [0.0]),</span>
<span class="sd">        ...     c.MIP_starts.effort_level.solve_MIP)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [([[2, 4], [0.0, 1.0]],</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto, &quot;third&quot;),</span>
<span class="sd">        ...      ([[3, 4], [1.0, 3.0]],</span>
<span class="sd">        ...       c.MIP_starts.effort_level.check_feasibility)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names()</span>
<span class="sd">        [&#39;first&#39;, &#39;m2&#39;, &#39;third&#39;, &#39;m4&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.change">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.change">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes a MIP start or set of MIP starts.</span>

<span class="sd">        To change a single MIP start, call this method as</span>

<span class="sd">        cpx.MIP_starts.change(ID, start, effort_level)</span>

<span class="sd">        The first argument, ID, must be an index or name of an</span>
<span class="sd">        existing MIP start.</span>

<span class="sd">        The second argument, start, must be either a SparsePair</span>
<span class="sd">        instance or a list of two lists, the first of which contains</span>
<span class="sd">        variable indices or names, the second of which contains the</span>
<span class="sd">        values that those variables take.  If the MIP start identified</span>
<span class="sd">        by ID already has a value for a variable specified by start,</span>
<span class="sd">        that value is replaced.</span>

<span class="sd">        The third argument, effort_level, must be an attribute of</span>
<span class="sd">        MIP_starts.effort_level.</span>

<span class="sd">        To change multiple MIP starts, call this method as</span>

<span class="sd">        cpx.MIP_starts.change(sequence)</span>

<span class="sd">        where sequence is a list of tuple of triples (ID, start,</span>
<span class="sd">        effort_level) as described above.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names = [&quot;x{0}&quot;.format(i) for i in range(4)],</span>
<span class="sd">        ...     types = &quot;I&quot; * 4</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind = [i], val = [0.0]),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto) for i in range(3)])</span>
<span class="sd">        &gt;&gt;&gt; for s in c.MIP_starts.get_starts():</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        (SparsePair(ind = [0], val = [0.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [1], val = [0.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [2], val = [0.0]), 0)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names()</span>
<span class="sd">        [&#39;m1&#39;, &#39;m2&#39;, &#39;m3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; check = c.MIP_starts.effort_level.check_feasibility</span>
<span class="sd">        &gt;&gt;&gt; repair = c.MIP_starts.effort_level.repair</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.change(&quot;m1&quot;, [[&quot;x0&quot;, &quot;x1&quot;], [1.0, 2.0]], check)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_starts(&quot;m1&quot;)</span>
<span class="sd">        (SparsePair(ind = [0, 1], val = [1.0, 2.0]), 1)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.change(1, [[1, 2], [-1.0, -2.0]], repair)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_starts(&quot;m2&quot;)</span>
<span class="sd">        (SparsePair(ind = [1, 2], val = [-1.0, -2.0]), 4)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.change([(1, [[0, 2], [-1.0, 2.0]], check),</span>
<span class="sd">        ...                      (&quot;m3&quot;, [[&quot;x0&quot;, 2], [3.0, 2.0]], repair)])</span>
<span class="sd">        &gt;&gt;&gt; for s in c.MIP_starts.get_starts([&quot;m2&quot;, &quot;m3&quot;]):</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        (SparsePair(ind = [0, 1, 2], val = [-1.0, -1.0, 2.0]), 1)</span>
<span class="sd">        (SparsePair(ind = [0, 2], val = [3.0, 2.0]), 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgmipstarts</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span>
                <span class="n">val</span><span class="p">,</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span></div>


<div class="viewcode-block" id="MIPStartsInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes MIP starts from the problem.</span>

<span class="sd">        There are four forms by which MIP_starts.delete may be called.</span>

<span class="sd">        MIP_starts.delete()</span>
<span class="sd">          deletes all MIP starts from the problem.</span>

<span class="sd">        MIP_starts.delete(i)</span>
<span class="sd">          i must be a MIP start name or index. Deletes the MIP start</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        MIP_starts.delete(s)</span>
<span class="sd">          s must be a sequence of MIP start names or indices.</span>
<span class="sd">          Deletes the MIP starts with names or indices contained within</span>
<span class="sd">          s. Equivalent to [MIP_starts.delete(i) for i in s].</span>

<span class="sd">        MIP_starts.delete(begin, end)</span>
<span class="sd">          begin and end must be MIP start indices or MIP start names.</span>
<span class="sd">          Deletes the MIP starts with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          MIP_starts.delete(range(begin, end + 1)). This will give the</span>
<span class="sd">          best performance when deleting batches of MIP starts.</span>

<span class="sd">        See `CPXdelmipstarts &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/delmipstarts.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&#39;x&#39;, &#39;y&#39;], types=[&quot;II&quot;])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind=[&#39;x&#39;], val=[1.0]),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto, str(i))</span>
<span class="sd">        ...      for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.delete(8)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.delete(&quot;1&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.delete([2, &quot;0&quot;, 5])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names()</span>
<span class="sd">        [&#39;4&#39;, &#39;6&#39;, &#39;7&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delmipstarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.get_starts">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.get_starts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_starts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of MIP starts.</span>

<span class="sd">        Returns a SparsePair instance or a list of SparsePair instances.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        MIP_starts.get_starts()</span>
<span class="sd">          return the starting vector for all MIP starts from the</span>
<span class="sd">          problem.</span>

<span class="sd">        MIP_starts.get_starts(i)</span>
<span class="sd">          i must be a MIP start name or index.  Returns the starting</span>
<span class="sd">          vector for the MIP start whose index or name is i.</span>

<span class="sd">        MIP_starts.get_starts(s)</span>
<span class="sd">          s must be a sequence of MIP start names or indices.</span>
<span class="sd">          Returns the starting vector for the MIP starts with indices</span>
<span class="sd">          the members of s.  Equivalent to [MIP_starts.get_starts(i)</span>
<span class="sd">          for i in s]</span>

<span class="sd">        MIP_starts.get_starts(begin, end)</span>
<span class="sd">          begin and end must be MIP start indices or MIP start names.</span>
<span class="sd">          Returns the starting vector for the MIP starts with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          MIP_starts.get_starts(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names=[str(i) for i in range(11)],</span>
<span class="sd">        ...     types=&quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; indices =c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind=[i], val=[1.0 * i]),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto, str(i))</span>
<span class="sd">        ...      for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_starts(7)</span>
<span class="sd">        (SparsePair(ind = [7], val = [7.0]), 0)</span>
<span class="sd">        &gt;&gt;&gt; for s in c.MIP_starts.get_starts(&quot;0&quot;, 2):</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        (SparsePair(ind = [0], val = [0.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [1], val = [1.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [2], val = [2.0]), 0)</span>
<span class="sd">        &gt;&gt;&gt; for s in c.MIP_starts.get_starts([2, &quot;0&quot;, 5]):</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        (SparsePair(ind = [2], val = [2.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [0], val = [0.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [5], val = [5.0]), 0)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.delete(3,9)</span>
<span class="sd">        &gt;&gt;&gt; for s in c.MIP_starts.get_starts():</span>
<span class="sd">        ...     print(s)</span>
<span class="sd">        (SparsePair(ind = [0], val = [0.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [1], val = [1.0]), 0)</span>
<span class="sd">        (SparsePair(ind = [2], val = [2.0]), 0)</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.effort_level[0]</span>
<span class="sd">        &#39;auto&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getmst</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmipstarts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">()</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matbeg</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matind</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matval</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mat</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getmst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.get_effort_levels">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.get_effort_levels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_effort_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the effort levels for a set of MIP starts.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        MIP_starts.get_effort_levels()</span>
<span class="sd">          return the effort level for all MIP starts from the</span>
<span class="sd">          problem.</span>

<span class="sd">        MIP_starts.get_effort_levels(i)</span>
<span class="sd">          i must be a MIP start name or index.  Returns the effort</span>
<span class="sd">          level for the MIP start whose index or name is i.</span>

<span class="sd">        MIP_starts.get_effort_levels(s)</span>
<span class="sd">          s must be a sequence of MIP start names or indices.</span>
<span class="sd">          Returns the effort level for the MIP starts with indices</span>
<span class="sd">          the members of s.  Equivalent to</span>
<span class="sd">          [MIP_starts.get_effort_levels(i) for i in s]</span>

<span class="sd">        MIP_starts.get_effort_levels(begin, end)</span>
<span class="sd">          begin and end must be MIP start indices or MIP start names.</span>
<span class="sd">          Returns the effort level for the MIP starts with indices</span>
<span class="sd">          between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          MIP_starts.get_effort_levels(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names = [str(i) for i in range(10)],</span>
<span class="sd">        ...     types = &quot;B&quot; * 10)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind = [i], val = [1.0 * i]),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto, str(i))</span>
<span class="sd">        ...      for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.change([(1, [[0], [0.0]], c.MIP_starts.effort_level.check_feasibility),</span>
<span class="sd">                                 (2, [[0], [0.0]], c.MIP_starts.effort_level.solve_fixed),</span>
<span class="sd">                                 (3, [[0], [0.0]], c.MIP_starts.effort_level.solve_MIP),</span>
<span class="sd">                                 (4, [[0], [0.0]], c.MIP_starts.effort_level.repair),</span>
<span class="sd">                                 (5, [[0], [0.0]], c.MIP_starts.effort_level.no_check)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.effort_level[c.MIP_starts.get_effort_levels(3)]</span>
<span class="sd">        &#39;solve_MIP&#39;</span>
<span class="sd">        &gt;&gt;&gt; [c.MIP_starts.effort_level[i] for i in c.MIP_starts.get_effort_levels(&quot;0&quot;,2)]</span>
<span class="sd">        [&#39;auto&#39;, &#39;check_feasibility&#39;, &#39;solve_fixed&#39;]</span>
<span class="sd">        &gt;&gt;&gt; [c.MIP_starts.effort_level[i] for i in c.MIP_starts.get_effort_levels([2,&quot;0&quot;,5])]</span>
<span class="sd">        [&#39;solve_fixed&#39;, &#39;auto&#39;, &#39;no_check&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_effort_levels()</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 0, 0, 0, 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">geteffort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmipstarts_effort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">geteffort</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.get_num_entries">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.get_num_entries">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_entries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of variables specified by a set of MIP starts.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        MIP_starts.get_num_entries()</span>
<span class="sd">          return the length of the starting vector for all MIP starts</span>
<span class="sd">          from the problem.</span>

<span class="sd">        MIP_starts.get_num_entries(i)</span>
<span class="sd">          i must be a MIP start name or index.  Returns the length of</span>
<span class="sd">          the starting vector for the MIP start whose index or name</span>
<span class="sd">          is i.</span>

<span class="sd">        MIP_starts.get_num_entries(s)</span>
<span class="sd">          s must be a sequence of MIP start names or indices.</span>
<span class="sd">          Returns the length of the starting vector for the MIP</span>
<span class="sd">          starts with indices the members of s.  Equivalent to</span>
<span class="sd">          [MIP_starts.get_num_entries(i) for i in s]</span>

<span class="sd">        MIP_starts.get_num_entries(begin, end)</span>
<span class="sd">          begin and end must be MIP start indices or MIP start names.</span>
<span class="sd">          Returns the length of the starting vector for the MIP starts</span>
<span class="sd">          with indices between begin and end, inclusive of end.</span>
<span class="sd">          Equivalent to</span>
<span class="sd">          MIP_starts.get_num_entries(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names = [str(i) for i in range(11)],</span>
<span class="sd">        ...     types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind = range(i), val = [0.0] * i),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto, str(i - 1))</span>
<span class="sd">        ...      for i in range(1, 11)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num_entries(3)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num_entries(&quot;0&quot;,2)</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num_entries([2,&quot;0&quot;,5])</span>
<span class="sd">        [3, 1, 6]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num_entries()</span>
<span class="sd">        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getmstsize</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmipstarts_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getmstsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPStartsInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPStartsInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of a set of MIP starts.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        MIP_starts.get_names()</span>
<span class="sd">          return the names of all MIP starts from the problem.</span>

<span class="sd">        MIP_starts.get_names(i)</span>
<span class="sd">          i must be a MIP start index.  Returns the name of MIP start i.</span>

<span class="sd">        MIP_starts.get_names(s)</span>
<span class="sd">          s must be a sequence of MIP start indices.  Returns the</span>
<span class="sd">          names of the MIP starts with indices the members of s.</span>
<span class="sd">          Equivalent to [MIP_starts.get_names(i) for i in s]</span>

<span class="sd">        MIP_starts.get_names(begin, end)</span>
<span class="sd">          begin and end must be MIP start indices. Returns the names of</span>
<span class="sd">          the MIP starts with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to MIP_starts.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names = [str(i) for i in range(11)],</span>
<span class="sd">        ...     types = &quot;B&quot; * 11)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.MIP_starts.add(</span>
<span class="sd">        ...     [(cplex.SparsePair(ind = range(i), val = [0.0] * i),</span>
<span class="sd">        ...       c.MIP_starts.effort_level.auto, &quot;mst&quot; + str(i - 1))</span>
<span class="sd">        ...      for i in range(1, 11)])</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names(8)</span>
<span class="sd">        &#39;mst8&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names(1, 3)</span>
<span class="sd">        [&#39;mst1&#39;, &#39;mst2&#39;, &#39;mst3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names([2, 0, 5])</span>
<span class="sd">        [&#39;mst2&#39;, &#39;mst0&#39;, &#39;mst5&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.MIP_starts.get_names()</span>
<span class="sd">        [&#39;mst0&#39;, &#39;mst1&#39;, &#39;mst2&#39;, &#39;mst3&#39;, &#39;mst4&#39;, &#39;mst5&#39;, &#39;mst6&#39;, &#39;mst7&#39;, &#39;mst8&#39;, &#39;mst9&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmipstartname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ObjSense">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjSense">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ObjSense</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants defining the sense of the objective function.</span>

<span class="sd">    See `CPXgetobjsen &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/getobjsen.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">    Manual for more detail.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maximize</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See CPX_MAX in the C API.&quot;&quot;&quot;</span>

    <span class="n">minimize</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MIN</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See CPX_MIN in the C API.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ObjectiveInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ObjectiveInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Contains methods for querying and modifying the objective function.&quot;&quot;&quot;</span>

    <span class="n">sense</span> <span class="o">=</span> <span class="n">ObjSense</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `ObjSense()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ObjectiveInterface.set_linear">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.set_linear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes the linear part of the objective function.</span>

<span class="sd">        Can be called by two forms:</span>

<span class="sd">        objective.set_linear(var, value)</span>
<span class="sd">          var must be a variable index or name and value must be a</span>
<span class="sd">          float.  Changes the coefficient of the variable identified</span>
<span class="sd">          by var to value.</span>

<span class="sd">        objective.set_linear(sequence)</span>
<span class="sd">          sequence is a sequence of pairs (var, value) as described</span>
<span class="sd">          above.  Changes the coefficients for the specified</span>
<span class="sd">          variables to the given values.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(4)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear()</span>
<span class="sd">        [0.0, 0.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_linear(0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear()</span>
<span class="sd">        [1.0, 0.0, 0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_linear(&quot;3&quot;, -1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear()</span>
<span class="sd">        [1.0, 0.0, 0.0, -1.0]</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_linear([(&quot;2&quot;, 2.0), (1, 0.5)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear()</span>
<span class="sd">        [1.0, 0.5, 2.0, -1.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">chgobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">apply_pairs</span><span class="p">(</span><span class="n">chgobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.set_quadratic">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.set_quadratic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_quadratic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the quadratic part of the objective function.</span>

<span class="sd">        Call this method with a list with length equal to the number</span>
<span class="sd">        of variables in the problem.</span>

<span class="sd">        If the quadratic objective function is separable, the entries</span>
<span class="sd">        of the list must all be of type float or int.</span>

<span class="sd">        If the quadratic objective function is not separable, the</span>
<span class="sd">        entries of the list must be either SparsePair instances or</span>
<span class="sd">        lists of two lists, the first of which contains variable</span>
<span class="sd">        indices or names, the second of which contains the values that</span>
<span class="sd">        those variables take.</span>

<span class="sd">        Note</span>
<span class="sd">          Successive calls to set_quadratic will overwrite any previous</span>
<span class="sd">          quadratic objective function.  To modify only part of the</span>
<span class="sd">          quadratic objective function, use the method</span>
<span class="sd">          set_quadratic_coefficients.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(3)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic(</span>
<span class="sd">        ...     [cplex.SparsePair(ind=[0, 1, 2], val=[1.0, -2.0, 0.5]),</span>
<span class="sd">        ...      cplex.SparsePair(ind=[0, 1], val=[-2.0, -1.0]),</span>
<span class="sd">        ...      cplex.SparsePair(ind=[0, 2], val=[0.5, -3.0])]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic():</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [0, 1, 2], val = [1.0, -2.0, 0.5])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [-2.0, -1.0])</span>
<span class="sd">        SparsePair(ind = [0, 2], val = [0.5, -3.0])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic([1.0, 2.0, 3.0])</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic():</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [1], val = [2.0])</span>
<span class="sd">        SparsePair(ind = [2], val = [3.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_HBMatrix</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">copyquad</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">matbeg</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">matind</span><span class="p">),</span>
                <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">matval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">copyqpsep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_quadratic</span><span class="p">(</span><span class="n">_HBMatrix</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>


<div class="viewcode-block" id="ObjectiveInterface.set_quadratic_coefficients">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.set_quadratic_coefficients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_quadratic_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets coefficients of the quadratic component of the objective</span>
<span class="sd">        function.</span>

<span class="sd">        To set a single coefficient, call this method as</span>

<span class="sd">        objective.set_quadratic_coefficients(v1, v2, val)</span>

<span class="sd">        where v1 and v2 are names or indices of variables and val is</span>
<span class="sd">        the value for the coefficient.</span>

<span class="sd">        To set multiple coefficients, call this method as</span>

<span class="sd">        objective.set_quadratic_coefficients(sequence)</span>

<span class="sd">        where sequence is a list or tuple of triples (v1, v2, val) as</span>
<span class="sd">        described above.</span>

<span class="sd">        Note</span>
<span class="sd">          Since the quadratic objective function must be symmetric, each</span>
<span class="sd">          triple in which v1 is different from v2 is used to set both</span>
<span class="sd">          the (v1, v2) coefficient and the (v2, v1) coefficient.  If</span>
<span class="sd">          (v1, v2) and (v2, v1) are set with a single call, the second</span>
<span class="sd">          value is stored.</span>

<span class="sd">        Note</span>
<span class="sd">          Attempting to set many coefficients with set_quadratic_coefficients</span>
<span class="sd">          can be time consuming. Instead, use the method set_quadratic to set</span>
<span class="sd">          the quadratic part of the objective efficiently.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(3)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients(0, 1, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic():</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [1], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients([(1, 1, 2.0),</span>
<span class="sd">        ...                                         (0, 2, 3.0)])</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic():</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [1, 2], val = [1.0, 3.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [1.0, 2.0])</span>
<span class="sd">        SparsePair(ind = [0], val = [3.0])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients([(0, 1, 4.0),</span>
<span class="sd">        ...                                         (1, 0, 5.0)])</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic():</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [1, 2], val = [5.0, 3.0])</span>
<span class="sd">        SparsePair(ind = [0, 1], val = [5.0, 2.0])</span>
<span class="sd">        SparsePair(ind = [0], val = [3.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg_list</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">varcache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">arg_list</span><span class="p">:</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgqpcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">varcache</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">varcache</span><span class="p">),</span>
                               <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.set_sense">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.set_sense">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_sense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sense</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the sense of the objective function.</span>

<span class="sd">        The argument to this method must be either</span>
<span class="sd">        objective.sense.minimize or objective.sense.maximize.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.objective.sense[c.objective.get_sense()]</span>
<span class="sd">        &#39;minimize&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_sense(c.objective.sense.maximize)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.sense[c.objective.get_sense()]</span>
<span class="sd">        &#39;maximize&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_sense(c.objective.sense.minimize)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.sense[c.objective.get_sense()]</span>
<span class="sd">        &#39;minimize&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgobjsen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">sense</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.set_name">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.set_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the name of the objective function.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_name(&quot;cost&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_name()</span>
<span class="sd">        &#39;cost&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">copyobjname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_linear">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_linear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the linear coefficients of a set of variables.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        objective.get_linear()</span>
<span class="sd">          return the linear objective coefficients of all variables</span>
<span class="sd">          from the problem.</span>

<span class="sd">        objective.get_linear(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the linear</span>
<span class="sd">          objective coefficient of the variable whose index or name</span>
<span class="sd">          is i.</span>

<span class="sd">        objective.get_linear(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the linear objective coefficient of the variables with</span>
<span class="sd">          indices the members of s.  Equivalent to</span>
<span class="sd">          [objective.get_linear(i) for i in s]</span>

<span class="sd">        objective.get_linear(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the linear objective coefficient of the variables with</span>
<span class="sd">          indices between begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          objective.get_linear(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(obj = [1.5 * i for i in range(10)],</span>
<span class="sd">                            names = [str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear(8)</span>
<span class="sd">        12.0</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear(&quot;1&quot;,3)</span>
<span class="sd">        [1.5, 3.0, 4.5]</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear([2,&quot;0&quot;,5])</span>
<span class="sd">        [3.0, 0.0, 7.5]</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_linear()</span>
<span class="sd">        [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_quadratic">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_quadratic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of columns of the quadratic component of the</span>
<span class="sd">        objective function.</span>

<span class="sd">        Returns a SparsePair instance or a list of SparsePair instances.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        objective.get_quadratic()</span>
<span class="sd">          return the entire quadratic objective function.</span>

<span class="sd">        objective.get_quadratic(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the column of</span>
<span class="sd">          the quadratic objective function associated with the</span>
<span class="sd">          variable whose index or name is i.</span>

<span class="sd">        objective.get_quadratic(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the columns of the quadratic objective function associated</span>
<span class="sd">          with the variables with indices the members of s.</span>
<span class="sd">          Equivalent to [objective.get_quadratic(i) for i in s]</span>

<span class="sd">        objective.get_quadratic(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the columns of the quadratic objective function</span>
<span class="sd">          associated with the variables with indices between begin and</span>
<span class="sd">          end, inclusive of end. Equivalent to</span>
<span class="sd">          objective.get_quadratic(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[str(i) for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.variables.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic([1.5 * i for i in range(10)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_quadratic(8)</span>
<span class="sd">        SparsePair(ind = [8], val = [12.0])</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic(&quot;1&quot;, 3):</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [1], val = [1.5])</span>
<span class="sd">        SparsePair(ind = [2], val = [3.0])</span>
<span class="sd">        SparsePair(ind = [3], val = [4.5])</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic([3, &quot;1&quot;, 5]):</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [3], val = [4.5])</span>
<span class="sd">        SparsePair(ind = [1], val = [1.5])</span>
<span class="sd">        SparsePair(ind = [5], val = [7.5])</span>
<span class="sd">        &gt;&gt;&gt; for q in c.objective.get_quadratic():</span>
<span class="sd">        ...     print(q)</span>
<span class="sd">        SparsePair(ind = [], val = [])</span>
<span class="sd">        SparsePair(ind = [1], val = [1.5])</span>
<span class="sd">        SparsePair(ind = [2], val = [3.0])</span>
<span class="sd">        SparsePair(ind = [3], val = [4.5])</span>
<span class="sd">        SparsePair(ind = [4], val = [6.0])</span>
<span class="sd">        SparsePair(ind = [5], val = [7.5])</span>
<span class="sd">        SparsePair(ind = [6], val = [9.0])</span>
<span class="sd">        SparsePair(ind = [7], val = [10.5])</span>
<span class="sd">        SparsePair(ind = [8], val = [12.0])</span>
<span class="sd">        SparsePair(ind = [9], val = [13.5])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getquad</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getquad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">matbeg</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">matind</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">matval</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getquad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_quadratic_coefficients">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_quadratic_coefficients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns individual coefficients from the quadratic objective function.</span>

<span class="sd">        To query a single coefficient, call this as</span>

<span class="sd">        objective.get_quadratic_coefficients(v1, v2)</span>

<span class="sd">        where v1 and v2 are indices or names of variables.</span>

<span class="sd">        To query multiple coefficients, call this method as</span>

<span class="sd">        objective.get_quadratic_coefficients(sequence)</span>

<span class="sd">        where sequence is a list or tuple of pairs (v1, v2) as</span>
<span class="sd">        described above.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(3)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients(0, 1, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_quadratic_coefficients(&quot;1&quot;, 0)</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients([(1, 1, 2.0), (0, 2, 3.0), (1, 0, 5.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_quadratic_coefficients([(1, 0), (1, &quot;1&quot;), (2, &quot;0&quot;)])</span>
<span class="sd">        [5.0, 2.0, 3.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getqpcoef</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqpcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getqpcoef</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_quadratic_coefficients</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">()</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_sense">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_sense">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sense of the objective function.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.objective.sense[c.objective.get_sense()]</span>
<span class="sd">        &#39;minimize&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_sense(c.objective.sense.maximize)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.sense[c.objective.get_sense()]</span>
<span class="sd">        &#39;maximize&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_sense(c.objective.sense.minimize)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.sense[c.objective.get_sense()]</span>
<span class="sd">        &#39;minimize&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getobjsen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_name">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the name of the objective function.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_name(&quot;cost&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_name()</span>
<span class="sd">        &#39;cost&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getobjname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_num_quadratic_variables">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_num_quadratic_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_quadratic_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of variables with quadratic coefficients.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(3)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients(0, 1, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_num_quadratic_variables()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic([1.0, 0.0, 0.0])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_num_quadratic_variables()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients([(1, 1, 2.0), (0, 2, 3.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_num_quadratic_variables()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumquad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_num_quadratic_nonzeros">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_num_quadratic_nonzeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_quadratic_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nonzeros in the quadratic objective function.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(3)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients(0, 1, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_num_quadratic_nonzeros()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients([(1, 1, 2.0), (0, 2, 3.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_num_quadratic_nonzeros()</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_quadratic_coefficients([(0, 1, 4.0), (1, 0, 0.0)])</span>
<span class="sd">        &gt;&gt;&gt; c.objective.get_num_quadratic_nonzeros()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumqpnz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.get_offset">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.get_offset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the constant offset of the objective function for a problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; offset = c.objective.get_offset()</span>
<span class="sd">        &gt;&gt;&gt; abs(offset - 0.0) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getobjoffset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectiveInterface.set_offset">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ObjectiveInterface.set_offset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the constant offset of the objective function for a problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.objective.set_offset(3.14)</span>
<span class="sd">        &gt;&gt;&gt; offset = c.objective.get_offset()</span>
<span class="sd">        &gt;&gt;&gt; abs(offset - 3.14) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">chgobjoffset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ProgressInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ProgressInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods to query the progress of optimization.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProgressInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new ProgressInterface.</span>

<span class="sd">        The progress interface is exposed by the top-level `Cplex`</span>
<span class="sd">        class as Cplex.solution.progress.  This constructor is not</span>
<span class="sd">        meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_iterations">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_iterations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of iterations executed so far.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_iter = c.solution.progress.get_num_iterations()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_is_MIP</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmipitcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span>
        <span class="n">siftcnt</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsiftitcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">siftcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">siftcnt</span>
        <span class="n">baritcnt</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getbaritcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">baritcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">baritcnt</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getitcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_barrier_iterations">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_barrier_iterations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_barrier_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of barrier iterations.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;qcp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_iter = c.solution.progress.get_num_barrier_iterations()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getbaritcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_sifting_iterations">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_sifting_iterations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_sifting_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of sifting iterations.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.sifting)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_iter = c.solution.progress.get_num_sifting_iterations()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsiftitcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_phase_one_iterations">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_phase_one_iterations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_phase_one_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of iterations to find a feasible solution.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_iter = c.solution.progress.get_num_phase_one_iterations()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getphase1cnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_sifting_phase_one_iterations">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_sifting_phase_one_iterations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_sifting_phase_one_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of sifting iterations to find a feasible solution.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.sifting)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_iter = c.solution.progress.get_num_sifting_phase_one_iterations()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsiftphase1cnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_nodes_processed">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_nodes_processed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_nodes_processed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nodes processed.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_nodes = c.solution.progress.get_num_nodes_processed()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnodecnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_nodes_remaining">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_nodes_remaining">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_nodes_remaining</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of nodes left to process.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_nodes = c.solution.progress.get_num_nodes_remaining()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnodeleftcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_primal_push">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_primal_push">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_primal_push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of primal push operations.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.barrier)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_push = c.solution.progress.get_num_primal_push()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcrossppushcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_primal_exchange">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_primal_exchange">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_primal_exchange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of primal exchange operations.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.barrier)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_exch = c.solution.progress.get_num_primal_exchange()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcrosspexchcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_dual_push">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_dual_push">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_dual_push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of dual push operations.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.barrier)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_push = c.solution.progress.get_num_dual_push()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcrossdpushcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_dual_exchange">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_dual_exchange">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_dual_exchange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of dual exchange operations.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.barrier)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num_exch = c.solution.progress.get_num_dual_exchange()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcrossdexchcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProgressInterface.get_num_conflict_passes">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ProgressInterface.get_num_conflict_passes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_conflict_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of passes performed by the conflict</span>
<span class="sd">        refiner.</span>

<span class="sd">        See `CPXgetconflictnumpasses &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/getconflictnumpasses.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;infeasible.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.refine()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.progress.get_num_conflict_passes()</span>
<span class="sd">        5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getconflictnumpasses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="InfeasibilityInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InfeasibilityInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InfeasibilityInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for computing degree of infeasibility in a solution vector.</span>

<span class="sd">    Each of these methods takes one required argument, x, which must</span>
<span class="sd">    be a list of floats with length equal to the number of variables.</span>

<span class="sd">    If no other arguments are provided, the methods return the</span>
<span class="sd">    violation for all constraints of the given type.</span>

<span class="sd">    If one string or integer is provided, it is taken to be the name</span>
<span class="sd">    or index of a constraint of the given type.  The methods return</span>
<span class="sd">    the violation of that constraint.</span>

<span class="sd">    If two strings or integers are provided, they are taken to be the</span>
<span class="sd">    names or indices of constraints of the given type.  All violations</span>
<span class="sd">    for constraints between the first and second, inclusive, are</span>
<span class="sd">    returned in a list.</span>

<span class="sd">    If a sequence of strings or integers are provided, they are taken</span>
<span class="sd">    to be the names or indices of constraints of the given type.  All</span>
<span class="sd">    violations for constraints identified in the sequence are returned</span>
<span class="sd">    in a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="InfeasibilityInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InfeasibilityInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new InfeasibilityInterface.</span>

<span class="sd">        The infeasibility interface is exposed by the top-level `Cplex`</span>
<span class="sd">        class as Cplex.solution.infeasibility.  This constructor is not</span>
<span class="sd">        meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="InfeasibilityInterface.bound_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InfeasibilityInterface.bound_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bound_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the amount by which variable bounds are violated by x.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.bound_constraints(c.solution.get_values(), 2)</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.bound_constraints(c.solution.get_values(), &quot;x10&quot;)</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.bound_constraints(c.solution.get_values(), [&quot;x10&quot;, 8])</span>
<span class="sd">        [0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; bd = c.solution.infeasibility.bound_constraints(c.solution.get_values())</span>
<span class="sd">        &gt;&gt;&gt; bd[15]</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getinfeas</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcolinfeas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getinfeas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="InfeasibilityInterface.linear_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InfeasibilityInterface.linear_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">linear_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the amount by which a set of linear constraints are violated by x.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; sol_vals = c.solution.get_values()</span>
<span class="sd">        &gt;&gt;&gt; getrowinfeas = c.solution.infeasibility.linear_constraints</span>
<span class="sd">        &gt;&gt;&gt; abs(getrowinfeas(sol_vals, &quot;c10&quot;))</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; abs(getrowinfeas(sol_vals, 7))</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; [abs(x) for x in getrowinfeas(sol_vals, [&quot;c13&quot;, 4])]</span>
<span class="sd">        [0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; lconstraint = getrowinfeas(sol_vals)</span>
<span class="sd">        &gt;&gt;&gt; abs(lconstraint[5])</span>
<span class="sd">        0.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getinfeas</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getrowinfeas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getinfeas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="InfeasibilityInterface.quadratic_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InfeasibilityInterface.quadratic_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">quadratic_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the amount by which a set of quadratic constraints are violated by x.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;miqcp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; getqconstrinfeas = c.solution.infeasibility.quadratic_constraints</span>
<span class="sd">        &gt;&gt;&gt; abs(getqconstrinfeas(c.solution.get_values(), 2)) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; abs(getqconstrinfeas(c.solution.get_values(), &quot;QC3&quot;)) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; [abs(x) &lt; 1e-6 for x in getqconstrinfeas(c.solution.get_values(), [1, &quot;QC1&quot;])]</span>
<span class="sd">        [True, True]</span>
<span class="sd">        &gt;&gt;&gt; [abs(x) &lt; 1e-6 for x in getqconstrinfeas(c.solution.get_values())]</span>
<span class="sd">        [True, True, True, True]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getinfeas</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstrinfeas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getinfeas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="InfeasibilityInterface.indicator_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InfeasibilityInterface.indicator_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">indicator_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the amount by which indicator constraints are violated by x.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.indicator_constraints(c.solution.get_values(), 3)</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.indicator_constraints(c.solution.get_values(), &quot;c21&quot;)</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.indicator_constraints(c.solution.get_values(), [&quot;c21&quot;, 10])</span>
<span class="sd">        [0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; iconstraint = c.solution.infeasibility.indicator_constraints(c.solution.get_values())</span>
<span class="sd">        &gt;&gt;&gt; iconstraint[5]</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getinfeas</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">indicator_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstrinfeas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getinfeas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">indicator_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="InfeasibilityInterface.SOS_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InfeasibilityInterface.SOS_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">SOS_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the amount by which SOS constraints are violated by x.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;miqcp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.SOS_constraints(c.solution.get_values(), 0)</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.SOS_constraints(c.solution.get_values(), &quot;set1&quot;)</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.SOS_constraints(c.solution.get_values(), [&quot;set1&quot;, 0])</span>
<span class="sd">        [0.0, 0.0]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.infeasibility.SOS_constraints(c.solution.get_values())</span>
<span class="sd">        [0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getinfeas</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">SOS</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsosinfeas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getinfeas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">SOS</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CutType">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.CutType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CutType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identifiers for types of cuts.&quot;&quot;&quot;</span>
    <span class="c1"># NB: If you edit these, look at MIPInfoCallback.cut_type too!</span>
    <span class="n">cover</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_COVER</span>
    <span class="n">GUB_cover</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_GUBCOVER</span>
    <span class="n">flow_cover</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_FLOWCOVER</span>
    <span class="n">clique</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_CLIQUE</span>
    <span class="n">fractional</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_FRAC</span>
    <span class="n">MIR</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_MIR</span>
    <span class="n">flow_path</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_FLOWPATH</span>
    <span class="n">disjunctive</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_DISJ</span>
    <span class="n">implied_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_IMPLBD</span>
    <span class="n">zero_half</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_ZEROHALF</span>
    <span class="n">multi_commodity_flow</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_MCF</span>
    <span class="n">_local_cover</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_LOCALCOVER</span>
    <span class="n">_tighten</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_TIGHTEN</span>
    <span class="n">_objective_disjunctive</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_OBJDISJ</span>
    <span class="n">lift_and_project</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_LANDP</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_USER</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_TABLE</span>
    <span class="n">solution_pool</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_SOLNPOOL</span>
    <span class="n">local_implied_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_LOCALIMPLBD</span>
    <span class="n">BQP</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_BQP</span>
    <span class="n">RLT</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_RLT</span>
    <span class="n">benders</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_BENDERS</span>
    <span class="n">__num_types</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CUT_NUM_TYPES</span></div>



<div class="viewcode-block" id="MIPSolutionInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MIPSolutionInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for accessing solutions to a MIP.&quot;&quot;&quot;</span>

    <span class="n">cut_type</span> <span class="o">=</span> <span class="n">CutType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `CutType()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MIPSolutionInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new MIPSolutionInterface.</span>

<span class="sd">        The MIP solution interface is exposed by the top-level `Cplex`</span>
<span class="sd">        class as Cplex.solution.MIP.  This constructor is not meant to</span>
<span class="sd">        be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPSolutionInterface.get_best_objective">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface.get_best_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_best_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the currently best known bound of all the remaining</span>
<span class="sd">        open nodes in a branch-and-cut tree.</span>

<span class="sd">        It is computed for a minimization problem as the minimum</span>
<span class="sd">        objective function value of all remaining unexplored nodes.</span>
<span class="sd">        Similarly, it is computed for a maximization problem as the</span>
<span class="sd">        maximum objective function value of all remaining unexplored</span>
<span class="sd">        nodes.</span>

<span class="sd">        For a regular MIP optimization, this value is also the best known</span>
<span class="sd">        bound on the optimal solution value of the MIP problem.  In fact,</span>
<span class="sd">        when a problem has been solved to optimality, this value matches</span>
<span class="sd">        the optimal solution value.</span>

<span class="sd">        However, for the populate method, the value can also exceed the</span>
<span class="sd">        optimal solution value if CPLEX has already solved the model to</span>
<span class="sd">        optimality but continues to search for additional solutions.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; best_obj = c.solution.MIP.get_best_objective()</span>
<span class="sd">        &gt;&gt;&gt; abs(best_obj - 499.0) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getbestobjval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPSolutionInterface.get_cutoff">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface.get_cutoff">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the MIP cutoff value.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; cutoff = c.solution.MIP.get_cutoff()</span>
<span class="sd">        &gt;&gt;&gt; abs(cutoff - 499.0) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getcutoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPSolutionInterface.get_mip_relative_gap">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface.get_mip_relative_gap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_mip_relative_gap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the MIP relative gap.</span>

<span class="sd">        See `CPXgetmiprelgap &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/getmiprelgap.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.MIP.get_mip_relative_gap()</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmiprelgap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPSolutionInterface.get_incumbent_node">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface.get_incumbent_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_incumbent_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the node number of the best solution found.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.threads.set(1)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.MIP.get_incumbent_node() &gt;= 0</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnodeint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPSolutionInterface.get_num_cuts">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface.get_num_cuts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of cuts of the specified type.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; ncuts = c.solution.MIP.get_num_cuts(</span>
<span class="sd">        ...     c.solution.MIP.cut_type.zero_half)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumcuts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">cut_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPSolutionInterface.get_subproblem_status">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.MIPSolutionInterface.get_subproblem_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_subproblem_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the solution status of the last subproblem optimization.</span>

<span class="sd">        Returns an attribute of Cplex.solution.status if there was an</span>
<span class="sd">        error termination where a subproblem could not be solved to</span>
<span class="sd">        completion during mixed integer optimization.  Otherwise 0</span>
<span class="sd">        (zero) is returned if no error occurred.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.MIP.get_subproblem_status()</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsubstat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="BasisVarStatus">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisVarStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BasisVarStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Status values returned by basis query methods.&quot;&quot;&quot;</span>
    <span class="n">at_lower_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_AT_LOWER</span>
    <span class="n">basic</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_BASIC</span>
    <span class="n">at_upper_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_AT_UPPER</span>
    <span class="n">free_nonbasic</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_FREE_SUPER</span></div>



<div class="viewcode-block" id="BasisInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BasisInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for accessing the basis of a solution.&quot;&quot;&quot;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">BasisVarStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `BasisVarStatus()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BasisInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new BasisInterface.</span>

<span class="sd">        The basis interface is exposed by the top-level `Cplex` class as</span>
<span class="sd">        Cplex.solution.basis.  This constructor is not meant to be used</span>
<span class="sd">        externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_basis">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_basis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of structural and slack variables.</span>

<span class="sd">        Returns a pair of lists of attributes of solution.basis.status.</span>
<span class="sd">        The first lists the status of the structural variables (of length</span>
<span class="sd">        equal to the number of variables), the second lists the status of</span>
<span class="sd">        the slack variables (of length equal to the number of linear</span>
<span class="sd">        constraints).</span>

<span class="sd">        See `CPXgetbase &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/getbase.html&gt;`_ in the Callable Library Reference Manual</span>
<span class="sd">        for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; pair_of_lists = c.solution.basis.get_basis()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getbase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the basis to a file.</span>

<span class="sd">        See `CPXmbasewrite &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/mbasewrite.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual and also `InitialInterface.read_basis()`.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.basis.write(&quot;lpex.bas&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">mbasewrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_header">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_header">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the basis header.</span>

<span class="sd">        Returns a pair (head, x), where head is a list of variable</span>
<span class="sd">        indices and x is a list of floats indicating the values of</span>
<span class="sd">        those variables.  Indices of basic slacks are specified by</span>
<span class="sd">        -rowindex - 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getbhead</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_basic_row_index">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_basic_row_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basic_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the position of a basic slack variable in the basis header.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.basis.get_basic_row_index(2)</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getijrow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_basic_col_index">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_basic_col_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basic_col_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the position of a basic structural variable in the basis header.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.basis.get_basic_col_index(2)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getijrow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_primal_norms">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_primal_norms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_primal_norms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns norms from the primal steepest edge.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.preprocessing.presolve.set(c.parameters.preprocessing.presolve.values.off)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.simplex.pgradient.set(c.parameters.simplex.pgradient.values.steep)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.primal)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; pnorm = c.solution.basis.get_primal_norms()</span>
<span class="sd">        &gt;&gt;&gt; for i, j in zip(pnorm[1], [1.722656, 1.691406, 2.0, 1.062499]):</span>
<span class="sd">        ...     abs(i - j) &lt; 1e-6</span>
<span class="sd">        ...</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getpnorms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_dual_norms">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_dual_norms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dual_norms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns norms from the dual steepest edge.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.basis.get_dual_norms()</span>
<span class="sd">        ([1.0, 1.0, 1.0, 1.0], [1, 2, 3, -3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getdnorms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_basis_dual_norms">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_basis_dual_norms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basis_dual_norms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns basis and dual norms.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.basis.get_basis_dual_norms()</span>
<span class="sd">        ([2, 1, 1, 1], [0, 0, 1, 0], [1.0, 1.0, 1.0, 1.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getbasednorms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_num_primal_superbasic">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_num_primal_superbasic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_primal_superbasic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of primal superbasic variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getpsbcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="BasisInterface.get_num_dual_superbasic">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BasisInterface.get_num_dual_superbasic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_dual_superbasic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of primal superbasic variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getdsbcnt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SensitivityInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SensitivityInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SensitivityInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for sensitivity analysis.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SensitivityInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SensitivityInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new SensitivityInterface.</span>

<span class="sd">        The sensitivity interface is exposed by the top-level `Cplex`</span>
<span class="sd">        class as Cplex.solution.sensitivity.  This constructor is not</span>
<span class="sd">        meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SensitivityInterface.lower_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SensitivityInterface.lower_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lower_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sensitivity of a set of lower bounds.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.lower_bounds(1)</span>
<span class="sd">        (-1e+20, 17.5)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.lower_bounds(&#39;x3&#39;)</span>
<span class="sd">        (-1e+20, 42.5)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.lower_bounds([&quot;x3&quot;, 0])</span>
<span class="sd">        [(-1e+20, 42.5), (-1e+20, 40.0)]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.lower_bounds()</span>
<span class="sd">        [(-1e+20, 40.0), (-1e+20, 17.5), (-1e+20, 42.5), (-1e+20, 0.625)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">sa</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">boundsa_lower</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">sa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SensitivityInterface.upper_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SensitivityInterface.upper_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">upper_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sensitivity of a set of upper bounds.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.upper_bounds(1)</span>
<span class="sd">        (17.5, 1e+20)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.upper_bounds(&quot;x3&quot;)</span>
<span class="sd">        (42.5, 1e+20)</span>
<span class="sd">        &gt;&gt;&gt; bupper = c.solution.sensitivity.upper_bounds([&quot;x3&quot;, 0])</span>
<span class="sd">        &gt;&gt;&gt; for i, j in zip(bupper, [(42.5, 1e+20), (36.428571, 155.0)]):</span>
<span class="sd">        ...     abs(i[0] - j[0]) &lt; 1e-6 and abs(i[1]- j[1]) &lt; 1e-6</span>
<span class="sd">        ...</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; bupper = c.solution.sensitivity.upper_bounds()</span>
<span class="sd">        &gt;&gt;&gt; for i, j in zip(bupper[3], (0.625, 1e+20)):</span>
<span class="sd">        ...     abs(i - j) &lt; 1e-6</span>
<span class="sd">        ...</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">sa</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">boundsa_upper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">sa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SensitivityInterface.bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SensitivityInterface.bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sensitivity of a set of both lower and upper bounds.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.bounds(1)</span>
<span class="sd">        (-1e+20, 17.5, 17.5, 1e+20)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.bounds(&quot;x3&quot;)</span>
<span class="sd">        (-1e+20, 42.5, 42.5, 1e+20)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.bounds([&quot;x3&quot;, 1])</span>
<span class="sd">        [(-1e+20, 42.5, 42.5, 1e+20), (-1e+20, 17.5, 17.5, 1e+20)]</span>
<span class="sd">        &gt;&gt;&gt; bd = c.solution.sensitivity.bounds()</span>
<span class="sd">        &gt;&gt;&gt; bd[1]</span>
<span class="sd">        (-1e+20, 17.5, 17.5, 1e+20)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">sa</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">boundsa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">sa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SensitivityInterface.objective">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SensitivityInterface.objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sensitivity of part of the objective function.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.objective(1)</span>
<span class="sd">        (-3.0, 5.0)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.objective(&quot;x3&quot;)</span>
<span class="sd">        (-1e+20, -2.0)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.objective([&quot;x3&quot;, 1])</span>
<span class="sd">        [(-1e+20, -2.0), (-3.0, 5.0)]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.objective()</span>
<span class="sd">        [(-1e+20, 2.5), (-3.0, 5.0), (-1e+20, -2.0), (0.0, 4.0)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">sa</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">objsa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">sa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SensitivityInterface.rhs">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SensitivityInterface.rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sensitivity of the righthand side of a set of linear constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; rhssa = c.solution.sensitivity.rhs(1)</span>
<span class="sd">        &gt;&gt;&gt; for i, j in zip(rhssa, (20.0, 46.666666)):</span>
<span class="sd">        ...     abs(i - j) &lt; 1e-6</span>
<span class="sd">        ...</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.solution.sensitivity.rhs(&quot;c3&quot;)</span>
<span class="sd">        (-1e+20, 112.5)</span>
<span class="sd">        &gt;&gt;&gt; rhssa = c.solution.sensitivity.rhs([&quot;c3&quot;, 1])</span>
<span class="sd">        &gt;&gt;&gt; for i, j in zip(rhssa, [(-1e+20, 112.5), (20.0, 46.666666)]):</span>
<span class="sd">        ...     abs(i[0] - j[0]) &lt; 1e-6 and abs(i[1]- j[1]) &lt; 1e-6</span>
<span class="sd">        ...</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; rhssa = c.solution.sensitivity.rhs()</span>
<span class="sd">        &gt;&gt;&gt; for i, j in zip(rhssa[3], (-1e+20, 42.5)):</span>
<span class="sd">        ...     abs(i - j) &lt; 1e-6</span>
<span class="sd">        ...</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">sa</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">rhssa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">sa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FilterType">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FilterType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FilterType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attributes define the filter types.&quot;&quot;&quot;</span>
    <span class="n">diversity</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SOLNPOOL_FILTER_DIVERSITY</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SOLNPOOL_FILTER_RANGE</span></div>



<div class="viewcode-block" id="SolnPoolFilterInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolnPoolFilterInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for solution pool filters.&quot;&quot;&quot;</span>

    <span class="nb">type</span> <span class="o">=</span> <span class="n">FilterType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `FilterType()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SolnPoolFilterInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new SolnPoolFilterInterface.</span>

<span class="sd">        The solution pool filter interface is exposed by the top-level</span>
<span class="sd">        `Cplex` class as Cplex.solution.pool.filter.  This constructor</span>
<span class="sd">        is not meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolfilterindex</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_diversity_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">weights</span><span class="p">],</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: expression, weights&quot;</span>
        <span class="p">)</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addsolnpooldivfilter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span>
            <span class="n">weights</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="SolnPoolFilterInterface.add_diversity_filter">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.add_diversity_filter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_diversity_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a diversity filter to the solution pool.</span>

<span class="sd">        The arguments determine, in order,</span>

<span class="sd">        the lower bound (float)</span>

<span class="sd">        the upper bound (float)</span>

<span class="sd">        the variables and values it takes as either a SparsePair or a</span>
<span class="sd">        list of two lists.</span>

<span class="sd">        a set of weights (a list of floats with the same length as</span>
<span class="sd">        expression).  If an empty list is given, then weights of 1.0</span>
<span class="sd">        (one) will be used.</span>

<span class="sd">        name (string)</span>

<span class="sd">        Returns the index of the added diversity filter.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.add_diversity_filter(</span>
<span class="sd">        ...     300, 600, [[&#39;x1&#39;,&#39;x2&#39;], [1,1]], [2,1], &quot;&quot;)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">weights</span><span class="p">,)</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_single</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_diversity_filter</span><span class="p">,</span>
                                <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_range_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;non-public&quot;&quot;&quot;</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">addsolnpoolrngfilter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="SolnPoolFilterInterface.add_range_filter">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.add_range_filter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_range_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a range filter to the solution pool.</span>

<span class="sd">        The arguments determine, in order,</span>

<span class="sd">        the lower bound (float)</span>

<span class="sd">        the upper bound (float)</span>

<span class="sd">        the variables and values it takes as either a SparsePair or a</span>
<span class="sd">        list of two lists.</span>

<span class="sd">        name (string)</span>

<span class="sd">        Returns the index of the added range filter.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...     300, 600, [[&#39;x1&#39;,&#39;x2&#39;], [1,1]], &quot;&quot;)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_single</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_range_filter</span><span class="p">,</span>
                                <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.get_diversity_filters">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.get_diversity_filters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_diversity_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of diversity filters.</span>

<span class="sd">        Returns filters as pairs of (SparsePair, weights), where</span>
<span class="sd">        weights is a list of floats.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&#39;x&#39;,&#39;y&#39;], types = [&quot;BB&quot;])</span>
<span class="sd">        &gt;&gt;&gt; f = cplex.SparsePair(ind = [&#39;x&#39;],val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_diversity_filter(</span>
<span class="sd">        ...      0, 1, f, [1], str(i))</span>
<span class="sd">        ...  for i in range(2)]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_diversity_filters(0)</span>
<span class="sd">        (SparsePair(ind = [0], val = [1.0]), [1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_diversity_filters(&quot;1&quot;)</span>
<span class="sd">        (SparsePair(ind = [0], val = [1.0]), [1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_diversity_filters([0, &quot;1&quot;])</span>
<span class="sd">        [(SparsePair(ind = [0], val = [1.0]), [1.0]), (SparsePair(ind = [0], val = [1.0]), [1.0])]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_diversity_filters()</span>
<span class="sd">        [(SparsePair(ind = [0], val = [1.0]), [1.0]), (SparsePair(ind = [0], val = [1.0]), [1.0])]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getflt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpooldivfilter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">ret</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getflt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.get_range_filters">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.get_range_filters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_range_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of range filters.</span>

<span class="sd">        Returns filters as SparsePair instances.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&#39;x&#39;,&#39;y&#39;], types = [&quot;II&quot;])</span>
<span class="sd">        &gt;&gt;&gt; f = cplex.SparsePair(ind = [&#39;x&#39;],val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...      0.0, 1.0, f, str(i)) for i in range(2)]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_range_filters(0)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_range_filters(&quot;1&quot;)</span>
<span class="sd">        SparsePair(ind = [0], val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_range_filters([0, &quot;1&quot;])</span>
<span class="sd">        [SparsePair(ind = [0], val = [1.0]), SparsePair(ind = [0], val = [1.0])]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_range_filters()</span>
<span class="sd">        [SparsePair(ind = [0], val = [1.0]), SparsePair(ind = [0], val = [1.0])]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getflt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolrngfilter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SparsePair</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getflt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_getfilter_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="n">filter_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_types</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">diversity</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpooldivfilter_constant</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">range</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolrngfilter_constant</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>

<div class="viewcode-block" id="SolnPoolFilterInterface.get_bounds">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.get_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns (lb, ub) pairs for a set of filters.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&#39;x&#39;, &#39;y&#39;], types=[&quot;BB&quot;])</span>
<span class="sd">        &gt;&gt;&gt; f = cplex.SparsePair(ind=[&#39;x&#39;], val=[1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_diversity_filter(</span>
<span class="sd">        ...      0, 1, f, [1], &quot;div{0}&quot;.format(i)) for i in range(2)]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...      0, 1, f, &quot;rng{0}&quot;.format(i)) for i in range(2)]</span>
<span class="sd">        [2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_bounds(0)</span>
<span class="sd">        (0.0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_bounds(&quot;rng0&quot;)</span>
<span class="sd">        (0.0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_bounds([&quot;div0&quot;, 2])</span>
<span class="sd">        [(0.0, 1.0), (0.0, 1.0)]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_bounds()</span>
<span class="sd">        [(0.0, 1.0), (0.0, 1.0), (0.0, 1.0), (0.0, 1.0)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getbds</span><span class="p">(</span><span class="n">which</span><span class="p">):</span>
            <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getfilter_constant</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getbds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.get_num_nonzeros">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.get_num_nonzeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_nonzeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of variables specified by a set of filters.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&#39;x&#39;, &#39;y&#39;], types=[&quot;BB&quot;])</span>
<span class="sd">        &gt;&gt;&gt; f = cplex.SparsePair(ind=[&#39;x&#39;], val=[1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_diversity_filter(</span>
<span class="sd">        ...      0, 1, f, [1], &quot;div{0}&quot;.format(i)) for i in range(2)]</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...      0, 1, f, &quot;rng{0}&quot;.format(i)) for i in range(2)]</span>
<span class="sd">        [2, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_num_nonzeros(0)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_num_nonzeros(&quot;rng0&quot;)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_num_nonzeros([&quot;div0&quot;, 2])</span>
<span class="sd">        [1, 1]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_num_nonzeros()</span>
<span class="sd">        [1, 1, 1, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getnnz</span><span class="p">(</span><span class="n">which</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getfilter_constant</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nnz</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getnnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes filters from the problem.</span>

<span class="sd">        There are four forms by which filters.delete may be called.</span>

<span class="sd">        filters.delete()</span>
<span class="sd">          deletes all filters from the problem.</span>

<span class="sd">        filters.delete(i)</span>
<span class="sd">          i must be a filter name or index. Deletes the filter whose</span>
<span class="sd">          index or name is i.</span>

<span class="sd">        filters.delete(s)</span>
<span class="sd">          s must be a sequence of filter names or indices. Deletes</span>
<span class="sd">          the filters with names or indices contained within s.</span>
<span class="sd">          Equivalent to [filters.delete(i) for i in s].</span>

<span class="sd">        filters.delete(begin, end)</span>
<span class="sd">          begin and end must be filter indices or filter names. Deletes</span>
<span class="sd">          the filters with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to filters.delete(range(begin, end + 1)). This</span>
<span class="sd">          will give the best performance when deleting batches of</span>
<span class="sd">          filters.</span>

<span class="sd">        See `CPXdelsolnpoolfilters &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/delsolnpoolfilters.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names=[&#39;x&#39;, &#39;y&#39;], types=[&#39;II&#39;])</span>
<span class="sd">        &gt;&gt;&gt; f = cplex.SparsePair(ind=[&#39;x&#39;], val=[1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...      0.0, 1.0, f, str(i)) for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_num()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.delete(8)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.delete(&#39;1&#39;, 3)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.delete([2, &#39;0&#39;, 5])</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names()</span>
<span class="sd">        [&#39;4&#39;, &#39;6&#39;, &#39;7&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delsolnpoolfilters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                        <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.get_types">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.get_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the types of a set of filters.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&#39;x&#39;,&#39;y&#39;], types = [&quot;II&quot;])</span>
<span class="sd">        &gt;&gt;&gt; f = cplex.SparsePair(ind = [&#39;x&#39;],val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...      0.0, 1.0, f, str(i)) for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_types(3)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_types(&quot;5&quot;)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_types([2, &quot;8&quot;])</span>
<span class="sd">        [2, 2]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_types()</span>
<span class="sd">        [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">gettype</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolfiltertype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">gettype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of filters, given their indices.</span>

<span class="sd">        There are four forms by which solution.pool.filter.get_names may be called.</span>

<span class="sd">        solution.pool.filter.get_names()</span>
<span class="sd">          return the names of all solution pool filters from the problem.</span>

<span class="sd">        solution.pool.filter.get_names(i)</span>
<span class="sd">          i must be a solution filter index.  Returns the name of row i.</span>

<span class="sd">        solution.pool.filter.get_names(s)</span>
<span class="sd">          s must be a sequence of row indices.  Returns the names of</span>
<span class="sd">          the solution pool filters with indices the members of s.</span>
<span class="sd">          Equivalent to [solution.pool.filter.get_names(i) for i in s]</span>

<span class="sd">        solution.pool.filter.get_names(begin, end)</span>
<span class="sd">          begin and end must be solution filter indices. Returns the</span>
<span class="sd">          names of the solution pool filter with indices between begin</span>
<span class="sd">          and end, inclusive of end. Equivalent to</span>
<span class="sd">          solution.pool.filter.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(names = [&#39;x&#39;,&#39;y&#39;], types = [&quot;II&quot;])</span>
<span class="sd">        &gt;&gt;&gt; f = cplex.SparsePair(ind = [&#39;x&#39;],val = [1.0])</span>
<span class="sd">        &gt;&gt;&gt; [c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...      0.0, 1.0, f, str(i)) for i in range(10)]</span>
<span class="sd">        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names()</span>
<span class="sd">        [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names(6)</span>
<span class="sd">        &#39;6&#39;</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names([5, 3])</span>
<span class="sd">        [&#39;5&#39;, &#39;3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_names(3, 5)</span>
<span class="sd">        [&#39;3&#39;, &#39;4&#39;, &#39;5&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolfiltername</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the filters to a file.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...     300, 600, [[&#39;x1&#39;,&#39;x2&#39;], [1,1]], &quot;&quot;)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.write(&quot;ind.flt&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">fltwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.read">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads filters from a file.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...     300, 600, [[&#39;x1&#39;,&#39;x2&#39;], [1,1]], &quot;&quot;)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.write(&quot;ind.flt&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.read(&quot;ind.flt&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">readcopysolnpoolfilters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                         <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolFilterInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolFilterInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of filters in the problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.add_range_filter(</span>
<span class="sd">        ...     300, 600, [[&#39;x1&#39;,&#39;x2&#39;], [1,1]], &quot;&quot;)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.filter.get_num()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolnumfilters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="QualityMetric">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QualityMetric">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QualityMetric</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Measures of solution quality.&quot;&quot;&quot;</span>
    <span class="n">max_primal_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_PRIMAL_INFEAS</span>
    <span class="n">max_scaled_primal_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_PRIMAL_INFEAS</span>
    <span class="n">sum_primal_infeasibilities</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_PRIMAL_INFEAS</span>
    <span class="n">sum_scaled_primal_infeasibilities</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_PRIMAL_INFEAS</span>
    <span class="n">max_dual_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_DUAL_INFEAS</span>
    <span class="n">max_scaled_dual_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_DUAL_INFEAS</span>
    <span class="n">sum_dual_infeasibilities</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_DUAL_INFEAS</span>
    <span class="n">sum_scaled_dual_infeasibilities</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_DUAL_INFEAS</span>
    <span class="n">max_int_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_INT_INFEAS</span>
    <span class="n">sum_integer_infeasibilities</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_INT_INFEAS</span>
    <span class="n">max_primal_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_PRIMAL_RESIDUAL</span>
    <span class="n">max_scaled_primal_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_PRIMAL_RESIDUAL</span>
    <span class="n">sum_primal_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_PRIMAL_RESIDUAL</span>
    <span class="n">sum_scaled_primal_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_PRIMAL_RESIDUAL</span>
    <span class="n">max_dual_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_DUAL_RESIDUAL</span>
    <span class="n">max_scaled_dual_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_DUAL_RESIDUAL</span>
    <span class="n">sum_dual_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_DUAL_RESIDUAL</span>
    <span class="n">sum_scaled_dual_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_DUAL_RESIDUAL</span>
    <span class="n">max_comp_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_COMP_SLACK</span>
    <span class="n">sum_comp_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_COMP_SLACK</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_X</span>
    <span class="n">max_scaled_x</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_X</span>
    <span class="n">max_pi</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_PI</span>
    <span class="n">max_scaled_pi</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_PI</span>
    <span class="n">max_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SLACK</span>
    <span class="n">max_scaled_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_SLACK</span>
    <span class="n">max_reduced_cost</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_RED_COST</span>
    <span class="n">max_scaled_reduced_cost</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_SCALED_RED_COST</span>
    <span class="n">sum_x</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_X</span>
    <span class="n">sum_scaled_x</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_X</span>
    <span class="n">sum_pi</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_PI</span>
    <span class="n">sum_scaled_pi</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_PI</span>
    <span class="n">sum_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SLACK</span>
    <span class="n">sum_scaled_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_SLACK</span>
    <span class="n">sum_reduced_cost</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_RED_COST</span>
    <span class="n">sum_scaled_reduced_cost</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_SCALED_RED_COST</span>
    <span class="n">kappa</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_KAPPA</span>
    <span class="n">objective_gap</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_OBJ_GAP</span>
    <span class="n">dual_objective</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_DUAL_OBJ</span>
    <span class="n">primal_objective</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PRIMAL_OBJ</span>
    <span class="n">max_quadratic_primal_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_QCPRIMAL_RESIDUAL</span>
    <span class="n">sum_quadratic_primal_residual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_QCPRIMAL_RESIDUAL</span>
    <span class="n">max_quadratic_slack_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_QCSLACK_INFEAS</span>
    <span class="n">sum_quadratic_slack_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_QCSLACK_INFEAS</span>
    <span class="n">max_quadratic_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_QCSLACK</span>
    <span class="n">sum_quadratic_slack</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_QCSLACK</span>
    <span class="n">max_indicator_slack_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_INDSLACK_INFEAS</span>
    <span class="n">sum_indicator_slack_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_INDSLACK_INFEAS</span>
    <span class="n">max_pwl_slack_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_MAX_PWLSLACK_INFEAS</span>
    <span class="n">sum_pwl_slack_infeasibility</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_SUM_PWLSLACK_INFEAS</span>
    <span class="n">exact_kappa</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_EXACT_KAPPA</span>
    <span class="n">kappa_stable</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_KAPPA_STABLE</span>
    <span class="n">kappa_suspicious</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_KAPPA_SUSPICIOUS</span>
    <span class="n">kappa_unstable</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_KAPPA_UNSTABLE</span>
    <span class="n">kappa_illposed</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_KAPPA_ILLPOSED</span>
    <span class="n">kappa_max</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_KAPPA_MAX</span>
    <span class="n">kappa_attention</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_KAPPA_ATTENTION</span></div>



<span class="nd">@contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_temp_results_stream</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">temp_stream</span><span class="p">):</span>
    <span class="n">old_results_stream</span> <span class="o">=</span> <span class="n">cpx</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_get_results_stream</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cpx</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">set_results_stream</span><span class="p">(</span><span class="n">temp_stream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">cpx</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">set_results_stream</span><span class="p">(</span><span class="n">old_results_stream</span><span class="o">.</span><span class="n">_file</span><span class="p">)</span>


<div class="viewcode-block" id="QualityMetrics">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QualityMetrics">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QualityMetrics</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class containing measures of the quality of a solution.</span>

<span class="sd">    The __str__ method of this class prints all available measures of</span>
<span class="sd">    the quality of the solution in human readable form.</span>

<span class="sd">    This class may have a different set of data members depending on</span>
<span class="sd">    the optimization algorithm used and the quality metrics that are</span>
<span class="sd">    available.</span>

<span class="sd">    An instance of this class always has the member quality_type,</span>
<span class="sd">    which is one of the following strings:</span>

<span class="sd">     * &quot;feasopt&quot;</span>
<span class="sd">     * &quot;simplex&quot;</span>
<span class="sd">     * &quot;quadratically_constrained&quot;</span>
<span class="sd">     * &quot;barrier&quot;</span>
<span class="sd">     * &quot;MIP&quot;</span>

<span class="sd">    If self.quality_type is &quot;feasopt&quot; this instance has the following</span>
<span class="sd">    members:</span>

<span class="sd">     * scaled</span>
<span class="sd">     * max_x</span>
<span class="sd">     * max_bound_infeas</span>
<span class="sd">     * max_Ax_minus_b</span>
<span class="sd">     * max_slack</span>

<span class="sd">    If self.scaled is 1, this instance also has the members:</span>

<span class="sd">     * max_scaled_x</span>
<span class="sd">     * max_scaled_bound_infeas</span>
<span class="sd">     * max_scaled_Ax_minus_b</span>
<span class="sd">     * max_scaled_slack</span>

<span class="sd">    If self.quality_type is &quot;simplex&quot; this instance has the following</span>
<span class="sd">    members:</span>

<span class="sd">     * scaled</span>
<span class="sd">     * max_x</span>
<span class="sd">     * max_pi</span>
<span class="sd">     * max_reduced_cost</span>
<span class="sd">     * max_bound_infeas</span>
<span class="sd">     * max_reduced_cost_infeas</span>
<span class="sd">     * max_Ax_minus_b</span>
<span class="sd">     * max_c_minus_Bpi</span>
<span class="sd">     * max_slack</span>

<span class="sd">    If self.scaled is 1, this instance also has the members:</span>

<span class="sd">     * max_scaled_x</span>
<span class="sd">     * max_scaled_pi</span>
<span class="sd">     * max_scaled_reduced_cost</span>
<span class="sd">     * max_scaled_bound_infeas</span>
<span class="sd">     * max_scaled_reduced_cost_infeas</span>
<span class="sd">     * max_scaled_Ax_minus_b</span>
<span class="sd">     * max_scaled_c_minus_Bpi</span>
<span class="sd">     * max_scaled_slack</span>

<span class="sd">    If the condition number of the final basis is available, this</span>
<span class="sd">    instance has the member:</span>

<span class="sd">     * kappa</span>

<span class="sd">    If self.quality_type is &quot;quadratically_constrained&quot; this instance</span>
<span class="sd">    has the following members:</span>

<span class="sd">     * objective</span>
<span class="sd">     * norm_total</span>
<span class="sd">     * norm_max</span>
<span class="sd">     * error_Ax_b_total</span>
<span class="sd">     * error_Ax_b_max</span>
<span class="sd">     * error_xQx_dx_f_total</span>
<span class="sd">     * error_xQx_dx_f_max</span>
<span class="sd">     * x_bound_error_total</span>
<span class="sd">     * x_bound_error_max</span>
<span class="sd">     * slack_bound_error_total</span>
<span class="sd">     * slack_bound_error_max</span>
<span class="sd">     * quadratic_slack_bound_error_total</span>
<span class="sd">     * quadratic_slack_bound_error_max</span>
<span class="sd">     * normalized_error_max</span>

<span class="sd">    If self.quality_type is &quot;barrier&quot; this instance has the following</span>
<span class="sd">    members:</span>

<span class="sd">     * primal_objective</span>
<span class="sd">     * dual_objective</span>
<span class="sd">     * duality_gap</span>
<span class="sd">     * complementarity_total</span>
<span class="sd">     * column_complementarity_total</span>
<span class="sd">     * column_complementarity_max</span>
<span class="sd">     * row_complementarity_total</span>
<span class="sd">     * row_complementarity_max</span>
<span class="sd">     * primal_norm_total</span>
<span class="sd">     * primal_norm_max</span>
<span class="sd">     * dual_norm_total</span>
<span class="sd">     * dual_norm_max</span>
<span class="sd">     * primal_error_total</span>
<span class="sd">     * primal_error_max</span>
<span class="sd">     * dual_error_total</span>
<span class="sd">     * dual_error_max</span>
<span class="sd">     * primal_x_bound_error_total</span>
<span class="sd">     * primal_x_bound_error_max</span>
<span class="sd">     * primal_slack_bound_error_total</span>
<span class="sd">     * primal_slack_bound_error_max</span>
<span class="sd">     * dual_pi_bound_error_total</span>
<span class="sd">     * dual_pi_bound_error_max</span>
<span class="sd">     * dual_reduced_cost_bound_error_total</span>
<span class="sd">     * dual_reduced_cost_bound_error_max</span>
<span class="sd">     * primal_normalized_error</span>
<span class="sd">     * dual_normalized_error</span>

<span class="sd">    If self.quality_type is &quot;MIP&quot; and this instance was generated for</span>
<span class="sd">    a specific member of the solution pool, it has the members:</span>

<span class="sd">     * solution_name</span>
<span class="sd">     * num_solutions</span>

<span class="sd">    If self.quality_type is &quot;MIP&quot;, this instance was not generated for</span>
<span class="sd">    a specific member of the solution pool, and kappa statistics are</span>
<span class="sd">    available, it has the members:</span>

<span class="sd">     * max_kappa</span>
<span class="sd">     * pct_kappa_stable</span>
<span class="sd">     * pct_kappa_suspicious</span>
<span class="sd">     * pct_kappa_unstable</span>
<span class="sd">     * pct_kappa_illposed</span>
<span class="sd">     * kappa_attention</span>

<span class="sd">    If self.quality_type is &quot;MIP&quot; and this instance was generated for</span>
<span class="sd">    the incumbent solution, it has the members:</span>

<span class="sd">     * solver</span>
<span class="sd">     * objective</span>
<span class="sd">     * x_norm_total</span>
<span class="sd">     * x_norm_max</span>
<span class="sd">     * error_Ax_b_total</span>
<span class="sd">     * error_Ax_b_max</span>
<span class="sd">     * x_bound_error_total</span>
<span class="sd">     * x_bound_error_max</span>
<span class="sd">     * integrality_error_total</span>
<span class="sd">     * integrality_error_max</span>
<span class="sd">     * slack_bound_error_total</span>
<span class="sd">     * slack_bound_error_max</span>

<span class="sd">    If in addition the problem this instance was generated for has</span>
<span class="sd">    indicator constraints, it has the members:</span>

<span class="sd">     * indicator_slack_bound_error_total</span>
<span class="sd">     * indicator_slack_bound_error_max</span>

<span class="sd">    if in addition the problem this instance was generated for has</span>
<span class="sd">    piecewise linear constraints, it has the members:</span>

<span class="sd">     * piecewise_linear_error_total</span>
<span class="sd">     * piecewise_linear_error_max</span>

<span class="sd">    If solver is &quot;MIQCP&quot; this instance also has the members:</span>

<span class="sd">     * error_xQx_dx_f_total</span>
<span class="sd">     * error_xQx_dx_f_max</span>
<span class="sd">     * quadratic_slack_bound_error_total</span>
<span class="sd">     * quadratic_slack_bound_error_max</span>

<span class="sd">    See also `SolutionInterface.get_quality_metrics` and</span>
<span class="sd">    `SolnPoolInterface.get_quality_metrics`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QualityMetrics.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QualityMetrics.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">soln</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">idata</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqualitymetrics</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">)</span>
        <span class="c1"># We get the &quot;to string&quot; from showquality by temporarily</span>
        <span class="c1"># hijacking the results stream.</span>
        <span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">StringIO</span><span class="p">())</span> <span class="k">as</span> <span class="n">output</span><span class="p">,</span> \
             <span class="n">_temp_results_stream</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>  <span class="c1"># noqa: E127</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">showquality</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tostring</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quality_type</span> <span class="o">=</span> <span class="s2">&quot;feasopt&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span> <span class="o">=</span> <span class="n">idata</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_bound_infeas</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_bound_infeas</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_bound_infeas</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_bound_infeas</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_Ax_minus_b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_Ax_minus_b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_Ax_minus_b</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_Ax_minus_b</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_slack</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_slack</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_slack</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_slack</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">idata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quality_type</span> <span class="o">=</span> <span class="s2">&quot;simplex&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span> <span class="o">=</span> <span class="n">idata</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_bound_infeas</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_bound_infeas</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_bound_infeas</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_bound_infeas</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_reduced_cost_infeas</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_reduced_cost_infeas</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_reduced_cost_infeas</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_reduced_cost_infeas</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_Ax_minus_b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_Ax_minus_b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_Ax_minus_b</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_Ax_minus_b</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_c_minus_Bpi</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_c_minus_Bpi</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_c_minus_Bpi</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_c_minus_Bpi</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_slack</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_slack</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_slack</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_slack</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_pi</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_pi</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_reduced_cost</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_scaled_reduced_cost</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">idata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quality_type</span> <span class="o">=</span> <span class="s2">&quot;quadratically_constrained&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_Ax_b_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_Ax_b_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_xQx_dx_f_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_xQx_dx_f_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slack_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slack_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_slack_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_slack_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalized_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">idata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quality_type</span> <span class="o">=</span> <span class="s2">&quot;barrier&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_objective</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_objective</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">duality_gap</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">complementarity_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_complementarity_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_complementarity_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_complementarity_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_complementarity_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_norm_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_norm_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_norm_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_norm_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_x_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_x_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_slack_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_slack_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_pi_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_pi_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_reduced_cost_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_reduced_cost_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primal_normalized_error</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dual_normalized_error</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">idata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quality_type</span> <span class="o">=</span> <span class="s2">&quot;MIP&quot;</span>
            <span class="k">if</span> <span class="n">soln</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solution_name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">get_names</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_solutions</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;MILP&quot;</span>
                <span class="k">elif</span> <span class="n">idata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;MIQP&quot;</span>
                <span class="k">elif</span> <span class="n">idata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;MIQCP&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error_xQx_dx_f_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error_xQx_dx_f_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_slack_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_slack_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_norm_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_norm_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error_Ax_b_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error_Ax_b_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">integrality_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">integrality_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">slack_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">slack_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indicator_slack_bound_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indicator_slack_bound_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">piecewise_linear_error_total</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">piecewise_linear_error_max</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idata</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_kappa</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pct_kappa_stable</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pct_kappa_suspicious</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pct_kappa_unstable</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pct_kappa_illposed</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kappa_attention</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span></div>


<div class="viewcode-block" id="QualityMetrics.__str__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.QualityMetrics.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string containing quality metrics in human readable form.&quot;&quot;&quot;</span>
        <span class="c1"># See __init__ (above) to see how this is constructed.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tostring</span></div>
</div>



<div class="viewcode-block" id="SolnPoolInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolnPoolInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for accessing the solution pool.&quot;&quot;&quot;</span>

    <span class="n">incumbent</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_INCUMBENT_ID</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `_constants.CPX_INCUMBENT_ID` &quot;&quot;&quot;</span>

    <span class="n">quality_metric</span> <span class="o">=</span> <span class="n">QualityMetric</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `QualityMetric()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SolnPoolInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new SolnPoolInterface.</span>

<span class="sd">        The solution pool interface is exposed by the top-level `Cplex`</span>
<span class="sd">        class as Cplex.solution.pool.  This constructor is not meant to</span>
<span class="sd">        be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">getindexfunc</span><span class="o">=</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolsolnindex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">SolnPoolFilterInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `SolnPoolFilterInterface()` &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_objective_value">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soln</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the objective value for a member of the solution pool.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; obj_val = c.solution.pool.get_objective_value(0)</span>
<span class="sd">        &gt;&gt;&gt; abs(obj_val - 499.0) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolobjval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_values">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the values of a set of variables for a given solution.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; v1 = c.solution.pool.get_values(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; v2 = c.solution.pool.get_values(1, &quot;x2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; somevals = c.solution.pool.get_values(1, [2, &quot;x2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; v1 == somevals[0], v2 == somevals[1]</span>
<span class="sd">        (True, True)</span>
<span class="sd">        &gt;&gt;&gt; allvals = c.solution.pool.get_values(1)</span>
<span class="sd">        &gt;&gt;&gt; v1 == allvals[2]</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_linear_slacks">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_linear_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of linear slacks for a given solution.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; s1 = c.solution.pool.get_linear_slacks(1, 1)</span>
<span class="sd">        &gt;&gt;&gt; s2 = c.solution.pool.get_linear_slacks(1, &quot;c2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; someslacks = c.solution.pool.get_linear_slacks(1, [1, &quot;c2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1 == someslacks[0], s2 == someslacks[1]</span>
<span class="sd">        (True, True)</span>
<span class="sd">        &gt;&gt;&gt; allslacks = c.solution.pool.get_linear_slacks(1)</span>
<span class="sd">        &gt;&gt;&gt; s1 == allslacks[1]</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getslacks</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolslack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslacks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_quadratic_slacks">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_quadratic_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of quadratic slacks for a given solution.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;miqcp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; var = c.solution.pool.get_quadratic_slacks(1, 1)</span>
<span class="sd">        &gt;&gt;&gt; var = c.solution.pool.get_quadratic_slacks(1, &quot;QC3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; vars = c.solution.pool.get_quadratic_slacks(1, [&quot;QC3&quot;, 1])</span>
<span class="sd">        &gt;&gt;&gt; vars = c.solution.pool.get_quadratic_slacks(1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">getqslacks</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolqconstrslack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getqslacks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_integer_quality">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_integer_quality">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integer_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the integer quality of a given solution.</span>

<span class="sd">        The integer quality of a solution can either be a single attribute of</span>
<span class="sd">        solution.pool.quality_metrics or a sequence of such</span>
<span class="sd">        attributes.</span>

<span class="sd">        Note</span>
<span class="sd">          This corresponds to the CPLEX callable library function</span>
<span class="sd">          CPXgetsolnpoolintquality.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; quality_metric = c.solution.pool.quality_metric</span>
<span class="sd">        &gt;&gt;&gt; misi = quality_metric.max_indicator_slack_infeasibility</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.get_integer_quality(1, misi)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolintquality</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolintquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">which</span><span class="p">]</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_float_quality">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_float_quality">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_float_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the float quality of a given solution.</span>

<span class="sd">        The float quality of a solution can either be a single attribute of</span>
<span class="sd">        solution.pool.quality_metrics or a sequence of such</span>
<span class="sd">        attributes.</span>

<span class="sd">        Note</span>
<span class="sd">          This corresponds to the CPLEX callable library function</span>
<span class="sd">          CPXgetsolnpooldblquality.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; qual = c.solution.pool.get_float_quality(1,</span>
<span class="sd">                                 c.solution.pool.quality_metric.max_indicator_slack_infeasibility)</span>
<span class="sd">        &gt;&gt;&gt; abs(qual) &lt; 1.e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpooldblquality</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpooldblquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">which</span><span class="p">]</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_mean_objective_value">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_mean_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_mean_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the average among the objective values in the solution pool.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; mov = c.solution.pool.get_mean_objective_value()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolmeanobjval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.delete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.delete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes solutions from the solution pool.</span>

<span class="sd">        There are four forms by which pool.delete may be called.</span>

<span class="sd">        pool.delete()</span>
<span class="sd">          deletes all solutions from the problem.</span>

<span class="sd">        pool.delete(i)</span>
<span class="sd">          i must be a solution name or index. Deletes the solution</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        pool.delete(s)</span>
<span class="sd">          s must be a sequence of solution names or indices. Deletes</span>
<span class="sd">          the solutions with names or indices contained within s.</span>
<span class="sd">          Equivalent to [pool.delete(i) for i in s].</span>

<span class="sd">        pool.delete(begin, end)</span>
<span class="sd">          begin and end must be solution indices or solution names.</span>
<span class="sd">          Deletes the solutions with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          pool.delete(range(begin, end + 1)). This will give the best</span>
<span class="sd">          performance when deleting batches of solutions from the</span>
<span class="sd">          solution pool.</span>

<span class="sd">        See `CPXdelsolnpoolsolns &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/delsolnpoolsolns.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.mip.limits.populate.set(5)</span>
<span class="sd">        &gt;&gt;&gt; c.populate_solution_pool()</span>
<span class="sd">        &gt;&gt;&gt; names = c.solution.pool.get_names()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.delete(1)</span>
<span class="sd">        &gt;&gt;&gt; n = c.solution.pool.get_names()</span>
<span class="sd">        &gt;&gt;&gt; del names[1]</span>
<span class="sd">        &gt;&gt;&gt; n == names</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.delete(names[1])</span>
<span class="sd">        &gt;&gt;&gt; n = c.solution.pool.get_names()</span>
<span class="sd">        &gt;&gt;&gt; names.remove(names[1])</span>
<span class="sd">        &gt;&gt;&gt; n == names</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.delete([names[1], 0])</span>
<span class="sd">        &gt;&gt;&gt; n = c.solution.pool.get_names()</span>
<span class="sd">        &gt;&gt;&gt; names.remove(names[1])</span>
<span class="sd">        &gt;&gt;&gt; del names[0]</span>
<span class="sd">        &gt;&gt;&gt; n == names</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.delete()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.get_names()</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_delete</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delsolnpoolsolns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                      <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">delete_set_by_range</span><span class="p">(</span><span class="n">_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names of a set of solutions.</span>

<span class="sd">        There are four forms by which solution.pool.get_names may be called.</span>

<span class="sd">        solution.pool.get_names()</span>
<span class="sd">          return the names of all solutions from the problem.</span>

<span class="sd">        solution.pool.get_names(i)</span>
<span class="sd">          i must be a solution index.  Returns the name of row i.</span>

<span class="sd">        solution.pool.get_names(s)</span>
<span class="sd">          s must be a sequence of row indices.  Returns the names of</span>
<span class="sd">          the solutions with indices the members of s.</span>
<span class="sd">          Equivalent to [solution.pool.get_names(i) for i in s]</span>

<span class="sd">        solution.pool.get_names(begin, end)</span>
<span class="sd">          begin and end must be solution indices. Returns the names of</span>
<span class="sd">          the solutions with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          solution.pool.get_names(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.mip.limits.populate.set(10)</span>
<span class="sd">        &gt;&gt;&gt; c.populate_solution_pool()</span>
<span class="sd">        &gt;&gt;&gt; names = c.solution.pool.get_names()</span>
<span class="sd">        &gt;&gt;&gt; names[1] == c.solution.pool.get_names(1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; [names[i] for i in [1,2]] == c.solution.pool.get_names([1,2])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; names[1:5] == c.solution.pool.get_names(1, 4)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getname</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolsolnname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                                <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_num_replaced">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_num_replaced">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_replaced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of solution pool members that have been replaced.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.get_num_replaced()</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolnumreplaced</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_num">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_num">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of solutions in the solution pool.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; num = c.solution.pool.get_num()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getsolnpoolnumsolns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes solutions to a file.</span>

<span class="sd">        If no second argument is provided, all solutions are written</span>
<span class="sd">        to file.</span>

<span class="sd">        If a second argument is provided, it is the index of a</span>
<span class="sd">        solution in the solution pool.  Only that solution will be</span>
<span class="sd">        written to file.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.mip.limits.populate.set(10)</span>
<span class="sd">        &gt;&gt;&gt; c.populate_solution_pool()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.pool.write(&quot;ind.sol&quot;,4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">solwritesolnpoolall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                         <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">solwritesolnpool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                      <span class="n">which</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolnPoolInterface.get_quality_metrics">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolnPoolInterface.get_quality_metrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quality_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soln</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object containing measures of the quality of the</span>
<span class="sd">        specified solution.</span>

<span class="sd">        See `QualityMetrics`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.randomseed.set(1)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; qm = c.solution.pool.get_quality_metrics(0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">QualityMetrics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">soln</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="AdvancedSolutionInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AdvancedSolutionInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Advanced methods for accessing solution information.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    &gt;&gt;&gt; import cplex</span>
<span class="sd">    &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">    &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">    &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">    &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">    &gt;&gt;&gt; c.solve()</span>
<span class="sd">    &gt;&gt;&gt; binvcol = c.solution.advanced.binvcol()</span>
<span class="sd">    &gt;&gt;&gt; binvrow = c.solution.advanced.binvrow()</span>
<span class="sd">    &gt;&gt;&gt; binvacol = c.solution.advanced.binvacol()</span>
<span class="sd">    &gt;&gt;&gt; binvarow = c.solution.advanced.binvarow()</span>
<span class="sd">    &gt;&gt;&gt; binvcol[0][24], binvcol[1][6]</span>
<span class="sd">    (-0.215, 1.0)</span>
<span class="sd">    &gt;&gt;&gt; binvrow[24][0], binvrow[6][1]</span>
<span class="sd">    (-0.215, 1.0)</span>
<span class="sd">    &gt;&gt;&gt; [x for i,x in enumerate(binvacol[0]) if i in range(0,3)], [x for i,x in enumerate(binvacol[1]) if i in range(0,3)]</span>
<span class="sd">    ([1.0, 0.0, 0.0], [0.0, 1.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; [x for i,x in enumerate(binvarow[0]) if i in range(0,2)], [x for i,x in enumerate(binvarow[1]) if i in range(0,2)], [x for i,x in enumerate(binvarow[2]) if i in range(0,2)]</span>
<span class="sd">    ([1.0, 0.0], [0.0, 1.0], [0.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; btran = c.solution.advanced.btran([1.0] * c.linear_constraints.get_num())</span>
<span class="sd">    &gt;&gt;&gt; bbtran = [x if x else 0.0 for i,x in enumerate(btran) if i in range(14,17)]</span>
<span class="sd">    &gt;&gt;&gt; [x if x else 0.0 for x in bbtran]</span>
<span class="sd">    [0.0, 2.0, 1.0]</span>
<span class="sd">    &gt;&gt;&gt; ftran = c.solution.advanced.ftran([1.0] * c.linear_constraints.get_num())</span>
<span class="sd">    &gt;&gt;&gt; ftran[0]</span>
<span class="sd">    2.891</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AdvancedSolutionInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new AdvancedSolutionInterface.</span>

<span class="sd">        The advanced solution interface is exposed by the top-level</span>
<span class="sd">        `Cplex` class as Cplex.solution.advanced.  This constructor is</span>
<span class="sd">        not meant to be used externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_cplex</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.binvcol">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.binvcol">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">binvcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of columns of the inverted basis matrix.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.advanced.binvcol()</span>
<span class="sd">          returns the inverted basis matrix as a list of columns.</span>

<span class="sd">        solution.advanced.binvcol(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          column of the inverted basis matrix associated with i.</span>

<span class="sd">        solution.advanced.binvcol(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the columns of the inverted basis matrix associated</span>
<span class="sd">          with the members of s.  Equivalent to</span>
<span class="sd">          [solution.advanced.binvcol(i) for i in s]</span>

<span class="sd">        solution.advanced.binvcol(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the columns of the inverted basis</span>
<span class="sd">          matrix associated with the linear constraints between begin</span>
<span class="sd">          and end, inclusive of end. Equivalent to</span>
<span class="sd">          solution.advanced.binvcol(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; binvcol = c.solution.advanced.binvcol()</span>
<span class="sd">        &gt;&gt;&gt; binvcol[0][24], binvcol[1][6]</span>
<span class="sd">        (-0.215, 1.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">binvcol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">inv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.binvrow">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.binvrow">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">binvrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of rows of the inverted basis matrix.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.advanced.binvrow()</span>
<span class="sd">          returns the inverted basis matrix as a list of rows.</span>

<span class="sd">        solution.advanced.binvrow(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          row of the inverted basis matrix associated with i.</span>

<span class="sd">        solution.advanced.binvrow(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the rows of the inverted basis matrix associated</span>
<span class="sd">          with the members of s.  Equivalent to</span>
<span class="sd">          [solution.advanced.binvrow(i) for i in s]</span>

<span class="sd">        solution.advanced.binvrow(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the rows of the inverted basis matrix</span>
<span class="sd">          associated with the linear constraints between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          solution.advanced.binvrow(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; binvrow = c.solution.advanced.binvrow()</span>
<span class="sd">        &gt;&gt;&gt; binvrow[24][0], binvrow[6][1]</span>
<span class="sd">        (-0.215, 1.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">binvrow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">inv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.binvacol">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.binvacol">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">binvacol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of columns of the tableau.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.advanced.binvacol()</span>
<span class="sd">          returns the tableau as a list of columns.</span>

<span class="sd">        solution.advanced.binvacol(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the column of</span>
<span class="sd">          the tableau associated with i.</span>

<span class="sd">        solution.advanced.binvacol(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the columns of the tableau associated with the members of s.</span>
<span class="sd">          Equivalent to [solution.advanced.binvacol(i) for i in s]</span>

<span class="sd">        solution.advanced.binvacol(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the columns of the tableau associated with the</span>
<span class="sd">          variables between begin and end, inclusive of end. Equivalent</span>
<span class="sd">          to solution.advanced.binvacol(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; binvacol = c.solution.advanced.binvacol()</span>
<span class="sd">        &gt;&gt;&gt; [x for i,x in enumerate(binvacol[0]) if i in range(0,3)], [x for i,x in enumerate(binvacol[1]) if i in range(0,3)]</span>
<span class="sd">        ([1.0, 0.0, 0.0], [0.0, 1.0, 0.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">binvacol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">inv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.binvarow">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.binvarow">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">binvarow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of rows of the tableau.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.advanced.binvacol()</span>
<span class="sd">          returns the tableau as a list of rows.</span>

<span class="sd">        solution.advanced.binvacol(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          row of the tableau associated with i.</span>

<span class="sd">        solution.advanced.binvacol(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the rows of the tableau associated with the members</span>
<span class="sd">          of s.  Equivalent to [solution.advanced.binvacol(i)</span>
<span class="sd">          for i in s]</span>

<span class="sd">        solution.advanced.binvacol(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or variable</span>
<span class="sd">          names. Returns the rows of the tableau associated with the</span>
<span class="sd">          variables between begin and end, inclusive of end. Equivalent</span>
<span class="sd">          to solution.advanced.binvacol(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; binvarow = c.solution.advanced.binvarow()</span>
<span class="sd">        &gt;&gt;&gt; [x for i,x in enumerate(binvarow[0]) if i in range(0,2)], [x for i,x in enumerate(binvarow[1]) if i in range(0,2)], [x for i,x in enumerate(binvarow[2]) if i in range(0,2)]</span>
<span class="sd">        ([1.0, 0.0], [0.0, 1.0], [0.0, 0.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">binvarow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">inv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.btran">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.btran">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">btran</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a backward linear solve using the basis matrix.</span>

<span class="sd">        Returns the solution to the linear system</span>

<span class="sd">        x^T B = y^T</span>

<span class="sd">        y must be a list of floats with length equal to the number of</span>
<span class="sd">        linear constraints.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; btran = c.solution.advanced.btran([1.0] * c.linear_constraints.get_num())</span>
<span class="sd">        &gt;&gt;&gt; bbtran = [x if x else 0.0 for i,x in enumerate(btran) if i in range(14,17)]</span>
<span class="sd">        &gt;&gt;&gt; [x if x else 0.0 for x in bbtran]</span>
<span class="sd">        [0.0, 2.0, 1.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">btran</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.ftran">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.ftran">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ftran</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a linear solve using the basis matrix.</span>

<span class="sd">        Returns the solution to the linear system</span>

<span class="sd">        B x = y</span>

<span class="sd">        y must be a list of floats with length equal to the number of</span>
<span class="sd">        linear constraints.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; ftran = c.solution.advanced.ftran([1.0] * c.linear_constraints.get_num())</span>
<span class="sd">        &gt;&gt;&gt; ftran[0]</span>
<span class="sd">        2.891</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">ftran</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_gradients">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_gradients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns information useful in post-solution analysis after an</span>
<span class="sd">        LP has been solved and a basis is available.</span>

<span class="sd">        See `CPXgetgrad &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/getgrad.html&gt;`_ in the Callable Library Reference Manual</span>
<span class="sd">        for more detail.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; grad = c.solution.advanced.get_gradients(1)</span>
<span class="sd">        &gt;&gt;&gt; grad.ind[1]</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; grad.val[1]</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getgrad</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SparsePair</span><span class="p">(</span><span class="o">*</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getgrad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getgrad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">(),</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_linear_slacks_from_x">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_linear_slacks_from_x">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_slacks_from_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the slack values from the given solution x</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; slack = c.solution.advanced.get_linear_slacks_from_x(c.solution.get_values())</span>
<span class="sd">        &gt;&gt;&gt; abs(slack[3]) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">slackfromx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_quadratic_slacks_from_x">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_quadratic_slacks_from_x">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_slacks_from_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the slack values for quadratic constraints from the given solution x</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;qcp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; qslack = c.solution.advanced.get_quadratic_slacks_from_x(c.solution.get_values())</span>
<span class="sd">        &gt;&gt;&gt; abs(qslack[0]) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">qconstrslackfromx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_linear_reduced_costs_from_pi">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_linear_reduced_costs_from_pi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_reduced_costs_from_pi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pi</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the reduced costs from the given dual solution pi</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; reducedcost = c.solution.advanced.get_linear_reduced_costs_from_pi(</span>
<span class="sd">                                                                    c.solution.get_dual_values())</span>
<span class="sd">        &gt;&gt;&gt; abs(reducedcost[0]) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">djfrompi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_quadratic_reduced_costs_from_pi">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_quadratic_reduced_costs_from_pi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_reduced_costs_from_pi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the reduced costs for QP from the given solution (pi, x)</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;qp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; qreducedcost = c.solution.advanced.get_quadratic_reduced_costs_from_pi(</span>
<span class="sd">                                                                    c.solution.get_dual_values(),</span>
<span class="sd">                                                                    c.solution.get_values())</span>
<span class="sd">        &gt;&gt;&gt; abs(qreducedcost[0]) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">qpdjfrompi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_Driebeek_penalties">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_Driebeek_penalties">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_Driebeek_penalties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basic_variables</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns values known as Driebeek penalties for a sequence of basic variables.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c_stat, _ = c.solution.basis.get_basis()</span>
<span class="sd">        &gt;&gt;&gt; b = [i for i, v in enumerate(c_stat) if v == c.solution.basis.status.basic]</span>
<span class="sd">        &gt;&gt;&gt; penalties = c.solution.advanced.get_Driebeek_penalties(b)</span>
<span class="sd">        &gt;&gt;&gt; penalties[0]</span>
<span class="sd">        (0.34477142857142856, 8.021494102228047)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">mdleave</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">basic_variables</span><span class="p">)))</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_quadratic_indefinite_certificate">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_quadratic_indefinite_certificate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_indefinite_certificate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a vector x that satisfies x&#39;Qx &lt; 0</span>

<span class="sd">        Such a vector demonstrates that the matrix Q violates the</span>
<span class="sd">        assumption of positive semi-definiteness, and can be an aid in</span>
<span class="sd">        debugging a user&#39;s program if indefiniteness is an unexpected</span>
<span class="sd">        outcome.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;qpindef.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; x = c.solution.advanced.get_quadratic_indefinite_certificate()</span>
<span class="sd">        &gt;&gt;&gt; abs(-0.5547001 - x[1]) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">qpindefcertificate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.dual_farkas">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.dual_farkas">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dual_farkas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns Farkas proof of infeasibility for the active LP model after proven infeasibility.</span>

<span class="sd">        See `CPXdualfarkas &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/dualfarkas.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual for more detail.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(senses=&quot;L&quot;, rhs=[-1])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(lb=[1], ub=[2],columns=[[[0],[1]]])</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.preprocessing.presolve.set(c.parameters.preprocessing.presolve.values.off)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; y = c.solution.advanced.dual_farkas()</span>
<span class="sd">        &gt;&gt;&gt; y[1]</span>
<span class="sd">        2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">dualfarkas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_diverging_index">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_diverging_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_diverging_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the index of the diverging row or column</span>

<span class="sd">        if the problem is not unbounded, get_diverging_index returns -1.</span>

<span class="sd">        If the problem is unbounded, get_diverging_index returns the</span>
<span class="sd">        index of the diverging variable in the augmented form of the</span>
<span class="sd">        constraint matrix.  In other words, if the diverging variable</span>
<span class="sd">        is a structural variable, get_diverging_index returns its</span>
<span class="sd">        index; if the diverging variable is a slack or ranged</span>
<span class="sd">        variable, get_diverging_index returns the sum of the number of</span>
<span class="sd">        structural variables and the index of the corresponding</span>
<span class="sd">        constraint.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(obj=[1,1],lb=[1,-cplex.infinity],ub=[2,cplex.infinity])</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.primal)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.preprocessing.presolve.set(c.parameters.preprocessing.presolve.values.off)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; idx = c.solution.advanced.get_diverging_index()</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(obj=[-1,-1],lb=[1,1],ub=[2,2])</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(lin_expr = [[[0,1],[-1,-1]]], rhs=[-10], senses=&quot;L&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.lpmethod.set(c.parameters.lpmethod.values.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.preprocessing.presolve.set(c.parameters.preprocessing.presolve.values.off)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; idx = c.solution.advanced.get_diverging_index()</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getijdiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedSolutionInterface.get_ray">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedSolutionInterface.get_ray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an unbounded direction, i.e., ray, if a LP model is unbounded</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;unblp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.parameters.preprocessing.presolve.set(c.parameters.preprocessing.presolve.values.off)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; ray = c.solution.advanced.get_ray()</span>
<span class="sd">        &gt;&gt;&gt; ray[0]</span>
<span class="sd">        -1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SolutionMethod">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionMethod">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolutionMethod</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solution methods.&quot;&quot;&quot;</span>
    <span class="n">none</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_NONE</span>
    <span class="n">primal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_PRIMAL</span>
    <span class="n">dual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_DUAL</span>
    <span class="n">barrier</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_BARRIER</span>
    <span class="n">feasopt</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_FEASOPT</span>
    <span class="n">MIP</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_MIP</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_PIVOT</span>
    <span class="n">pivot_in</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_PIVOTIN</span>
    <span class="n">pivot_out</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_PIVOTOUT</span></div>



<div class="viewcode-block" id="SolutionStatus">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolutionStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solution status codes.</span>

<span class="sd">    For documentation of each status code, see the reference manual</span>
<span class="sd">    of the CPLEX Callable Library, especially the group</span>
<span class="sd">    optim.cplex.callable.solutionstatus.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># There is no constant for this.</span>
    <span class="n">optimal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_OPTIMAL</span>
    <span class="n">unbounded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_UNBOUNDED</span>
    <span class="n">infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_INFEASIBLE</span>
    <span class="n">feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_FEASIBLE</span>
    <span class="n">infeasible_or_unbounded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_INForUNBD</span>
    <span class="n">optimal_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_OPTIMAL_INFEAS</span>
    <span class="n">num_best</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_NUM_BEST</span>
    <span class="n">feasible_relaxed_sum</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_FEASIBLE_RELAXED_SUM</span>
    <span class="n">optimal_relaxed_sum</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_OPTIMAL_RELAXED_SUM</span>
    <span class="n">feasible_relaxed_inf</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_FEASIBLE_RELAXED_INF</span>
    <span class="n">optimal_relaxed_inf</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_OPTIMAL_RELAXED_INF</span>
    <span class="n">feasible_relaxed_quad</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_FEASIBLE_RELAXED_QUAD</span>
    <span class="n">optimal_relaxed_quad</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_OPTIMAL_RELAXED_QUAD</span>
    <span class="n">abort_obj_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_ABORT_OBJ_LIM</span>
    <span class="n">abort_primal_obj_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_ABORT_PRIM_OBJ_LIM</span>
    <span class="n">abort_dual_obj_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_ABORT_DUAL_OBJ_LIM</span>
    <span class="n">first_order</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_FIRSTORDER</span>
    <span class="n">abort_iteration_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_ABORT_IT_LIM</span>
    <span class="n">abort_time_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_ABORT_TIME_LIM</span>
    <span class="n">abort_dettime_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_ABORT_DETTIME_LIM</span>
    <span class="n">abort_user</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_ABORT_USER</span>
    <span class="n">optimal_face_unbounded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_OPTIMAL_FACE_UNBOUNDED</span>
    <span class="n">conflict_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_FEASIBLE</span>
    <span class="n">conflict_minimal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_MINIMAL</span>
    <span class="n">conflict_abort_contradiction</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_CONTRADICTION</span>
    <span class="n">conflict_abort_time_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_TIME_LIM</span>
    <span class="n">conflict_abort_dettime_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_DETTIME_LIM</span>
    <span class="n">conflict_abort_iteration_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_IT_LIM</span>
    <span class="n">conflict_abort_node_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_NODE_LIM</span>
    <span class="n">conflict_abort_obj_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_OBJ_LIM</span>
    <span class="n">conflict_abort_memory_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_MEM_LIM</span>
    <span class="n">conflict_abort_user</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_CONFLICT_ABORT_USER</span>
    <span class="n">relaxation_unbounded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_ABORT_RELAXATION_UNBOUNDED</span>
    <span class="n">abort_relaxed</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_ABORT_RELAXED</span>
    <span class="n">optimal_tolerance</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL_TOL</span>
    <span class="n">solution_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_SOL_LIM</span>
    <span class="n">populate_solution_limit</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_POPULATESOL_LIM</span>
    <span class="n">node_limit_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_NODE_LIM_FEAS</span>
    <span class="n">node_limit_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_NODE_LIM_INFEAS</span>
    <span class="n">fail_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FAIL_FEAS</span>
    <span class="n">fail_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FAIL_INFEAS</span>
    <span class="n">mem_limit_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_MEM_LIM_FEAS</span>
    <span class="n">mem_limit_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_MEM_LIM_INFEAS</span>
    <span class="n">fail_feasible_no_tree</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FAIL_FEAS_NO_TREE</span>
    <span class="n">fail_infeasible_no_tree</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FAIL_INFEAS_NO_TREE</span>
    <span class="n">optimal_populated</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL_POPULATED</span>
    <span class="n">optimal_populated_tolerance</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL_POPULATED_TOL</span>
    <span class="n">benders_num_best</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_BENDERS_NUM_BEST</span>

    <span class="n">MIP_optimal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL</span>
    <span class="n">MIP_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_INFEASIBLE</span>
    <span class="n">MIP_time_limit_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_TIME_LIM_FEAS</span>
    <span class="n">MIP_time_limit_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_TIME_LIM_INFEAS</span>
    <span class="n">MIP_dettime_limit_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_DETTIME_LIM_FEAS</span>
    <span class="n">MIP_dettime_limit_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_DETTIME_LIM_INFEAS</span>
    <span class="n">MIP_abort_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_ABORT_FEAS</span>
    <span class="n">MIP_abort_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_ABORT_INFEAS</span>
    <span class="n">MIP_optimal_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL_INFEAS</span>
    <span class="n">MIP_unbounded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_UNBOUNDED</span>
    <span class="n">MIP_infeasible_or_unbounded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_INForUNBD</span>
    <span class="n">MIP_feasible_relaxed_sum</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FEASIBLE_RELAXED_SUM</span>
    <span class="n">MIP_optimal_relaxed_sum</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL_RELAXED_SUM</span>
    <span class="n">MIP_feasible_relaxed_inf</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FEASIBLE_RELAXED_INF</span>
    <span class="n">MIP_optimal_relaxed_inf</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL_RELAXED_INF</span>
    <span class="n">MIP_feasible_relaxed_quad</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FEASIBLE_RELAXED_QUAD</span>
    <span class="n">MIP_optimal_relaxed_quad</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_OPTIMAL_RELAXED_QUAD</span>
    <span class="n">MIP_feasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPXMIP_FEASIBLE</span>

    <span class="n">multiobj_optimal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_MULTIOBJ_OPTIMAL</span>
    <span class="n">multiobj_infeasible</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_MULTIOBJ_INFEASIBLE</span>
    <span class="n">multiobj_inforunbd</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_MULTIOBJ_INForUNBD</span>
    <span class="n">multiobj_non_optimal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_MULTIOBJ_NON_OPTIMAL</span>
    <span class="n">multiobj_stopped</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_MULTIOBJ_STOPPED</span>
    <span class="n">multiobj_unbounded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_STAT_MULTIOBJ_UNBOUNDED</span></div>



<div class="viewcode-block" id="SolutionType">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolutionType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solution types&quot;&quot;&quot;</span>
    <span class="n">none</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_NO_SOLN</span>
    <span class="n">basic</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_BASIC_SOLN</span>
    <span class="n">nonbasic</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_NONBASIC_SOLN</span>
    <span class="n">primal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PRIMAL_SOLN</span></div>



<div class="viewcode-block" id="SolutionInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SolutionInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for querying the solution to an optimization problem.&quot;&quot;&quot;</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">SolutionMethod</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `SolutionMethod()` &quot;&quot;&quot;</span>
    <span class="n">quality_metric</span> <span class="o">=</span> <span class="n">QualityMetric</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `QualityMetric()` &quot;&quot;&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">SolutionStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `SolutionStatus()` &quot;&quot;&quot;</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">SolutionType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `SolutionType()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SolutionInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new SolutionInterface.</span>

<span class="sd">        The solution interface is exposed by the top-level `Cplex` class</span>
<span class="sd">        as Cplex.solution.  This constructor is not meant to be used</span>
<span class="sd">        externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `ProgressInterface()` &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infeasibility</span> <span class="o">=</span> <span class="n">InfeasibilityInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `InfeasibilityInterface()` &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MIP</span> <span class="o">=</span> <span class="n">MIPSolutionInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `MIPSolutionInterface()` &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">BasisInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `BasisInterface()` &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensitivity</span> <span class="o">=</span> <span class="n">SensitivityInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `SensitivityInterface()` &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">SolnPoolInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `SolnPoolInterface()` &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">advanced</span> <span class="o">=</span> <span class="n">AdvancedSolutionInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `AdvancedSolutionInterface()` &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiobj</span> <span class="o">=</span> <span class="n">MultiObjSolnInterface</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `MultiObjSolnInterface()` &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="SolutionInterface.get_status">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of the solution.</span>

<span class="sd">        Returns an attribute of Cplex.solution.status.</span>
<span class="sd">        For interpretations of the status codes, see the</span>
<span class="sd">        reference manual of the CPLEX Callable Library,</span>
<span class="sd">        especially the group optim.cplex.callable.solutionstatus</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_status()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getstat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_method">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_method">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the method used to solve the problem.</span>

<span class="sd">        Returns an attribute of Cplex.solution.method.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_method()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getmethod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_status_string">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_status_string">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_status_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status_code</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string describing the status of the solution.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_status_string()</span>
<span class="sd">        &#39;optimal&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">status_code</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getstatstring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="n">status_code</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_objective_value">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_objective_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_objective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the value of the objective function.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_objective_value()</span>
<span class="sd">        -202.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getobjval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_values">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the values of a set of variables at the solution.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_values()</span>
<span class="sd">          return the values of all variables from the problem.</span>

<span class="sd">        solution.get_values(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the value of</span>
<span class="sd">          the variable whose index or name is i.</span>

<span class="sd">        solution.get_values(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the values of the variables with indices the members of s.</span>
<span class="sd">          Equivalent to [solution.get_values(i) for i in s]</span>

<span class="sd">        solution.get_values(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the values of the variables with indices between begin</span>
<span class="sd">          and end, inclusive of end. Equivalent to</span>
<span class="sd">          solution.get_values(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_values([0, 4, 5])</span>
<span class="sd">        [25.5, 0.0, 80.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_reduced_costs">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_reduced_costs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_reduced_costs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the reduced costs of a set of variables.</span>

<span class="sd">        The values returned by this method are defined to be the dual</span>
<span class="sd">        multipliers for bound constraints on the specified variables.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_reduced_costs()</span>
<span class="sd">          return the reduced costs of all variables from the problem.</span>

<span class="sd">        solution.get_reduced_costs(i)</span>
<span class="sd">          i must be a variable name or index.  Returns the reduced</span>
<span class="sd">          cost of the variable whose index or name is i.</span>

<span class="sd">        solution.get_reduced_costs(s)</span>
<span class="sd">          s must be a sequence of variable names or indices.  Returns</span>
<span class="sd">          the reduced costs of the variables with indices the members</span>
<span class="sd">          of s.  Equivalent to [solution.get_reduced_costs(i) for i</span>
<span class="sd">          in s]</span>

<span class="sd">        solution.get_reduced_costs(begin, end)</span>
<span class="sd">          begin and end must be variable indices or variable names.</span>
<span class="sd">          Returns the reduced costs of the variables with indices between</span>
<span class="sd">          begin and end, inclusive of end. Equivalent to</span>
<span class="sd">          solution.get_reduced_costs(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_reduced_costs([0, 4, 5])</span>
<span class="sd">        [0.0, 10.0, 0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getdj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getdj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getdj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_dual_values">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_dual_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dual_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of dual values.</span>

<span class="sd">        Note that the values returned by this function are not only</span>
<span class="sd">        meaningful for linear programs. Also for second order cone</span>
<span class="sd">        programs, they provide information about the dual solution.</span>
<span class="sd">        Refer to the user manual to see how to use the values returned by</span>
<span class="sd">        this function for second order cone programs.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_dual_values()</span>
<span class="sd">          return all dual values from the problem.</span>

<span class="sd">        solution.get_dual_values(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          dual value associated with the linear constraint whose</span>
<span class="sd">          index or name is i.</span>

<span class="sd">        solution.get_dual_values(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the dual values associated with the linear</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [solution.get_dual_values(i) for i in s]</span>

<span class="sd">        solution.get_dual_values(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the dual values associated with the</span>
<span class="sd">          linear constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          solution.get_dual_values(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; pi = c.solution.get_dual_values([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; for i, j in zip(pi, [-0.628571, 0.0]):</span>
<span class="sd">        ...     abs(i - j) &lt; 1e-6</span>
<span class="sd">        ...</span>
<span class="sd">        True</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getpi</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getpi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getpi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_quadratic_dualslack">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_quadratic_dualslack">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_dualslack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the dual slack for a quadratic constraint.</span>

<span class="sd">        The function returns the dual slack vector of its arguments as a</span>
<span class="sd">        SparsePair.</span>
<span class="sd">        The function argument may be either the index or the name of a</span>
<span class="sd">        quadratic constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getqconstrdslack</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstrdslack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SparsePair</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">SparsePair</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">apply_freeform_one_arg</span><span class="p">(</span>
            <span class="n">getqconstrdslack</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span>
            <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getnumqconstrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">),</span>
            <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_linear_slacks">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_linear_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_linear_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of linear slacks.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_linear_slacks()</span>
<span class="sd">          return all linear slack values from the problem.</span>

<span class="sd">        solution.get_linear_slacks(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          slack values associated with the linear constraint whose</span>
<span class="sd">          index or name is i.</span>

<span class="sd">        solution.get_linear_slacks(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the slack values associated with the linear</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [solution.get_linear_slacks(i) for i in s]</span>

<span class="sd">        solution.get_linear_slacks(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the slack values associated with the</span>
<span class="sd">          linear constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          solution.get_linear_slacks(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; abs(c.solution.get_linear_slacks(5)) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getslack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_indicator_slacks">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_indicator_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_indicator_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of indicator slacks.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_indicator_slacks()</span>
<span class="sd">          return all indicator slack values from the problem.</span>

<span class="sd">        solution.get_indicator_slacks(i)</span>
<span class="sd">          i must be a indicator constraint name or index.  Returns</span>
<span class="sd">          the slack values associated with the indicator constraint</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        solution.get_indicator_slacks(s)</span>
<span class="sd">          s must be a sequence of indicator constraint names or</span>
<span class="sd">          indices.  Returns the slack values associated with the</span>
<span class="sd">          indicator constraints with indices the members of s.</span>
<span class="sd">          Equivalent to [solution.get_indicator_slacks(i) for i in s]</span>

<span class="sd">        solution.get_indicator_slacks(begin, end)</span>
<span class="sd">          begin and end must be indicator constraint indices or indicator</span>
<span class="sd">          constraint names. Returns the slack values associated with the</span>
<span class="sd">          indicator constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          solution.get_indicator_slacks(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;ind.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_indicator_slacks([0, 18])</span>
<span class="sd">        [1e+20, 0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getindslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">indicator_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getindconstrslack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getindslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">indicator_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span>
            <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_quadratic_slacks">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_quadratic_slacks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_slacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a set of quadratic slacks.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_quadratic_slacks()</span>
<span class="sd">          return all quadratic slack values from the problem.</span>

<span class="sd">        solution.get_quadratic_slacks(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns</span>
<span class="sd">          the slack values associated with the quadratic constraint</span>
<span class="sd">          whose index or name is i.</span>

<span class="sd">        solution.get_quadratic_slacks(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the slack values associated with the</span>
<span class="sd">          quadratic constraints with indices the members of s.</span>
<span class="sd">          Equivalent to [solution.get_quadratic_slacks(i) for i in s]</span>

<span class="sd">        solution.get_quadratic_slacks(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the slack values associated with the</span>
<span class="sd">          quadratic constraints with indices between begin and end,</span>
<span class="sd">          inclusive of end. Equivalent to</span>
<span class="sd">          solution.get_quadratic_slacks(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;qcp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; slack = c.solution.get_quadratic_slacks(0)</span>
<span class="sd">        &gt;&gt;&gt; abs(slack) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getqslack</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getqconstrslack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getqslack</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_integer_quality">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_integer_quality">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integer_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a measure of the quality of the solution.</span>

<span class="sd">        The measure of the quality of a solution can be a single attribute of</span>
<span class="sd">        solution.quality_metrics or a sequence of such</span>
<span class="sd">        attributes.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; m = c.solution.quality_metric</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_integer_quality([m.max_x, m.max_dual_infeasibility])</span>
<span class="sd">        [18, -1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getintquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getintquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">which</span><span class="p">]</span></div>


<div class="viewcode-block" id="SolutionInterface.get_float_quality">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_float_quality">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_float_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a measure of the quality of the solution.</span>

<span class="sd">        The measure of the quality of a solution can be a single attribute of</span>
<span class="sd">        solution.quality_metrics or a sequence of such attributes.</span>

<span class="sd">        Note</span>
<span class="sd">          This corresponds to the CPLEX callable library function</span>
<span class="sd">          CPXgetdblquality.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; m = c.solution.quality_metric</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_float_quality([m.max_x, m.max_dual_infeasibility])</span>
<span class="sd">        [500.0, 0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getdblquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getdblquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">which</span><span class="p">]</span></div>


<div class="viewcode-block" id="SolutionInterface.get_solution_type">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_solution_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_solution_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the type of the solution.</span>

<span class="sd">        Returns an attribute of Cplex.solution.type.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_solution_type()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">solninfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="SolutionInterface.is_primal_feasible">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.is_primal_feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_primal_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether or not the solution is known to be primal feasible.</span>

<span class="sd">        Note</span>
<span class="sd">          Returning False does not necessarily mean that the problem is</span>
<span class="sd">          not primal feasible, only that it is not proved to be primal</span>
<span class="sd">          feasible.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.is_primal_feasible()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">solninfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="SolutionInterface.is_dual_feasible">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.is_dual_feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_dual_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether or not the solution is known to be dual feasible.</span>

<span class="sd">        Note</span>
<span class="sd">          Returning False does not necessarily mean that the problem is</span>
<span class="sd">          not dual feasible, only that it is not proved to be dual</span>
<span class="sd">          feasible.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.is_dual_feasible()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">solninfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span></div>


<div class="viewcode-block" id="SolutionInterface.get_activity_levels">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_activity_levels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_activity_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the activity levels for set of linear constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_activity_levels()</span>
<span class="sd">          return the activity levels for all linear constraints from</span>
<span class="sd">          the problem.</span>

<span class="sd">        solution.get_activity_levels(i)</span>
<span class="sd">          i must be a linear constraint name or index.  Returns the</span>
<span class="sd">          activity levels for the linear constraint whose index or</span>
<span class="sd">          name is i.</span>

<span class="sd">        solution.get_activity_levels(s)</span>
<span class="sd">          s must be a sequence of linear constraint names or indices.</span>
<span class="sd">          Returns the activity levels for the linear constraints with</span>
<span class="sd">          indices the members of s.  Equivalent to</span>
<span class="sd">          [solution.get_activity_levels(i) for i in s]</span>

<span class="sd">        solution.get_activity_levels(begin, end)</span>
<span class="sd">          begin and end must be linear constraint indices or linear</span>
<span class="sd">          constraint names. Returns the activity levels for the linear</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          solution.get_activity_levels(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_activity_levels([2, 3, 12])</span>
<span class="sd">        [80.0, 0.0, 500.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_quadratic_activity_levels">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_quadratic_activity_levels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quadratic_activity_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the activity levels for set of quadratic constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        solution.get_quadratic_activity_levels()</span>
<span class="sd">          return the activity levels for all quadratic constraints</span>
<span class="sd">          from the problem.</span>

<span class="sd">        solution.get_quadratic_activity_levels(i)</span>
<span class="sd">          i must be a quadratic constraint name or index.  Returns</span>
<span class="sd">          the activity levels for the quadratic constraint whose</span>
<span class="sd">          index or name is i.</span>

<span class="sd">        solution.get_quadratic_activity_levels(s)</span>
<span class="sd">          s must be a sequence of quadratic constraint names or</span>
<span class="sd">          indices.  Returns the activity levels for the quadratic</span>
<span class="sd">          constraints with indices the members of s.  Equivalent to</span>
<span class="sd">          [solution.get_quadratic_activity_levels(i) for i in s]</span>

<span class="sd">        solution.get_quadratic_activity_levels(begin, end)</span>
<span class="sd">          begin and end must be quadratic constraint indices or quadratic</span>
<span class="sd">          constraint names. Returns the activity levels for the quadratic</span>
<span class="sd">          constraints with indices between begin and end, inclusive of</span>
<span class="sd">          end. Equivalent to</span>
<span class="sd">          solution.get_quadratic_activity_levels(range(begin, end + 1)).</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;qcp.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; xqxax = c.solution.get_quadratic_activity_levels()</span>
<span class="sd">        &gt;&gt;&gt; abs(xqxax[0] - 2.015616) &lt; 1e-6</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getxqxax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getxqxax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span>
            <span class="n">getxqxax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.get_quality_metrics">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.get_quality_metrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_quality_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object containing measures of the solution quality.</span>

<span class="sd">        See `QualityMetrics`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; qm = c.solution.get_quality_metrics()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QualityMetrics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="p">)</span></div>


<div class="viewcode-block" id="SolutionInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.SolutionInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the incumbent solution to a file.</span>

<span class="sd">        See `CPXsolwrite &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/solwrite.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual and also `InitialInterface.read_start()`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; c.solution.write(&quot;lpex.sol&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">solwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="PresolveStatus">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PresolveStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Presolve status codes&quot;&quot;&quot;</span>
    <span class="n">no_reductions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">has_problem</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">empty_problem</span> <span class="o">=</span> <span class="mi">2</span></div>



<div class="viewcode-block" id="PresolveMethod">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveMethod">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PresolveMethod</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Presolve solution methods&quot;&quot;&quot;</span>
    <span class="n">none</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_NONE</span>
    <span class="n">primal</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_PRIMAL</span>
    <span class="n">dual</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_DUAL</span>
    <span class="n">barrier</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_ALG_BARRIER</span></div>



<div class="viewcode-block" id="PresolveColStatus">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveColStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PresolveColStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Presolve variable status codes&quot;&quot;&quot;</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PRECOL_LOW</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PRECOL_UP</span>
    <span class="n">fixed</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PRECOL_FIX</span>
    <span class="n">aggregated</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PRECOL_AGG</span>
    <span class="n">other</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PRECOL_OTHER</span></div>



<div class="viewcode-block" id="PresolveRowStatus">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveRowStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PresolveRowStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Presolve linear constraint status codes&quot;&quot;&quot;</span>
    <span class="n">reduced</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PREROW_RED</span>
    <span class="n">aggregated</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PREROW_AGG</span>
    <span class="n">other</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_PREROW_OTHER</span></div>



<div class="viewcode-block" id="PresolveInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PresolveInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for dealing with the presolved problem.&quot;&quot;&quot;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">PresolveStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `PresolveStatus()` &quot;&quot;&quot;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">PresolveMethod</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `PresolveMethod()` &quot;&quot;&quot;</span>
    <span class="n">col_status</span> <span class="o">=</span> <span class="n">PresolveColStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `PresolveColStatus()` &quot;&quot;&quot;</span>
    <span class="n">row_status</span> <span class="o">=</span> <span class="n">PresolveRowStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `PresolveRowStatus()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PresolveInterface.crush_formula">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.crush_formula">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">crush_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Crushes a linear formula down into the presolved space.</span>

<span class="sd">        formula may either be an instance of the SparsePair class or a</span>
<span class="sd">        sequence of length two, the first entry of which contains</span>
<span class="sd">        variable names or indices, the second entry of which contains</span>
<span class="sd">        the float values associated with those variables.</span>

<span class="sd">        Returns a (crushed_formula, offset) pair, where</span>
<span class="sd">        crushed_formula is a SparsePair object containing the crushed</span>
<span class="sd">        formula in terms of the presolved variables and offset is the</span>
<span class="sd">        value of the linear formula corresponding to variables that</span>
<span class="sd">        have been removed in the presolved problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.crush_formula(cplex.SparsePair(ind = [1, 2], val = [1.0] * 2))</span>
<span class="sd">        (SparsePair(ind = [1, 2], val = [1.0, 1.0]), 0.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">crushform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="PresolveInterface.crush_x">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.crush_x">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">crush_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Projects a primal solution down to the presolved space.</span>

<span class="sd">        x must be a list of floats with length equal to the number of</span>
<span class="sd">        variables in the original problem.  Returns a list of floats</span>
<span class="sd">        with length equal to the number of variables in the presolved</span>
<span class="sd">        problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.crush_x([1.0] * 4)</span>
<span class="sd">        [1.0, 1.0, 1.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">crushx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.crush_pi">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.crush_pi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">crush_pi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pi</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Projects a dual solution down to the presolved space.</span>

<span class="sd">        pi must be a list of floats with length equal to the number of</span>
<span class="sd">        linear constraints in the original problem.  Returns a list of</span>
<span class="sd">        floats with length equal to the number of linear constraints</span>
<span class="sd">        in the presolved problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.crush_pi([1.0] * 4)</span>
<span class="sd">        [1.0, 1.0, 1.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">crushpi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.uncrush_formula">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.uncrush_formula">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">uncrush_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_formula</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uncrushes a linear formula up from the presolved space.</span>

<span class="sd">        formula may either be an instance of the SparsePair class or a</span>
<span class="sd">        sequence of length two, the first entry of which contains</span>
<span class="sd">        variable names or indices, the second entry of which contains</span>
<span class="sd">        the float values associated with those variables.</span>

<span class="sd">        Returns a (formula, offset) pair, where formula is a</span>
<span class="sd">        SparsePair object containing the formula in terms of variables</span>
<span class="sd">        in the original problem and offset is the value of the linear</span>
<span class="sd">        formula corresponding to variables that have been removed in</span>
<span class="sd">        the presolved problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.uncrush_formula(cplex.SparsePair(ind = [1, 2], val = [1.0] * 2))</span>
<span class="sd">        (SparsePair(ind = [1, 2], val = [1.0, 1.0]), 0.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">pre_formula</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">uncrushform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SparsePair</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="PresolveInterface.uncrush_x">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.uncrush_x">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">uncrush_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Projects a primal presolved solution up to the original space.</span>

<span class="sd">        x must be a list of floats with length equal to the number of</span>
<span class="sd">        variables in the presolved problem.  Returns a list of floats</span>
<span class="sd">        with length equal to the number of variables in the original</span>
<span class="sd">        problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.uncrush_x([1.0] * 3)</span>
<span class="sd">        [1.0, 1.0, 1.0, 0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">uncrushx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">pre_x</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.uncrush_pi">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.uncrush_pi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">uncrush_pi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre_pi</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Projects a dual presolved solution up to the presolved space.</span>

<span class="sd">        pi must be a list of floats with length equal to the number of</span>
<span class="sd">        linear constraints in the presolved problem.  Returns a list</span>
<span class="sd">        of floats with length equal to the number of linear</span>
<span class="sd">        constraints in the original problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.uncrush_pi([1.0] * 3)</span>
<span class="sd">        [1.0, 1.0, 1.0, 0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">uncrushpi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">pre_pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.free">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.free">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Frees the presolved problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.free()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">freepresolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.get_status">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.get_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of presolve.</span>

<span class="sd">        Returns an attribute of Cplex.presolve.status.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.get_status()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getprestat_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.get_row_status">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.get_row_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_row_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of the original linear constraints.</span>

<span class="sd">        Returns a list of integers with length equal to the number of</span>
<span class="sd">        linear constraints in the original problem.  Each entry of</span>
<span class="sd">        this list is an attribute of Cplex.presolve.row_status.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.get_row_status()</span>
<span class="sd">        [-3, 1, 2, -3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getprestat_r</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.get_col_status">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.get_col_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_col_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of the original variables.</span>

<span class="sd">        Returns a list of integers with length equal to the number of</span>
<span class="sd">        variables in the original problem.  Each entry of this list</span>
<span class="sd">        is an attribute of Cplex.presolve.col_status.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.get_col_status()</span>
<span class="sd">        [0, 1, 2, -5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getprestat_c</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.get_presolved_row_status">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.get_presolved_row_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_presolved_row_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of the presolved linear constraints.</span>

<span class="sd">        Returns a list of integers with length equal to the number of</span>
<span class="sd">        linear constraints in the presolved problem.  -1 indicates</span>
<span class="sd">        that the presolved linear constraint corresponds to more than</span>
<span class="sd">        one linear constraint in the original problem.  Otherwise the</span>
<span class="sd">        value is the index of the corresponding linear constraint in</span>
<span class="sd">        the original problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.get_presolved_row_status()</span>
<span class="sd">        [-1, 1, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getprestat_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.get_presolved_col_status">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.get_presolved_col_status">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_presolved_col_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of the presolved variables.</span>

<span class="sd">        Returns a list of integers with length equal to the number of</span>
<span class="sd">        variables in the presolved problem.  -1 indicates that the</span>
<span class="sd">        presolved variable corresponds to a linear combination of more</span>
<span class="sd">        than one variable in the original problem.  Otherwise the</span>
<span class="sd">        value is the index of the corresponding variable in the</span>
<span class="sd">        original problem.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.get_presolved_col_status()</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getprestat_oc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.add_rows">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.add_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lin_expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">senses</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds linear constraints to the presolved problem.</span>

<span class="sd">        presolve.add_rows accepts the keyword arguments lin_expr,</span>
<span class="sd">        senses, rhs, and names.</span>

<span class="sd">        If more than one argument is specified, all arguments must</span>
<span class="sd">        have the same length.</span>

<span class="sd">        lin_expr may be either a list of SparsePair instances or a</span>
<span class="sd">        matrix in list-of-lists format.</span>

<span class="sd">        Note</span>
<span class="sd">          The entries of lin_expr must not contain duplicate indices.</span>
<span class="sd">          If an entry of lin_expr references a variable more than</span>
<span class="sd">          once, either by index, name, or a combination of index and</span>
<span class="sd">          name, an exception will be raised.</span>

<span class="sd">        senses must be either a list of single-character strings or a</span>
<span class="sd">        string containing the types of the variables.</span>

<span class="sd">        rhs is a list of floats, specifying the righthand side of</span>
<span class="sd">        each linear constraint.</span>

<span class="sd">        names is a list of strings.</span>

<span class="sd">        The specified constraints are added to both the original</span>
<span class="sd">        problem and the presolved problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">init_list_args</span><span class="p">(</span>
            <span class="n">lin_expr</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">senses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">senses</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">senses</span><span class="p">)</span>
        <span class="n">validate_arg_lengths</span><span class="p">(</span>
            <span class="p">[</span><span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">lin_expr</span><span class="p">],</span>
            <span class="n">extra_msg</span><span class="o">=</span><span class="s2">&quot;: lin_expr, senses, rhs, names&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lin_expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">rmat</span> <span class="o">=</span> <span class="n">_HBMatrix</span><span class="p">(</span><span class="n">lin_expr</span><span class="p">)</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">preaddrows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">senses</span><span class="p">,</span>
                            <span class="n">rmat</span><span class="o">.</span><span class="n">matbeg</span><span class="p">,</span> <span class="n">rmat</span><span class="o">.</span><span class="n">matind</span><span class="p">,</span> <span class="n">rmat</span><span class="o">.</span><span class="n">matval</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span></div>

        <span class="c1"># TODO: We don&#39;t return an iterator here because there&#39;s no way to</span>
        <span class="c1">#       get indices of presolve rows from names.</span>

<div class="viewcode-block" id="PresolveInterface.set_objective">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.set_objective">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the linear objective function of the presolved problem.</span>

<span class="sd">        objective must be either a SparsePair instance or a list of</span>
<span class="sd">        two lists, the first of which contains variable indices or</span>
<span class="sd">        names, the second of which contains floats.</span>

<span class="sd">        The objective function of both the original problem and the</span>
<span class="sd">        presolved problem are changed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">unpack_pair</span><span class="p">(</span><span class="n">objective</span><span class="p">)</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">prechgobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.presolve">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.presolve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">presolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solves the presolved problem.</span>

<span class="sd">        method must be an attribute of Cplex.presolve.method.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.presolve.presolve(c.presolve.method.dual)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">presolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="PresolveInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PresolveInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the presolved problem to a file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">preslvwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                    <span class="n">filename</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FeasoptConstraintType">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptConstraintType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FeasoptConstraintType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Types of constraints&quot;&quot;&quot;</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_LOWER_BOUND</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_UPPER_BOUND</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_LINEAR</span>
    <span class="n">quadratic</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_QUADRATIC</span>
    <span class="n">indicator</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_INDICATOR</span></div>



<div class="viewcode-block" id="FeasoptInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FeasoptInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds a minimal relaxation of the problem that is feasible.</span>

<span class="sd">    This is a callable class. To find a feasible relaxation of a problem,</span>
<span class="sd">    invoke the `__call__` method of this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">constraint_type</span> <span class="o">=</span> <span class="n">FeasoptConstraintType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `FeasoptConstraintType()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FeasoptInterface.all_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface.all_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing feasopt to relax all constraints.</span>

<span class="sd">        Calling Cplex.feasopt(Cplex.feasopt.all_constraints()) will</span>
<span class="sd">        result in every constraint being relaxed independently with</span>
<span class="sd">        equal weight.</span>

<span class="sd">        See also the `__call__` method of this class.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.feasopt.all_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bound_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bound_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicator_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="k">return</span> <span class="n">_group</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span></div>


<div class="viewcode-block" id="FeasoptInterface.upper_bound_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface.upper_bound_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">upper_bound_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing feasopt to relax all upper bounds.</span>

<span class="sd">        If called with no arguments, every upper bound is assigned</span>
<span class="sd">        weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every upper bound is</span>
<span class="sd">        assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of upper bounds to be relaxed.  If one variable index or name</span>
<span class="sd">        is specified, it is the only upper bound that can be relaxed.</span>
<span class="sd">        If two variable indices or names are specified, then upper</span>
<span class="sd">        bounds of all variables between the first and the second,</span>
<span class="sd">        inclusive, can be relaxed.  If a sequence of variable names or</span>
<span class="sd">        indices is passed in, all of their upper bounds can be</span>
<span class="sd">        relaxed.</span>

<span class="sd">        See also the `__call__` method of this class.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.feasopt.upper_bound_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="FeasoptInterface.lower_bound_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface.lower_bound_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lower_bound_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing feasopt to relax all lower bounds.</span>

<span class="sd">        If called with no arguments, every lower bound is assigned</span>
<span class="sd">        weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every lower bound is</span>
<span class="sd">        assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of lower bounds to be relaxed.  If one variable index or name</span>
<span class="sd">        is specified, it is the only lower bound that can be relaxed.</span>
<span class="sd">        If two variable indices or names are specified, then lower</span>
<span class="sd">        bounds of all variables between the first and the second,</span>
<span class="sd">        inclusive, can be relaxed.  If a sequence of variable names or</span>
<span class="sd">        indices is passed in, all of their lower bounds can be</span>
<span class="sd">        relaxed.</span>

<span class="sd">        See also the `__call__` method of this class.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.feasopt.lower_bound_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="FeasoptInterface.linear_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface.linear_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">linear_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing feasopt to relax all linear constraints.</span>

<span class="sd">        If called with no arguments, every linear constraint is</span>
<span class="sd">        assigned weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every linear constraint</span>
<span class="sd">        is assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of linear constraints to be relaxed.  If one linear constraint</span>
<span class="sd">        index or name is specified, it is the only linear constraint</span>
<span class="sd">        that can be relaxed.  If two linear constraint indices or</span>
<span class="sd">        names are specified, then all linear constraints between the</span>
<span class="sd">        first and the second, inclusive, can be relaxed.  If a sequence</span>
<span class="sd">        of linear constraint names or indices is passed in, all of their</span>
<span class="sd">        linear constraints can be relaxed.</span>

<span class="sd">        See also the `__call__` method of this class.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.feasopt.linear_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="FeasoptInterface.quadratic_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface.quadratic_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">quadratic_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing feasopt to relax all quadratic constraints.</span>

<span class="sd">        If called with no arguments, every quadratic constraint is</span>
<span class="sd">        assigned weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every quadratic</span>
<span class="sd">        constraint is assigned a weight equal to the float passed in</span>
<span class="sd">        as the first argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of quadratic constraints to be relaxed.  If one quadratic</span>
<span class="sd">        constraint index or name is specified, it is the only</span>
<span class="sd">        quadratic constraint that can be relaxed.  If two quadratic</span>
<span class="sd">        constraint indices or names are specified, then all quadratic</span>
<span class="sd">        constraints between the first and the second, inclusive, can be</span>
<span class="sd">        relaxed.  If a sequence of quadratic constraint names or indices</span>
<span class="sd">        is passed in, all of their quadratic constraints can be relaxed.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.feasopt.quadratic_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">quadratic</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="FeasoptInterface.indicator_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface.indicator_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">indicator_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing feasopt to relax all indicator constraints.</span>

<span class="sd">        If called with no arguments, every indicator constraint is</span>
<span class="sd">        assigned weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every indicator</span>
<span class="sd">        constraint is assigned a weight equal to the float passed in</span>
<span class="sd">        as the first argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of indicator constraints to be relaxed.  If one indicator</span>
<span class="sd">        constraint index or name is specified, it is the only</span>
<span class="sd">        indicator constraint that can be relaxed.  If two indicator</span>
<span class="sd">        constraint indices or names are specified, then all indicator</span>
<span class="sd">        constraints between the first and the second, inclusive, can be</span>
<span class="sd">        relaxed.  If a sequence of indicator constraint names or indices</span>
<span class="sd">        is passed in, all of their indicator constraints can be relaxed.</span>

<span class="sd">        See also the `__call__` method of this class.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.feasopt.indicator_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">indicator</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="FeasoptInterface.__call__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.FeasoptInterface.__call__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finds a minimal relaxation of the problem that is feasible.</span>

<span class="sd">        This method can take arbitrarily many arguments. Either the</span>
<span class="sd">        object returned by feasopt.all_constraints() or any combination</span>
<span class="sd">        of constraint groups and objects returned by</span>
<span class="sd">        `upper_bound_constraints()`, `lower_bound_constraints()`,</span>
<span class="sd">        `linear_constraints()`, `quadratic_constraints()`, or</span>
<span class="sd">        `indicator_constraints()` may be used to specify the constraints</span>
<span class="sd">        to consider.</span>

<span class="sd">        Constraint groups are sequences of length two, the first entry of</span>
<span class="sd">        which is the preference for the group (a float), the second of</span>
<span class="sd">        which is a sequence of pairs (type, id), where type is an</span>
<span class="sd">        attribute of self.constraint_type and id is either an index or a</span>
<span class="sd">        valid name for the type.</span>

<span class="sd">        See `CPXfeasoptext &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/feasoptext.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;infeasible.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.feasopt(c.feasopt.all_constraints())</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_objective_value()</span>
<span class="sd">        2.0</span>
<span class="sd">        &gt;&gt;&gt; c.solution.get_values()</span>
<span class="sd">        [3.0, 2.0, 3.0, 2.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongNumberOfArgumentsError</span><span class="p">(</span>
                <span class="s2">&quot;Requires at least one argument&quot;</span><span class="p">)</span>
        <span class="n">gpref</span><span class="p">,</span> <span class="n">gbeg</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">indt</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># so we can call extend() below</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">_group</span><span class="p">):</span>
                <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">_gp</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">gpref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gbeg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">tran</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getconvfunc</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">indt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tran</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_setup_callbacks</span><span class="p">()</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">feasoptext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                            <span class="n">gpref</span><span class="p">,</span> <span class="n">gbeg</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">indt</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getconvfunc</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="n">max_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getnum</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_group</span><span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">max_num</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_getinterface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="n">contype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span>
        <span class="n">switcher</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">linear</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">quadratic</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">indicator</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">indicator_constraints</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">switcher</span><span class="p">[</span><span class="n">which</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_getnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="n">interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getinterface</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interface</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_getconvfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="n">interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getinterface</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interface</span><span class="o">.</span><span class="n">_conv</span></div>



<div class="viewcode-block" id="ConflictStatus">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConflictStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Status codes returned by conflict.get&quot;&quot;&quot;</span>
    <span class="n">excluded</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CONFLICT_EXCLUDED</span>
    <span class="n">possible_member</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CONFLICT_POSSIBLE_MEMBER</span>
    <span class="n">member</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CONFLICT_MEMBER</span></div>



<div class="viewcode-block" id="ConflictConstraintType">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictConstraintType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConflictConstraintType</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Types of constraints&quot;&quot;&quot;</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_LOWER_BOUND</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_UPPER_BOUND</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_LINEAR</span>
    <span class="n">quadratic</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_QUADRATIC</span>
    <span class="n">indicator</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_INDICATOR</span>
    <span class="n">SOS</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_SOS</span>
    <span class="n">pwl</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_CON_PWL</span></div>



<div class="viewcode-block" id="ConflictInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConflictInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for identifying conflicts among constraints.&quot;&quot;&quot;</span>

    <span class="n">group_status</span> <span class="o">=</span> <span class="n">ConflictStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `ConflictStatus()` &quot;&quot;&quot;</span>
    <span class="n">constraint_type</span> <span class="o">=</span> <span class="n">ConflictConstraintType</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `ConflictConstraintType()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConflictInterface.__init__">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cplex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new ConflictInterface.</span>

<span class="sd">        The conflict interface is exposed by the top-level `Cplex` class</span>
<span class="sd">        as Cplex.conflict.  This constructor is not meant to be used</span>
<span class="sd">        externally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cplex</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.all_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.all_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all constraints.</span>

<span class="sd">        Calling</span>
<span class="sd">        Cplex.conflict.refine(Cplex.conflict.all_constraints()) or</span>
<span class="sd">        Cplex.conflict.refine_MIP_start(Cplex.conflict.all_constraints())</span>
<span class="sd">        will result in every constraint being included in the search</span>
<span class="sd">        for conflicts with equal preference.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.all_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bound_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bound_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SOS_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicator_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="n">gp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwl_constraints</span><span class="p">()</span><span class="o">.</span><span class="n">_gp</span>
        <span class="k">return</span> <span class="n">_group</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.upper_bound_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.upper_bound_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">upper_bound_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all upper bounds.</span>

<span class="sd">        If called with no arguments, every upper bound is assigned</span>
<span class="sd">        weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every upper bound is</span>
<span class="sd">        assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of upper bounds to be included.  If one variable index or name</span>
<span class="sd">        is specified, it is the only upper bound that will be</span>
<span class="sd">        included.  If two variable indices or names are specified, then</span>
<span class="sd">        upper bounds of all variables between the first and the</span>
<span class="sd">        second, inclusive, will be included.  If a sequence of</span>
<span class="sd">        variable names or indices is passed in, all of their upper</span>
<span class="sd">        bounds will be included.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.upper_bound_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.lower_bound_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.lower_bound_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lower_bound_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all lower bounds.</span>

<span class="sd">        If called with no arguments, every lower bound is assigned</span>
<span class="sd">        weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every lower bound is</span>
<span class="sd">        assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of lower bounds to be included.  If one variable index or name</span>
<span class="sd">        is specified, it is the only lower bound that will be</span>
<span class="sd">        included.  If two variable indices or names are specified, then</span>
<span class="sd">        lower bounds of all variables between the first and the</span>
<span class="sd">        second, inclusive, will be included.  If a sequence of</span>
<span class="sd">        variable names or indices is passed in, all of their lower</span>
<span class="sd">        bounds will be included.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.lower_bound_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.linear_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.linear_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">linear_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all linear constraints.</span>

<span class="sd">        If called with no arguments, every linear constraint is</span>
<span class="sd">        assigned weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every linear constraint</span>
<span class="sd">        is assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of linear constraints to be included.  If one linear</span>
<span class="sd">        constraint index or name is specified, it is the only linear</span>
<span class="sd">        constraint that will be included.  If two linear constraint</span>
<span class="sd">        indices or names are specified, then all linear constraints</span>
<span class="sd">        between the first and the second, inclusive, will be included.</span>
<span class="sd">        If a sequence of linear constraint names or indices is passed</span>
<span class="sd">        in, they will all be included.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.linear_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.quadratic_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.quadratic_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">quadratic_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all quadratic constraints.</span>

<span class="sd">        If called with no arguments, every quadratic constraint is</span>
<span class="sd">        assigned weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every quadratic</span>
<span class="sd">        constraint is assigned a weight equal to the float passed in</span>
<span class="sd">        as the first argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of quadratic constraints to be included.  If one quadratic</span>
<span class="sd">        constraint index or name is specified, it is the only</span>
<span class="sd">        quadratic constraint that will be included.  If two quadratic</span>
<span class="sd">        constraint indices or names are specified, then all quadratic</span>
<span class="sd">        constraints between the first and the second, inclusive, will</span>
<span class="sd">        be included.  If a sequence of quadratic constraint names or</span>
<span class="sd">        indices is passed in, they will all be included.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.quadratic_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">quadratic</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.indicator_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.indicator_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">indicator_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all indicator constraints.</span>

<span class="sd">        If called with no arguments, every indicator constraint is</span>
<span class="sd">        assigned weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every indicator</span>
<span class="sd">        constraint is assigned a weight equal to the float passed in</span>
<span class="sd">        as the first argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of indicator constraints to be included.  If one indicator</span>
<span class="sd">        constraint index or name is specified, it is the only</span>
<span class="sd">        indicator constraint that will be included.  If two indicator</span>
<span class="sd">        constraint indices or names are specified, the all indicator</span>
<span class="sd">        constraints between the first and the second, inclusive, will</span>
<span class="sd">        be included.  If a sequence of indicator constraint names or</span>
<span class="sd">        indices is passed in, they will all be included.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.indicator_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">indicator</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.pwl_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.pwl_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pwl_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all PWL constraints.</span>

<span class="sd">        If called with no arguments, every PWL constraint is assigned</span>
<span class="sd">        weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every PWL constraint is</span>
<span class="sd">        assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of PWL constraints to be included. If one PWL constraint index or</span>
<span class="sd">        name is specified, it is the only PWL constraint that will be</span>
<span class="sd">        included. If two PWL constraint indices or names are specified,</span>
<span class="sd">        then all PWL constraints between the first and the second,</span>
<span class="sd">        inclusive, will be included. If a sequence of PWL constraint</span>
<span class="sd">        names or indices is passed in, they will all be included.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.pwl_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">pwl</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.SOS_constraints">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.SOS_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">SOS_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object instructing the conflict refiner to include</span>
<span class="sd">        all SOS constraints.</span>

<span class="sd">        If called with no arguments, every SOS constraint is assigned</span>
<span class="sd">        weight 1.0.</span>

<span class="sd">        If called with one or more arguments, every SOS constraint is</span>
<span class="sd">        assigned a weight equal to the float passed in as the first</span>
<span class="sd">        argument.</span>

<span class="sd">        If additional arguments are specified, they determine a subset</span>
<span class="sd">        of SOS constraints to be included.  If one SOS constraint</span>
<span class="sd">        index or name is specified, it is the only SOS constraint that</span>
<span class="sd">        will be included.  If two SOS constraint indices or names are</span>
<span class="sd">        specified, then all SOS constraints between the first and the</span>
<span class="sd">        second, inclusive, will be included.  If a sequence of SOS</span>
<span class="sd">        constraint names or indices is passed in, they will all be</span>
<span class="sd">        included.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; group = c.conflict.SOS_constraints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span><span class="o">.</span><span class="n">SOS</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_expand_groups</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expands group arguments passed to the refine methods</span>

<span class="sd">        These should be either _group objects or tuples of length two</span>
<span class="sd">        (the first entry of which is the preference for the group (a</span>
<span class="sd">        float), the second of which is a tuple of pairs (type, id),</span>
<span class="sd">        where type is an attribute of conflict.constraint_type and id is</span>
<span class="sd">        either an index or a valid name for the type).</span>

<span class="sd">        As _group objects can contain many tuples, this method makes</span>
<span class="sd">        sure that the expanded order is maintained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Grab the tuple list out of any _group objects we encounter.</span>
                <span class="n">groups</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">_gp</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># Otherwise, we assume these are tuples.</span>
                <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groups</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_separate_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Separates group information into individual lists.</span>

<span class="sd">        This, so they can be passed into the callable library in the</span>
<span class="sd">        expected format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_groups</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="n">pref</span><span class="p">,</span> <span class="n">contpl</span> <span class="o">=</span> <span class="n">group</span>
            <span class="n">grppref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pref</span><span class="p">)</span>
            <span class="n">grpbeg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grpind</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">contype</span><span class="p">,</span> <span class="n">conid</span> <span class="ow">in</span> <span class="n">contpl</span><span class="p">:</span>
                <span class="n">tran</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getconvfunc</span><span class="p">(</span><span class="n">contype</span><span class="p">)</span>
                <span class="n">grptype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contype</span><span class="p">)</span>
                <span class="n">grpind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tran</span><span class="p">(</span><span class="n">conid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compose_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert individual lists of group information into group</span>
<span class="sd">        format.</span>

<span class="sd">        These are tuples of length two (the first entry of which is the</span>
<span class="sd">        preference for the group (a float), the second of which is a</span>
<span class="sd">        tuple of pairs (type, id), where type is an attribute of</span>
<span class="sd">        conflict.constraint_type and id is either an index or a valid</span>
<span class="sd">        name for the type).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">grpbeglen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grpbeg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grpbeglen</span><span class="p">):</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">grpbeg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">grpbeglen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grpind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">grpbeg</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">grppref</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">grptype</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">end</span><span class="p">],</span>
                                                 <span class="n">grpind</span><span class="p">[</span><span class="n">begin</span><span class="p">:</span><span class="n">end</span><span class="p">]))))</span>
        <span class="k">return</span> <span class="n">groups</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getconvfunc</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="n">max_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getnum</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_group</span><span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">max_num</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_getinterface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="n">contype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_type</span>
        <span class="n">switcher</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">linear</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">quadratic</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">quadratic_constraints</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">SOS</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">SOS</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">indicator</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">indicator_constraints</span><span class="p">,</span>
            <span class="n">contype</span><span class="o">.</span><span class="n">pwl</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">pwl_constraints</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">switcher</span><span class="p">[</span><span class="n">which</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_getnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="n">interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getinterface</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interface</span><span class="o">.</span><span class="n">get_num</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_getconvfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="n">interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getinterface</span><span class="p">(</span><span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interface</span><span class="o">.</span><span class="n">_conv</span>

<div class="viewcode-block" id="ConflictInterface.refine_MIP_start">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.refine_MIP_start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">refine_MIP_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MIP_start</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identifies a minimal conflict among a set of constraints for a</span>
<span class="sd">        given MIP start.</span>

<span class="sd">        This method can take arbitrarily many arguments.  The first</span>
<span class="sd">        argument must be either a name or index of a MIP start.</span>
<span class="sd">        Additional arguments are optional and can be the object returned</span>
<span class="sd">        by `all_constraints()` or any combination of constraint groups</span>
<span class="sd">        and objects returned by `upper_bound_constraints()`,</span>
<span class="sd">        `lower_bound_constraints()`, `linear_constraints()`,</span>
<span class="sd">        `quadratic_constraints()`, `indicator_constraints()`,</span>
<span class="sd">        `pwl_constraints()`, or `SOS_constraints()` may be used to</span>
<span class="sd">        specify the constraints to consider. If no additional arguments</span>
<span class="sd">        are specified, then constraint groups are created automatically</span>
<span class="sd">        as in the CPLEX interactive.</span>

<span class="sd">        Constraint groups are sequences of length two, the first entry</span>
<span class="sd">        of which is the preference for the group (a float), the second</span>
<span class="sd">        of which is a sequence of pairs (type, id), where type is an</span>
<span class="sd">        attribute of conflict.constraint_type and id is either an index</span>
<span class="sd">        or a valid name for the type.</span>

<span class="sd">        See `CPXrefinemipstartconflictext &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/mipapi/refinemipstartconflictext.html&gt;`_ and in the Callable</span>
<span class="sd">        Library Reference Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add([1], [0], [0], c.variables.type.binary)</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add([2], [0], [0], c.variables.type.binary)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">        ...     lin_expr=[[[0, 1], [1.0, 1.0]]], senses=&quot;E&quot;, rhs=[2.0])</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.refine_MIP_start(0, c.conflict.all_constraints())</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.get()</span>
<span class="sd">        [-1, -1, -1, -1, 3]</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.group_status[3], c.conflict.group_status[-1]</span>
<span class="sd">        (&#39;member&#39;, &#39;excluded&#39;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.get_groups(0, 3)</span>
<span class="sd">        [(1.0, ((2, 0),)), (1.0, ((2, 1),)), (1.0, ((1, 0),)), (1.0, ((1, 1),))]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_setup_callbacks</span><span class="p">()</span>
        <span class="n">mipstartindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">MIP_starts</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">MIP_start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separate_groups</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">refinemipstartconflictext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                           <span class="n">mipstartindex</span><span class="p">,</span>
                                           <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.refine">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.refine">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identifies a minimal conflict among a set of constraints.</span>

<span class="sd">        This method can take arbitrarily many arguments.  Either the</span>
<span class="sd">        object returned by `all_constraints()` or any combination of</span>
<span class="sd">        constraint groups and objects returned by</span>
<span class="sd">        `upper_bound_constraints()`, `lower_bound_constraints()`,</span>
<span class="sd">        `linear_constraints()`, `quadratic_constraints()`,</span>
<span class="sd">        `indicator_constraints()`, `pwl_constraints()`, or</span>
<span class="sd">        `SOS_constraints()` may be used to specify the constraints to</span>
<span class="sd">        consider. Alternatively, if no arguments are specified, then</span>
<span class="sd">        constraint groups are created automatically as in the CPLEX</span>
<span class="sd">        interactive.</span>

<span class="sd">        Constraint groups are sequences of length two, the first entry</span>
<span class="sd">        of which is the preference for the group (a float), the second</span>
<span class="sd">        of which is a sequence of pairs (type, id), where type is an</span>
<span class="sd">        attribute of conflict.constraint_type and id is either an index or</span>
<span class="sd">        a valid name for the type.</span>

<span class="sd">        See `CPXrefineconflictext &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/refineconflictext.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;infeasible.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.refine(c.conflict.linear_constraints(),</span>
<span class="sd">        ...                   c.conflict.lower_bound_constraints())</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.get()</span>
<span class="sd">        [3, -1, 3, -1, -1, -1]</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.group_status[3], c.conflict.group_status[-1]</span>
<span class="sd">        (&#39;member&#39;, &#39;excluded&#39;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.get_groups([0, 2])</span>
<span class="sd">        [(1.0, ((3, 0),)), (1.0, ((1, 0),))]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_setup_callbacks</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_separate_groups</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">refineconflictext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                   <span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.get">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.get">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the status of a set of groups of constraints.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        If called with no arguments, returns a list containing the</span>
<span class="sd">        status of all constraint groups.</span>

<span class="sd">        If called with one integer argument, returns the status of</span>
<span class="sd">        that constraint group.</span>

<span class="sd">        If called with two integer arguments, returns the status of</span>
<span class="sd">        all constraint groups between the first and second argument,</span>
<span class="sd">        inclusive.</span>

<span class="sd">        If called with a sequence of integers as its argument, returns</span>
<span class="sd">        the status of all constraint groups in the sequence.</span>

<span class="sd">        The status codes are attributes of</span>
<span class="sd">        Cplex.conflict.group_status.</span>

<span class="sd">        See `CPXgetconflictext &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/getconflictext.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;infeasible.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.refine(c.conflict.all_constraints())</span>
<span class="sd">        &gt;&gt;&gt; confstatus = c.conflict.get()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getconflict</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_groups</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getconflictext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getconflict</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.get_num_groups">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.get_num_groups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of constraint groups used in the last call</span>
<span class="sd">        to `refine()` or `refine_MIP_start()`.</span>

<span class="sd">        See `CPXgetconflictnumgroups &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/getconflictnumgroups.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;infeasible.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.refine(c.conflict.all_constraints())</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.get_num_groups()</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getconflictnumgroups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.get_groups">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.get_groups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the groups of constraints used in the last call to</span>
<span class="sd">        `refine()` or `refine_MIP_start()`.</span>

<span class="sd">        Can be called by four forms.</span>

<span class="sd">        If called with no arguments, returns a list containing all</span>
<span class="sd">        constraint groups.</span>

<span class="sd">        If called with one integer argument, returns that constraint</span>
<span class="sd">        group.</span>

<span class="sd">        If called with two integer arguments, returns all constraint</span>
<span class="sd">        groups between the first and second argument, inclusive.</span>

<span class="sd">        If called with a sequence of integers as its argument, returns</span>
<span class="sd">        all constraint groups in the sequence.</span>

<span class="sd">        Constraint groups are tuples of length two, the first entry of</span>
<span class="sd">        which is the preference for the group (a float), the second of</span>
<span class="sd">        which is a tuple of pairs (type, id), where type is an</span>
<span class="sd">        attribute of conflict.constraint_type and id is either an index</span>
<span class="sd">        or a valid name for the type.</span>

<span class="sd">        See `CPXgetconflictgroups &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/getconflictgroups.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;infeasible.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.refine(c.conflict.all_constraints())</span>
<span class="sd">        &gt;&gt;&gt; groups = c.conflict.get_groups()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">getgroups</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_groups</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="p">(</span><span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span>
             <span class="n">grptype</span><span class="p">)</span> <span class="o">=</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getconflictgroups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
                                                   <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compose_groups</span><span class="p">(</span><span class="n">grppref</span><span class="p">,</span> <span class="n">grpbeg</span><span class="p">,</span> <span class="n">grpind</span><span class="p">,</span> <span class="n">grptype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">apply_freeform_two_args</span><span class="p">(</span><span class="n">getgroups</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConflictInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.ConflictInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the conflict to a file.</span>

<span class="sd">        See `CPXclpwrite &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/clpwrite.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;infeasible.lp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.refine(c.conflict.all_constraints())</span>
<span class="sd">        &gt;&gt;&gt; c.conflict.write(&quot;conflict.clp&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">clpwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="PivotVarStatus">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.PivotVarStatus">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PivotVarStatus</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use as input to pivoting methods.&quot;&quot;&quot;</span>
    <span class="n">at_lower_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_AT_LOWER</span>
    <span class="n">at_upper_bound</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_AT_UPPER</span></div>



<div class="viewcode-block" id="AdvancedCplexInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AdvancedCplexInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Advanced control of a Cplex object.&quot;&quot;&quot;</span>

    <span class="n">no_variable</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_NO_VARIABLE</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `_constants.CPX_NO_VARIABLE` &quot;&quot;&quot;</span>
    <span class="n">variable_status</span> <span class="o">=</span> <span class="n">PivotVarStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `PivotVarStatus()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AdvancedCplexInterface.delete_names">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface.delete_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes all names from the problem and its objects.&quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">delnames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedCplexInterface.basic_presolve">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface.basic_presolve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">basic_presolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs bound strengthening and detects redundant rows.</span>

<span class="sd">        Returns a tuple containing three lists: a list containing the</span>
<span class="sd">        strengthened lower bounds, a list containing the strengthened</span>
<span class="sd">        upper bounds, and a list containing the status of each row.</span>

<span class="sd">        See `CPXbasicpresolve &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/basicpresolve.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual.</span>

<span class="sd">        Note</span>
<span class="sd">          This method does not create a presolved problem.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; redlb, redub, rstat = c.advanced.basic_presolve()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">basicpresolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedCplexInterface.pivot">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface.pivot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pivot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enter</span><span class="p">,</span> <span class="n">leave</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pivots a variable into the basis.</span>

<span class="sd">        enter is a name or index of a variable or linear constraint.</span>
<span class="sd">        The index of a slack variable is specified by a negative</span>
<span class="sd">        integer; -i - 1 refers to the slack associated with the ith</span>
<span class="sd">        linear constraint.  enter must not identify a basic variable.</span>

<span class="sd">        leave is a name or index of a variable or linear constraint.</span>
<span class="sd">        The index of a slack variable is specified by a negative</span>
<span class="sd">        integer; -i - 1 refers to the slack associated with the ith</span>
<span class="sd">        linear constraint.  leave must identify either a basic</span>
<span class="sd">        variable or a non-basic variable with both a lower and upper</span>
<span class="sd">        bound to indicate that it is to move to its opposite bound.</span>
<span class="sd">        leave may also be set to Cplex.advanced.no_variable to</span>
<span class="sd">        instruct CPLEX to use a ratio test to determine the entering</span>
<span class="sd">        variable.</span>

<span class="sd">        Note</span>
<span class="sd">          If a linear constraint has the same name as a column, it must</span>
<span class="sd">          be specified by -index - 1, not by name.</span>

<span class="sd">        status must be an attribute of Cplex.advanced.variable_status</span>
<span class="sd">        specifying the nonbasic status to be assigned to the leaving</span>
<span class="sd">        variable after the basis change.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">conv</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CplexSolverError</span><span class="p">:</span>
                <span class="c1"># Variable name not found, try linear constraints.</span>
                <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">conv</span><span class="p">(</span><span class="n">enter</span><span class="p">),</span>
                       <span class="n">conv</span><span class="p">(</span><span class="n">leave</span><span class="p">),</span> <span class="n">status</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedCplexInterface.pivot_slacks_in">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface.pivot_slacks_in">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pivot_slacks_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forcibly pivots slack variables into the basis.</span>

<span class="sd">        which may be either a single linear constraint index or name</span>
<span class="sd">        or a sequence of linear constraint indices or names.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">listify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">linear_constraints</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">which</span><span class="p">))</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">pivotin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedCplexInterface.pivot_fixed_variables_out">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface.pivot_fixed_variables_out">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pivot_fixed_variables_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forcibly pivots structural variables out of the basis.</span>

<span class="sd">        which may be either a single variable index or name or a</span>
<span class="sd">        sequence of variable indices or names.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">listify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">which</span><span class="p">))</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">pivotout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdvancedCplexInterface.strong_branching">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface.strong_branching">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">strong_branching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs strong branching.</span>

<span class="sd">        variables is a sequence of names or indices of variables.</span>

<span class="sd">        it_limit is an integer that specifies the number of iterations</span>
<span class="sd">        allowed.</span>

<span class="sd">        Returns a list of pairs (down_penalty, up_penalty) with the</span>
<span class="sd">        same length as variables containing the penalties for</span>
<span class="sd">        branching down or up, respectively, on each variable.</span>

<span class="sd">        See `CPXstrongbranch &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/strongbranch.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual for more detail.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; itlim = c.parameters.simplex.limits.iterations.get()</span>
<span class="sd">        &gt;&gt;&gt; c.read(&quot;example.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c.solve()</span>
<span class="sd">        &gt;&gt;&gt; vars = list(range(c.variables.get_num()))</span>
<span class="sd">        &gt;&gt;&gt; result = c.advanced.strong_branching(vars, itlim)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">conv</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">strongbranch</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span>
            <span class="n">conv</span><span class="p">(</span><span class="n">variables</span><span class="p">),</span> <span class="n">it_limit</span><span class="p">))</span></div>


<div class="viewcode-block" id="AdvancedCplexInterface.complete">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.AdvancedCplexInterface.complete">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See `CPXcompletelp &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/completelp.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual.&quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">completelp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">lp</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="BranchDirection">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.BranchDirection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BranchDirection</span><span class="p">(</span><span class="n">ConstantClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constants defining branch directions&quot;&quot;&quot;</span>
    <span class="n">default</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_BRANCH_GLOBAL</span>
    <span class="n">down</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_BRANCH_DOWN</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">_constants</span><span class="o">.</span><span class="n">CPX_BRANCH_UP</span></div>



<div class="viewcode-block" id="OrderInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.OrderInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OrderInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods for setting and querying a priority order for branching.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    &gt;&gt;&gt; import cplex</span>
<span class="sd">    &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">    &gt;&gt;&gt; indices = c.variables.add(names = [str(i) for i in range(5)])</span>
<span class="sd">    &gt;&gt;&gt; c.variables.set_types(zip(list(range(5)), [&quot;C&quot;,&quot;I&quot;,&quot;I&quot;,&quot;I&quot;,&quot;I&quot;]))</span>
<span class="sd">    &gt;&gt;&gt; c.order.set([(1, 10, c.order.branch_direction.up), (&#39;3&#39;, 5, c.order.branch_direction.down)])</span>
<span class="sd">    &gt;&gt;&gt; c.order.get()</span>
<span class="sd">    [(1, 10, 1), (3, 5, -1)]</span>
<span class="sd">    &gt;&gt;&gt; c.order.get_variables()</span>
<span class="sd">    [1, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">branch_direction</span> <span class="o">=</span> <span class="n">BranchDirection</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `BranchDirection()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OrderInterface.get">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.OrderInterface.get">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of triples (variable, priority, direction)</span>
<span class="sd">        representing the priority order for branching.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unzip</span><span class="p">(</span><span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getorder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">))</span></div>


<div class="viewcode-block" id="OrderInterface.get_variables">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.OrderInterface.get_variables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the variables for which an order has been set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">getorder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="OrderInterface.set">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.OrderInterface.set">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the priority order for branching.</span>

<span class="sd">        order must be a list of triples (variable, priority, direction).</span>

<span class="sd">        variable must be an index or name of a variable.</span>

<span class="sd">        priority must be a nonnegative integer.</span>

<span class="sd">        direction must be an attribute of order.branch_direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">ord</span> <span class="o">=</span> <span class="n">unzip</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="nb">ord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">_conv</span><span class="p">(</span><span class="nb">ord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">copyorder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="o">*</span><span class="nb">ord</span><span class="p">)</span></div>


<div class="viewcode-block" id="OrderInterface.read">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.OrderInterface.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads a priority order from a file.&quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">readcopyorder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="OrderInterface.write">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.OrderInterface.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the priority order to a file.&quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">ordwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="InitialInterface">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InitialInterface">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InitialInterface</span><span class="p">(</span><span class="n">BaseInterface</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods to set starting information for an optimization algorithm</span>
<span class="sd">    to solve continuous problems (LP, QP, QCP).</span>

<span class="sd">    Note</span>
<span class="sd">      Data passed to these methods cannot be queried immediately from</span>
<span class="sd">      the methods in Cplex.solution.  Those methods will return</span>
<span class="sd">      data only after Cplex.solve() or Cplex.feasopt() has been called.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">BasisVarStatus</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;See `BasisVarStatus()` &quot;&quot;&quot;</span>

<div class="viewcode-block" id="InitialInterface.set_start">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InitialInterface.set_start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_status</span><span class="p">,</span> <span class="n">row_status</span><span class="p">,</span> <span class="n">col_primal</span><span class="p">,</span> <span class="n">row_primal</span><span class="p">,</span>
                  <span class="n">col_dual</span><span class="p">,</span> <span class="n">row_dual</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets basis statuses, primal values, and dual values.</span>

<span class="sd">        The arguments col_status, col_primal, and col_dual are lists</span>
<span class="sd">        that either have length equal to the number of variables or</span>
<span class="sd">        are empty.  If col_status is empty, then row_status must also</span>
<span class="sd">        be empty.  If col_primal is empty, then row_primal must also</span>
<span class="sd">        be empty.</span>

<span class="sd">        The arguments row_status, row_primal, and row_dual are lists</span>
<span class="sd">        that either have length equal to the number of linear</span>
<span class="sd">        constraints or are empty.  If row_status is empty, the</span>
<span class="sd">        col_status must also be empty.  If row_dual is empty, then</span>
<span class="sd">        col_dual must also be empty.</span>

<span class="sd">        Each entry of col_status and row_status must be an attribute of</span>
<span class="sd">        Cplex.start.status.</span>

<span class="sd">        Each entry of col_primal and row_primal must be a float</span>
<span class="sd">        specifying the starting primal values for the columns and</span>
<span class="sd">        rows, respectively.</span>

<span class="sd">        Each entry of col_dual and row_dual must be a float</span>
<span class="sd">        specifying the starting dual values for the columns and rows,</span>
<span class="sd">        respectively.</span>

<span class="sd">        Note</span>
<span class="sd">          The starting information is ignored by the optimizers if the</span>
<span class="sd">          parameter cplex.parameters.advance is set to</span>
<span class="sd">          cplex.parameters.advance.values.none.</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; indices = c.variables.add(</span>
<span class="sd">        ...     names=[&quot;v{0}&quot;.format(i) for i in range(5)]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; indices = c.linear_constraints.add(</span>
<span class="sd">        ...     names=[&quot;r{0}&quot;.format(i) for i in range(3)]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s = c.start.status</span>
<span class="sd">        &gt;&gt;&gt; c.start.set_start(</span>
<span class="sd">        ...     [s.basic] * 3 + [s.at_lower_bound] * 2,</span>
<span class="sd">        ...     [s.basic] + [s.at_upper_bound] * 2,</span>
<span class="sd">        ...     [0.0] * 5,</span>
<span class="sd">        ...     [1.0] * 3,</span>
<span class="sd">        ...     [2.0] * 5,</span>
<span class="sd">        ...     [3.0] * 3</span>
<span class="sd">        ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">copystart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">col_status</span><span class="p">,</span>
                           <span class="n">row_status</span><span class="p">,</span> <span class="n">col_primal</span><span class="p">,</span> <span class="n">row_primal</span><span class="p">,</span> <span class="n">col_dual</span><span class="p">,</span>
                           <span class="n">row_dual</span><span class="p">)</span></div>


<div class="viewcode-block" id="InitialInterface.read_start">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InitialInterface.read_start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the starting information from a file.</span>

<span class="sd">        See `CPXreadcopystartinfo &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/readcopystartinfo.html&gt;`_ in the Callable Library</span>
<span class="sd">        Reference Manual and also `SolutionInterface.write()`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c1 = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c1.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c1.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c1.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c1.solve()</span>
<span class="sd">        &gt;&gt;&gt; c1.solution.write(&quot;lpex.sol&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c2 = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c2.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c2.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c2.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c2.start.read_start(&quot;lpex.sol&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">readcopystartinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="InitialInterface.read_basis">
<a class="viewcode-back" href="../../../cplex._internal.html#cplex._internal._subinterfaces.InitialInterface.read_basis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the starting basis from a file.</span>

<span class="sd">        See `CPXreadcopybase &lt;https://www.ibm.com/docs/en/SSSA5P_22.1.2/ilog.odms.cplex.help/refcallablelibrary/cpxapi/readcopybase.html&gt;`_ in the Callable Library Reference</span>
<span class="sd">        Manual and also `BasisInterface.write()`.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; import cplex</span>
<span class="sd">        &gt;&gt;&gt; c1 = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c1.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c1.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c1.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c1.solve()</span>
<span class="sd">        &gt;&gt;&gt; c1.solution.basis.write(&quot;lpex.bas&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c2 = cplex.Cplex()</span>
<span class="sd">        &gt;&gt;&gt; out = c2.set_results_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; out = c2.set_log_stream(None)</span>
<span class="sd">        &gt;&gt;&gt; c2.read(&quot;lpex.mps&quot;)</span>
<span class="sd">        &gt;&gt;&gt; c2.start.read_basis(&quot;lpex.bas&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CPX_PROC</span><span class="o">.</span><span class="n">readcopybase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">_e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cplex</span><span class="o">.</span><span class="n">_lp</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../../index.html">Table of Contents</a></h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">Cplex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Python tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../manual/index.html">CPLEX for Python users</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span></span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">CPLEX Python API documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../cplex.html" >cplex</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../_internal.html" >cplex._internal</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cplex._internal._subinterfaces</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright IBM Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    </div>
  </body>
</html>